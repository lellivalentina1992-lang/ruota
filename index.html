<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>La Ruota della Fortuna – Multiplayer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Frasi -->
  <script src="Frasi.js"></script>

  <style>
    :root {
      --bg: #001831;
      --panel: #02264a;
      --accent: #f9c642;
      --accent-2: #00c3ff;
      --danger: #ff4b4b;
      --text: #f5f5f5;
      --muted: #9fb3d1;
      --border: #0b3a6b;
      --good: #34c759;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #003973 0, #000814 55%, #000000 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 16px;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      background: linear-gradient(135deg, rgba(6, 31, 64, 0.96), rgba(1, 9, 20, 0.98));
      border-radius: 18px;
      border: 1px solid rgba(120, 180, 255, 0.35);
      box-shadow: 0 24px 80px rgba(0, 0, 0, 0.8);
      padding: 20px 18px 22px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    h1 {
      font-size: 1.4rem;
      margin: 0 0 4px;
      text-align: center;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--accent);
      text-shadow: 0 0 8px rgba(0,0,0,0.7);
    }

    .subtitle {
      text-align: center;
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 10px;
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 14px;
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: radial-gradient(circle at top, rgba(15, 52, 96, 0.95), rgba(3, 15, 31, 0.98));
      border-radius: 14px;
      border: 1px solid var(--border);
      padding: 12px 12px 14px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.5);
    }

    .panel-header {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-bottom: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.7rem;
      border: 1px solid rgba(249, 198, 66, 0.5);
      color: var(--accent);
    }

    .field-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 8px;
    }

    label {
      font-size: 0.85rem;
      color: var(--muted);
    }

    input[type="text"] {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(152, 180, 220, 0.7);
      background: rgba(1, 12, 28, 0.9);
      color: var(--text);
      font-size: 0.9rem;
    }

    input[type="text"]:focus {
      outline: 2px solid var(--accent-2);
      outline-offset: 1px;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 4px;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 6px 10px;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      background: linear-gradient(135deg, #0f68c8, #00c3ff);
      color: #ffffff;
      box-shadow: 0 0 10px rgba(0, 195, 255, 0.35);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    button:disabled {
      opacity: 0.45;
      cursor: default;
      box-shadow: none;
    }

    .btn-secondary {
      background: linear-gradient(135deg, #273447, #1c2736);
      color: var(--muted);
      border: 1px solid rgba(120, 150, 200, 0.6);
      box-shadow: none;
    }

    .btn-danger {
      background: linear-gradient(135deg, #ff4b4b, #c81e1e);
      box-shadow: 0 0 10px rgba(255, 75, 75, 0.45);
    }

    .section-title {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin: 4px 0;
    }

    .status {
      font-size: 0.9rem;
      padding: 6px 8px;
      border-radius: 8px;
      background: radial-gradient(circle at left, rgba(0,195,255,0.16), rgba(0,0,0,0.7));
      border: 1px solid rgba(0, 195, 255, 0.4);
      color: var(--text);
      min-height: 32px;
    }

    .status-strong {
      font-weight: 600;
      color: var(--accent);
    }

    /* Board */
    .board-container {
      margin-top: 4px;
      padding: 8px;
      border-radius: 10px;
      background: radial-gradient(circle at top, rgba(1, 54, 94, 0.8), rgba(0,0,0,0.85));
      border: 1px solid rgba(0, 195, 255, 0.2);
      min-height: 80px;
    }

    .board-category {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .board-phrase {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .word {
      display: inline-flex;
      gap: 4px;
      margin-right: 8px;
      margin-bottom: 4px;
    }

    .letter-box {
      width: 26px;
      height: 34px;
      border-radius: 6px;
      background: linear-gradient(180deg, #020d1e, #041e3b);
      border: 1px solid rgba(140, 180, 230, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.05rem;
      font-weight: 600;
      color: var(--accent-2);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.8);
    }

    .letter-box.revealed {
      background: linear-gradient(180deg, #f9c642, #f08a00);
      color: #00101f;
      text-shadow: 0 0 6px rgba(255,255,255,0.7);
    }

    .letter-box.space {
      background: transparent;
      border: none;
      box-shadow: none;
      width: 12px;
    }

    /* Wheel */
    .wheel-area {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .wheel-circle {
      width: 190px;
      height: 190px;
      border-radius: 50%;
      position: relative;
      margin: 6px auto 4px;
      border: 4px solid #f9c642;
      box-shadow: 0 0 15px rgba(0,0,0,0.8);
      overflow: hidden;
      background: radial-gradient(circle, #02264a 0, #000814 55%);
    }

    .wheel-pointer {
      position: absolute;
      top: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
      border-bottom: 16px solid #ff3355;
      filter: drop-shadow(0 0 4px rgba(0,0,0,0.8));
      z-index: 5;
    }

    .wheel-wedge {
      position: absolute;
      width: 50%;
      height: 50%;
      top: 50%;
      left: 50%;
      transform-origin: 0% 0%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding-right: 8px;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 0 0 4px rgba(0,0,0,0.9);
    }

    .wheel-center {
      position: absolute;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: radial-gradient(circle, #f9c642, #c57c00);
      border: 3px solid #fff;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      font-weight: 800;
      letter-spacing: 0.08em;
      color: #00101f;
    }

    .wheel-result {
      text-align: center;
      font-size: 0.9rem;
      color: var(--accent);
      min-height: 20px;
    }

    /* Scoreboard */
    .scoreboard {
      margin-top: 4px;
      padding: 8px;
      border-radius: 10px;
      background: radial-gradient(circle at top, rgba(10, 56, 110, 0.95), rgba(1, 8, 20, 0.96));
      border: 1px solid rgba(0, 195, 255, 0.2);
    }

    .score-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.9rem;
      padding: 4px 6px;
      border-radius: 8px;
      margin-bottom: 2px;
    }

    .score-row.me {
      background: rgba(0, 195, 255, 0.08);
    }

    .score-name {
      font-weight: 600;
    }

    .score-points {
      font-variant-numeric: tabular-nums;
    }

    .score-jolly {
      font-size: 0.8rem;
      color: var(--muted);
      margin-left: 6px;
    }

    .turn-indicator {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--accent-2);
    }

    /* Letter controls */
    .letters-panel {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 4px;
    }

    .inline-fields {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .inline-fields input[type="text"] {
      max-width: 70px;
      text-align: center;
    }

    .used-letters {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 2px;
    }

    .solution-panel {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px dashed rgba(120,150,200,0.4);
    }

    .log {
      font-size: 0.8rem;
      max-height: 160px;
      overflow-y: auto;
      padding: 6px;
      border-radius: 8px;
      background: radial-gradient(circle at top, rgba(5, 34, 70, 0.9), rgba(0,0,0,0.9));
      border: 1px solid rgba(0, 195, 255, 0.15);
    }

    .log-entry {
      margin-bottom: 3px;
    }

    .log-entry strong {
      color: var(--accent-2);
    }

    .sr-only {
      position: absolute !important;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
  </style>
</head>
<body>
  <main class="app" aria-label="Gioco La Ruota della Fortuna Multiplayer">
    <header>
      <h1>LA RUOTA DELLA FORTUNA – MULTIPLAYER</h1>
      <p class="subtitle">
        Stanza condivisa online, turni automatici, punteggi sincronizzati. Nessuna installazione: basta il link.
      </p>
    </header>

    <!-- Stanza e giocatore -->
    <section class="panel" aria-labelledby="room-title">
      <div class="panel-header">
        <span id="room-title">1. Dati giocatore e stanza</span>
        <span class="badge">Online realtime</span>
      </div>

      <div class="grid">
        <div>
          <div class="field-group">
            <label for="player-name">Il tuo nome (come apparirà agli altri):</label>
            <input id="player-name" type="text" autocomplete="name" placeholder="Es. Valelli">
          </div>

          <div class="field-group">
            <label for="room-code">Codice stanza (es. ABC123):</label>
            <input id="room-code" type="text" maxlength="12" placeholder="Es. RUOTA1">
          </div>

          <div class="btn-row" aria-label="Azioni sulla stanza">
            <button id="btn-create-room">Crea nuova stanza</button>
            <button id="btn-join-room" class="btn-secondary">Entra in stanza esistente</button>
          </div>

          <p class="subtitle" style="text-align:left; margin-top:4px;">
            Suggerimento: apri questa pagina da due dispositivi diversi, usa lo stesso codice stanza e verifica che ruota, punteggi e frase cambiano per tutti.
          </p>

          <div class="status" id="room-status" aria-live="polite"></div>
        </div>

        <div class="panel" style="background: radial-gradient(circle at top, rgba(6,42,90,0.95), rgba(2,13,30,0.98));">
          <div class="panel-header">
            <span>Giocatori collegati</span>
          </div>
          <div id="players-list" aria-live="polite" aria-label="Giocatori collegati"></div>
        </div>
      </div>
    </section>

    <section class="grid" aria-label="Gioco in corso">
      <!-- Colonna sinistra: frase + lettere -->
      <section class="panel" aria-labelledby="game-title">
        <div class="panel-header">
          <span id="game-title">2. Tabellone frase e lettere</span>
        </div>

        <div class="board-container">
          <div id="board-category" class="board-category">Categoria: —</div>
          <div id="board-phrase" class="board-phrase" aria-label="Tabellone della frase"></div>
        </div>

        <div class="letters-panel" aria-label="Scelte di lettere">
          <div>
            <div class="section-title">Lettere dopo il giro (consonanti)</div>
            <div class="inline-fields">
              <label for="consonant-input">Consonante da proporre:</label>
              <input id="consonant-input" type="text" maxlength="1" aria-describedby="consonant-help">
              <button id="btn-send-consonant" disabled>Invia consonante</button>
            </div>
            <div id="consonant-help" class="used-letters">
              Usa una sola lettera. Niente vocali qui: servono solo consonanti.
            </div>
          </div>

          <div>
            <div class="section-title">Vocali (a pagamento)</div>
            <div class="inline-fields">
              <label for="vowel-input">Vocale da comprare:</label>
              <input id="vowel-input" type="text" maxlength="1" aria-describedby="vowel-help">
              <button id="btn-buy-vowel" class="btn-secondary" disabled>Compra vocale</button>
              <span style="font-size:0.8rem;color:var(--muted);">Costo: 500 punti</span>
            </div>
            <div id="vowel-help" class="used-letters">
              Puoi comprare una vocale solo se è il tuo turno e hai almeno 500 punti.
            </div>
          </div>

          <div class="solution-panel">
            <div class="section-title">Tentativo di soluzione</div>
            <div class="inline-fields">
              <label for="solution-input">Prova a risolvere:</label>
              <input id="solution-input" type="text" placeholder="Scrivi la soluzione completa">
              <button id="btn-try-solution" class="btn-danger" disabled>Tenta soluzione</button>
            </div>
          </div>

          <div class="used-letters" id="used-letters">
            Lettere usate: —
          </div>
        </div>

        <div class="solution-panel">
          <div class="section-title">Ultimi eventi</div>
          <div id="log" class="log" aria-live="polite"></div>
        </div>
      </section>

      <!-- Colonna destra: ruota + punteggi -->
      <section class="panel" aria-labelledby="wheel-title">
        <div class="panel-header">
          <span id="wheel-title">3. Ruota, turni e punteggi</span>
        </div>

        <div class="wheel-area" aria-label="Ruota della fortuna">
          <div class="wheel-circle" aria-hidden="true">
            <div class="wheel-pointer"></div>
            <div id="wheel-wedges"></div>
            <div class="wheel-center">RUOTA</div>
          </div>
          <div class="btn-row" style="justify-content:center;">
            <button id="btn-spin" disabled>Gira la ruota</button>
            <button id="btn-pass-turn" class="btn-secondary" disabled>Passa turno</button>
          </div>
          <div id="wheel-result" class="wheel-result" aria-live="polite"></div>
        </div>

        <div class="scoreboard" aria-label="Tabellone punteggi">
          <div class="section-title">Tabellone punteggi</div>
          <div id="scores"></div>
          <div class="section-title">Turno corrente</div>
          <div id="turn-info" class="status"></div>
        </div>
      </section>
    </section>

    <section aria-label="Messaggi di stato globali">
      <div id="global-status" class="status" aria-live="polite"></div>
    </section>

    <div id="live-region" class="sr-only" aria-live="assertive"></div>
  </main>

  <!-- Supabase client -->
  <script src="https://unpkg.com/@supabase/supabase-js@2.48.0/dist/umd/supabase.min.js"></script>

  <script>
    // =========================
    // CONFIGURAZIONE GIOCO
    // =========================
    const VOWEL_COST = 500;
    const VOWELS = ['A','E','I','O','U'];

    const WHEEL_VALUES = [100, 200, 300, 400, 500, 1000, 2000, 'BANCAROTTA', 'PASSA', 'MISTERO', 'JOLLY'];

    const MYSTERY_EVENTS = [
      { type: "raddoppia", label: "RADDOPPIA!", prob: 0.25 },
      { type: "perdi_tutto", label: "PERDI TUTTO E PASSI!", prob: 0.20 },
      { type: "lettera_gratis", label: "LETTERA GRATIS!", prob: 0.25 },
      { type: "vocale_gratis", label: "VOCALE GRATIS!", prob: 0.15 },
      { type: "jolly_turno", label: "SALVA TURNO ATTIVO!", prob: 0.15 }
    ];

    // Supabase config (dal tuo progetto)
    const SUPABASE_URL = 'https://azcwkpdjbysnivknnino.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF6Y3drcGRqYnlzbml2a25uaW5vIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2MzAwNDksImV4cCI6MjA3OTIwNjA0OX0.R8wkMJEmsP8cTVUUOcWtD4Rrg_ZhuOE-PYBJ56eGqMU';

    const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // =========================
    // STATO LOCALE
    // =========================
    let localPlayerName = '';
    let localRoomId = '';
    let localIsCreator = false;
    let currentState = null;
    let wheelSpinning = false;
    let wheelRotation = 0;
    let wheelSegments = [];
    let realtimeChannel = null;

    // =========================
    // RIFERIMENTI DOM
    // =========================
    const elPlayerName = document.getElementById('player-name');
    const elRoomCode = document.getElementById('room-code');
    const btnCreateRoom = document.getElementById('btn-create-room');
    const btnJoinRoom = document.getElementById('btn-join-room');
    const roomStatus = document.getElementById('room-status');
    const playersList = document.getElementById('players-list');

    const boardCategory = document.getElementById('board-category');
    const boardPhrase = document.getElementById('board-phrase');

    const consonantInput = document.getElementById('consonant-input');
    const btnSendConsonant = document.getElementById('btn-send-consonant');

    const vowelInput = document.getElementById('vowel-input');
    const btnBuyVowel = document.getElementById('btn-buy-vowel');

    const solutionInput = document.getElementById('solution-input');
    const btnTrySolution = document.getElementById('btn-try-solution');

    const wheelWedgesContainer = document.getElementById('wheel-wedges');
    const btnSpin = document.getElementById('btn-spin');
    const btnPassTurn = document.getElementById('btn-pass-turn');
    const wheelResult = document.getElementById('wheel-result');

    const scoresContainer = document.getElementById('scores');
    const turnInfo = document.getElementById('turn-info');
    const globalStatus = document.getElementById('global-status');
    const usedLettersEl = document.getElementById('used-letters');
    const logEl = document.getElementById('log');
    const liveRegion = document.getElementById('live-region');

    // =========================
    // UTILITY
    // =========================
    function announce(msg) {
      if (!msg) return;
      liveRegion.textContent = '';
      setTimeout(() => {
        liveRegion.textContent = msg;
      }, 10);
    }

    function addLogEntry(text) {
      const p = document.createElement('div');
      p.className = 'log-entry';
      p.textContent = text;
      logEl.appendChild(p);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function normalizeRoomId(val) {
      return (val || '').trim().toUpperCase();
    }

    function normalizeName(val) {
      return (val || '').trim();
    }

    function clone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    function pickRandomPhrase() {
      if (typeof phrasesDB === 'undefined' || !Array.isArray(phrasesDB) || phrasesDB.length === 0) {
        return {
          category: 'ESPRESSIONE',
          solution: 'LA RUOTA DELLA FORTUNA'
        };
      }
      const idx = Math.floor(Math.random() * phrasesDB.length);
      const base = phrasesDB[idx];
      return {
        category: base.category || 'CATEGORIA',
        solution: (base.solution || '').toUpperCase()
      };
    }

    function buildInitialState(roomId, creatorName) {
      const phraseObj = pickRandomPhrase();
      const solution = phraseObj.solution;
      const totalLetters = solution.replace(/ /g, '').length;
      const players = [creatorName];

      const scores = {};
      const jollies = {};
      players.forEach(n => {
        scores[n] = 0;
        jollies[n] = 0;
      });

      return {
        roomId: roomId,
        createdAt: new Date().toISOString(),
        players,
        currentPlayerIndex: 0,
        scores,
        jollies,
        phrase: {
          category: phraseObj.category,
          solution: solution,
          revealedIndices: [],
          usedConsonants: [],
          usedVowels: []
        },
        wheel: {
          lastValue: null,
          lastLabel: '',
          lastPlayer: null
        },
        pendingAction: null,
        gameStatus: 'playing',
        winner: null,
        lastMessage: 'Nuova partita. Categoria: ' + phraseObj.category + '. Totale lettere: ' + totalLetters + '.',
        lastUpdateBy: creatorName
      };
    }

    function isPlayersTurn(state, name) {
      if (!state || !state.players || state.players.length === 0) return false;
      const idx = state.currentPlayerIndex || 0;
      return state.players[idx] === name;
    }

    function nextPlayerIndex(state) {
      if (!state.players || state.players.length === 0) return 0;
      const len = state.players.length;
      const cur = state.currentPlayerIndex || 0;
      return (cur + 1) % len;
    }

    function allLettersRevealed(state) {
      const sol = state.phrase.solution;
      const indexes = state.phrase.revealedIndices || [];
      for (let i = 0; i < sol.length; i++) {
        const ch = sol[i];
        if (ch.match(/[A-ZÀ-Ù]/)) {
          if (!indexes.includes(i)) return false;
        }
      }
      return true;
    }

    // =========================
    // SUPABASE – STATO STANZA
    // =========================
    async function upsertState(state, announceText) {
      try {
        const payload = {
          id: state.roomId,
          state: state,
          updated_at: new Date().toISOString()
        };
        const { error } = await supabaseClient
          .from('rooms')
          .upsert(payload);
        if (error) {
          console.error('Errore upsert Supabase', error);
          globalStatus.textContent = 'Errore di connessione al server (Supabase).';
          return;
        }
        if (announceText) {
          addLogEntry(announceText);
          announce(announceText);
          globalStatus.textContent = announceText;
        }
      } catch (err) {
        console.error('Eccezione upsert', err);
        globalStatus.textContent = 'Errore imprevisto durante il salvataggio.';
      }
    }

    async function fetchState(roomId) {
      const { data, error } = await supabaseClient
        .from('rooms')
        .select('state')
        .eq('id', roomId)
        .single();
      if (error) {
        return null;
      }
      return data.state;
    }

    function subscribeToRoom(roomId) {
      if (realtimeChannel) {
        supabaseClient.removeChannel(realtimeChannel);
        realtimeChannel = null;
      }

      realtimeChannel = supabaseClient
        .channel('rooms-' + roomId)
        .on(
          'postgres_changes',
          { event: 'UPDATE', schema: 'public', table: 'rooms', filter: 'id=eq.' + roomId },
          payload => {
            const newState = payload.new.state;
            currentState = newState;
            renderAll();
          }
        )
        .subscribe(status => {
          console.log('Realtime status', status);
        });
    }

    // =========================
    // RENDERING UI
    // =========================
    function renderPlayersList() {
      if (!currentState) {
        playersList.textContent = 'Nessuna stanza attiva.';
        return;
      }
      const players = currentState.players || [];
      if (players.length === 0) {
        playersList.textContent = 'Nessun giocatore.';
        return;
      }
      playersList.innerHTML = '';
      const ul = document.createElement('ul');
      for (const p of players) {
        const li = document.createElement('li');
        li.textContent = p + (p === localPlayerName ? ' (tu)' : '');
        ul.appendChild(li);
      }
      playersList.appendChild(ul);
    }

    function renderBoard() {
      if (!currentState || !currentState.phrase) {
        boardCategory.textContent = 'Categoria: —';
        boardPhrase.innerHTML = '';
        return;
      }
      const phrase = currentState.phrase;
      boardCategory.textContent = 'Categoria: ' + phrase.category;

      const sol = phrase.solution;
      const revealedIndices = phrase.revealedIndices || [];

      boardPhrase.innerHTML = '';
      const words = sol.split(' ');
      let absIndex = 0;

      words.forEach((word, wIdx) => {
        const wDiv = document.createElement('div');
        wDiv.className = 'word';

        for (let i = 0; i < word.length; i++) {
          const ch = word[i];
          const box = document.createElement('div');
          if (ch.match(/[A-ZÀ-Ù]/)) {
            box.className = 'letter-box';
            if (revealedIndices.includes(absIndex)) {
              box.classList.add('revealed');
              box.textContent = ch;
            } else {
              box.textContent = '';
            }
            absIndex++;
          } else {
            box.className = 'letter-box';
            box.textContent = ch;
            box.classList.add('revealed');
            absIndex++;
          }
          wDiv.appendChild(box);
        }
        boardPhrase.appendChild(wDiv);
        if (wIdx < words.length - 1) {
          const space = document.createElement('div');
          space.className = 'letter-box space';
          boardPhrase.appendChild(space);
          absIndex++;
        }
      });
    }

    function renderScores() {
      if (!currentState) {
        scoresContainer.innerHTML = 'Nessun punteggio.';
        turnInfo.textContent = 'Nessuna partita attiva.';
        return;
      }
      const players = currentState.players || [];
      const scores = currentState.scores || {};
      const jollies = currentState.jollies || {};
      const curIdx = currentState.currentPlayerIndex || 0;
      const curPlayer = players[curIdx] || null;

      scoresContainer.innerHTML = '';
      players.forEach(p => {
        const row = document.createElement('div');
        row.className = 'score-row';
        if (p === localPlayerName) {
          row.classList.add('me');
        }
        const nameEl = document.createElement('div');
        nameEl.className = 'score-name';
        nameEl.textContent = p;

        const right = document.createElement('div');
        const pts = document.createElement('span');
        pts.className = 'score-points';
        pts.textContent = (scores[p] || 0) + ' punti';

        const jEl = document.createElement('span');
        jEl.className = 'score-jolly';
        jEl.textContent = 'Jolly: ' + (jollies[p] || 0);

        right.appendChild(pts);
        right.appendChild(jEl);

        row.appendChild(nameEl);
        row.appendChild(right);

        scoresContainer.appendChild(row);
      });

      if (currentState.gameStatus === 'won' && currentState.winner) {
        turnInfo.innerHTML = '<span class="status-strong">Partita conclusa.</span> Ha vinto: ' + currentState.winner + '.';
      } else {
        turnInfo.innerHTML = 'Sta giocando: <span class="status-strong">' + (curPlayer || '—') + '</span>';
      }
    }

    function renderUsedLetters() {
      if (!currentState || !currentState.phrase) {
        usedLettersEl.textContent = 'Lettere usate: —';
        return;
      }
      const c = currentState.phrase.usedConsonants || [];
      const v = currentState.phrase.usedVowels || [];
      const all = c.concat(v);
      if (all.length === 0) {
        usedLettersEl.textContent = 'Lettere usate: —';
      } else {
        usedLettersEl.textContent = 'Lettere usate: ' + all.join(', ');
      }
    }

    function renderWheel() {
      if (wheelSegments.length === 0) {
        // build
        let segments = [...WHEEL_VALUES];
        while (segments.length < 12) {
          segments.push(Math.floor(Math.random() * 500) + 100);
        }
        segments = segments.slice(0, 12);
        const arcSize = 360 / segments.length;
        const colors = ['#ff5733', '#33c4ff', '#00c55a', '#ffb533', '#ff33a1', '#9b59ff'];

        wheelWedgesContainer.innerHTML = '';
        wheelSegments = segments.map((val, i) => {
          const el = document.createElement('div');
          el.className = 'wheel-wedge';
          const rotation = i * arcSize;
          const skew = 90 - arcSize;
          el.style.transform = 'rotate(' + rotation + 'deg) skewY(' + skew + 'deg)';
          el.style.background = colors[i % colors.length];
          el.textContent = typeof val === 'number' ? val.toString() : val;
          wheelWedgesContainer.appendChild(el);
          return { value: val, startAngle: rotation, endAngle: rotation + arcSize };
        });
      }
      // niente da ridisegnare dinamicamente per ora
    }

    function renderControls() {
      if (!currentState) {
        btnSpin.disabled = true;
        btnPassTurn.disabled = true;
        btnSendConsonant.disabled = true;
        btnBuyVowel.disabled = true;
        btnTrySolution.disabled = true;
        return;
      }
      const isMyTurn = isPlayersTurn(currentState, localPlayerName);
      const pending = currentState.pendingAction;

      const myScore = (currentState.scores && currentState.scores[localPlayerName]) || 0;

      // Spin possibile solo se è il mio turno, partita in corso e nessuna azione pendente
      btnSpin.disabled = !(
        isMyTurn &&
        currentState.gameStatus === 'playing' &&
        (!pending || pending.type === null)
      );

      // Passa turno possibile solo se è il mio turno e partita in corso
      btnPassTurn.disabled = !(isMyTurn && currentState.gameStatus === 'playing');

      // Consonante: solo se pendingAction è "consonant" per me
      btnSendConsonant.disabled = !(
        isMyTurn &&
        currentState.gameStatus === 'playing' &&
        pending &&
        pending.type === 'consonant' &&
        pending.player === localPlayerName
      );

      // Compra vocale: se è il mio turno, ho abbastanza punti, partita in corso
      btnBuyVowel.disabled = !(
        isMyTurn &&
        currentState.gameStatus === 'playing' &&
        myScore >= VOWEL_COST
      );

      // Tentativo soluzione: se è il mio turno e partita in corso
      btnTrySolution.disabled = !(isMyTurn && currentState.gameStatus === 'playing');
    }

    function renderGlobalStatus() {
      if (!currentState) {
        globalStatus.textContent = 'Nessuna partita attiva.';
        return;
      }
      globalStatus.textContent = currentState.lastMessage || '';
    }

    function renderAll() {
      renderPlayersList();
      renderBoard();
      renderScores();
      renderUsedLetters();
      renderWheel();
      renderControls();
      renderGlobalStatus();
    }

    // =========================
    // LOGICA DI GIOCO
    // =========================
    async function handleCreateRoom() {
      const name = normalizeName(elPlayerName.value);
      const roomId = normalizeRoomId(elRoomCode.value);

      if (!name || !roomId) {
        roomStatus.textContent = 'Inserisci sia il tuo nome sia il codice stanza.';
        return;
      }

      localPlayerName = name;
      localRoomId = roomId;
      localIsCreator = true;

      const state = buildInitialState(roomId, name);
      currentState = state;

      subscribeToRoom(roomId);
      roomStatus.textContent = 'Stanza ' + roomId + ' creata. Attendi gli altri giocatori.';
      await upsertState(state, 'Stanza ' + roomId + ' creata. Categoria: ' + state.phrase.category + '.');
      renderAll();
    }

    async function handleJoinRoom() {
      const name = normalizeName(elPlayerName.value);
      const roomId = normalizeRoomId(elRoomCode.value);

      if (!name || !roomId) {
        roomStatus.textContent = 'Inserisci sia il tuo nome sia il codice stanza.';
        return;
      }

      localPlayerName = name;
      localRoomId = roomId;
      localIsCreator = false;

      const existing = await fetchState(roomId);
      if (!existing) {
        roomStatus.textContent = 'Stanza non trovata: ' + roomId + '. Chiedi al creatore di avviarla.';
        return;
      }

      const state = clone(existing);
      state.lastUpdateBy = name;

      if (!state.players.includes(name)) {
        state.players.push(name);
        if (!state.scores[name]) state.scores[name] = 0;
        if (!state.jollies[name]) state.jollies[name] = 0;
        state.lastMessage = name + ' è entrato nella stanza.';
      } else {
        state.lastMessage = name + ' è rientrato nella stanza.';
      }

      currentState = state;

      subscribeToRoom(roomId);
      roomStatus.textContent = 'Sei entrata nella stanza ' + roomId + '.';
      await upsertState(state, state.lastMessage);
      renderAll();
    }

    function spinWheelValue() {
      // Per semplicità: scegliamo uno degli spicchi WHEEL_VALUES
      const idx = Math.floor(Math.random() * WHEEL_VALUES.length);
      return WHEEL_VALUES[idx];
    }

    async function handleSpin() {
      if (!currentState) return;
      if (wheelSpinning) return;
      if (!isPlayersTurn(currentState, localPlayerName)) return;
      if (currentState.gameStatus !== 'playing') return;
      if (currentState.pendingAction && currentState.pendingAction.type) return;

      wheelSpinning = true;
      btnSpin.disabled = true;

      const value = spinWheelValue();

      // Finta animazione: aggiorniamo subito il testo, la grafica della ruota non è fondamentale per NVDA
      setTimeout(async () => {
        wheelSpinning = false;

        const state = clone(currentState);
        state.wheel.lastValue = value;
        state.wheel.lastPlayer = localPlayerName;
        state.wheel.lastLabel = typeof value === 'number' ? ('Hai fatto ' + value + ' punti potenziali.') : value;
        state.lastUpdateBy = localPlayerName;

        let announceText = '';

        if (typeof value === 'number') {
          // azione pendente: scegliere consonante
          state.pendingAction = {
            type: 'consonant',
            player: localPlayerName,
            value: value
          };
          state.lastMessage = localPlayerName + ' ha fatto ' + value + '. Deve scegliere una consonante.';
          announceText = state.lastMessage;
        } else {
          // caselle speciali
          switch (value) {
            case 'BANCAROTTA': {
              const curScore = state.scores[localPlayerName] || 0;
              if ((state.jollies[localPlayerName] || 0) > 0) {
                state.jollies[localPlayerName] -= 1;
                state.lastMessage = localPlayerName + ' ha pescato BANCAROTTA ma usa un Jolly e salva i punti.';
              } else {
                state.scores[localPlayerName] = 0;
                state.currentPlayerIndex = nextPlayerIndex(state);
                state.lastMessage = localPlayerName + ' ha pescato BANCAROTTA e perde tutti i punti. Il turno passa al giocatore successivo.';
              }
              announceText = state.lastMessage;
              break;
            }
            case 'PASSA': {
              state.currentPlayerIndex = nextPlayerIndex(state);
              state.lastMessage = localPlayerName + ' ha pescato PASSA. Il turno passa al giocatore successivo.';
              announceText = state.lastMessage;
              break;
            }
            case 'JOLLY': {
              state.jollies[localPlayerName] = (state.jollies[localPlayerName] || 0) + 1;
              state.lastMessage = localPlayerName + ' ha trovato un Jolly!';
              announceText = state.lastMessage;
              break;
            }
            case 'MISTERO': {
              const rand = Math.random();
              let acc = 0;
              let event = MYSTERY_EVENTS[0];
              for (const e of MYSTERY_EVENTS) {
                acc += e.prob;
                if (rand <= acc) { event = e; break; }
              }
              state.lastMessage = localPlayerName + ' ha pescato MISTERO: ' + event.label;
              announceText = state.lastMessage;

              switch (event.type) {
                case 'raddoppia': {
                  state.scores[localPlayerName] = (state.scores[localPlayerName] || 0) * 2;
                  break;
                }
                case 'perdi_tutto': {
                  state.scores[localPlayerName] = 0;
                  state.currentPlayerIndex = nextPlayerIndex(state);
                  state.lastMessage += ' Tutti i punti azzerati. Il turno passa.';
                  break;
                }
                case 'lettera_gratis': {
                  state.pendingAction = {
                    type: 'consonant_free',
                    player: localPlayerName,
                    value: 0
                  };
                  state.lastMessage += ' Può scegliere una consonante gratis.';
                  break;
                }
                case 'vocale_gratis': {
                  state.pendingAction = {
                    type: 'vowel_free',
                    player: localPlayerName,
                    value: 0
                  };
                  state.lastMessage += ' Può scegliere una vocale gratis.';
                  break;
                }
                case 'jolly_turno': {
                  state.jollies[localPlayerName] = (state.jollies[localPlayerName] || 0) + 1;
                  state.lastMessage += ' Riceve un Jolly.';
                  break;
                }
              }
              break;
            }
          }
        }

        currentState = state;
        await upsertState(state, announceText || state.lastMessage);
        renderAll();
      }, 400);
    }

    async function handlePassTurn() {
      if (!currentState) return;
      if (!isPlayersTurn(currentState, localPlayerName)) return;
      if (currentState.gameStatus !== 'playing') return;

      const state = clone(currentState);
      state.currentPlayerIndex = nextPlayerIndex(state);
      state.pendingAction = null;
      state.lastUpdateBy = localPlayerName;
      state.lastMessage = localPlayerName + ' passa volontariamente il turno.';
      currentState = state;
      await upsertState(state, state.lastMessage);
      renderAll();
    }

    function letterAlreadyUsed(state, letter) {
      const p = state.phrase;
      letter = letter.toUpperCase();
      return (p.usedConsonants || []).includes(letter) || (p.usedVowels || []).includes(letter);
    }

    function revealLetterPositions(state, letter) {
      const sol = state.phrase.solution;
      const arr = state.phrase.revealedIndices || [];
      let count = 0;
      letter = letter.toUpperCase();

      let absIndex = 0;
      const words = sol.split(' ');
      words.forEach((word, wIdx) => {
        for (let i = 0; i < word.length; i++) {
          const ch = word[i];
          if (ch.match(/[A-ZÀ-Ù]/)) {
            if (ch === letter && !arr.includes(absIndex)) {
              arr.push(absIndex);
              count++;
            }
            absIndex++;
          } else {
            absIndex++;
          }
        }
        if (wIdx < words.length - 1) {
          absIndex++;
        }
      });

      state.phrase.revealedIndices = arr;
      return count;
    }

    async function handleSendConsonant() {
      if (!currentState) return;
      const state = clone(currentState);
      const pending = state.pendingAction;
      if (!pending || !pending.type || !pending.type.startsWith('consonant')) return;
      if (!isPlayersTurn(state, localPlayerName)) return;
      if (pending.player !== localPlayerName) return;

      let letter = (consonantInput.value || '').toUpperCase().trim();
      consonantInput.value = '';

      if (!letter.match(/^[A-ZÀ-Ù]$/)) {
        globalStatus.textContent = 'Inserisci una singola lettera.';
        announce('Errore: inserisci una sola lettera.');
        return;
      }
      if (VOWELS.includes(letter)) {
        globalStatus.textContent = 'Qui puoi usare solo consonanti.';
        announce('Errore: qui puoi usare solo consonanti.');
        return;
      }
      if (letterAlreadyUsed(state, letter)) {
        globalStatus.textContent = 'Lettera già utilizzata.';
        announce('Lettera già usata.');
        return;
      }

      const isFree = pending.type === 'consonant_free';
      const baseValue = pending.value || 0;

      const hits = revealLetterPositions(state, letter);
      state.phrase.usedConsonants = state.phrase.usedConsonants || [];
      state.phrase.usedConsonants.push(letter);

      let msg = '';

      if (hits > 0) {
        const gain = isFree ? 0 : baseValue * hits;
        state.scores[localPlayerName] = (state.scores[localPlayerName] || 0) + gain;
        msg = localPlayerName + ' ha scelto la consonante ' + letter + ', presente ' + hits + ' volte.';
        if (!isFree) {
          msg += ' Guadagna ' + gain + ' punti.';
        } else {
          msg += ' Lettera gratis: nessun costo.';
        }

        // turno resta allo stesso giocatore
      } else {
        msg = localPlayerName + ' ha scelto la consonante ' + letter + ', che non è presente.';
        // se ha un jolly lo può usare per NON perdere il turno
        if ((state.jollies[localPlayerName] || 0) > 0) {
          state.jollies[localPlayerName] -= 1;
          msg += ' Usa un Jolly e mantiene il turno.';
        } else {
          state.currentPlayerIndex = nextPlayerIndex(state);
          msg += ' Il turno passa al giocatore successivo.';
        }
      }

      state.pendingAction = null;
      state.lastUpdateBy = localPlayerName;
      state.lastMessage = msg;

      if (allLettersRevealed(state)) {
        state.gameStatus = 'won';
        state.winner = localPlayerName;
        state.lastMessage += ' Tutte le lettere sono state rivelate. ' + localPlayerName + ' vince il round!';
      }

      currentState = state;
      await upsertState(state, msg);
      renderAll();
    }

    async function handleBuyVowel() {
      if (!currentState) return;
      const state = clone(currentState);
      if (!isPlayersTurn(state, localPlayerName)) return;
      if (state.gameStatus !== 'playing') return;

      let letter = (vowelInput.value || '').toUpperCase().trim();
      vowelInput.value = '';

      if (!letter.match(/^[A-ZÀ-Ù]$/)) {
        globalStatus.textContent = 'Inserisci una singola lettera.';
        announce('Errore: inserisci una sola lettera.');
        return;
      }
      if (!VOWELS.includes(letter)) {
        globalStatus.textContent = 'Qui puoi usare solo vocali.';
        announce('Errore: qui puoi usare solo vocali.');
        return;
      }
      if (letterAlreadyUsed(state, letter)) {
        globalStatus.textContent = 'Lettera già utilizzata.';
        announce('Lettera già usata.');
        return;
      }

      // controlla se è gratuita (da MISTERO)
      let isFree = false;
      if (state.pendingAction && state.pendingAction.type === 'vowel_free' && state.pendingAction.player === localPlayerName) {
        isFree = true;
      }

      const curScore = state.scores[localPlayerName] || 0;
      if (!isFree && curScore < VOWEL_COST) {
        globalStatus.textContent = 'Non hai abbastanza punti per comprare una vocale.';
        announce('Punti insufficienti per la vocale.');
        return;
      }

      const hits = revealLetterPositions(state, letter);
      state.phrase.usedVowels = state.phrase.usedVowels || [];
      state.phrase.usedVowels.push(letter);

      let msg = '';
      if (hits > 0) {
        if (!isFree) {
          state.scores[localPlayerName] = curScore - VOWEL_COST;
          msg = localPlayerName + ' compra la vocale ' + letter + ', presente ' + hits + ' volte e paga ' + VOWEL_COST + ' punti.';
        } else {
          msg = localPlayerName + ' usa una VOCALE GRATIS: ' + letter + ', presente ' + hits + ' volte.';
        }
      } else {
        if (!isFree) {
          state.scores[localPlayerName] = curScore - VOWEL_COST;
          msg = localPlayerName + ' compra la vocale ' + letter + ', che non è presente e paga comunque ' + VOWEL_COST + ' punti.';
        } else {
          msg = localPlayerName + ' usa una VOCALE GRATIS: ' + letter + ', che non è presente.';
        }
        // di solito il turno resta, ma puoi cambiare regola se vuoi
      }

      // consuma eventuale pendingAction di tipo vowel_free
      if (state.pendingAction && state.pendingAction.type === 'vowel_free' && state.pendingAction.player === localPlayerName) {
        state.pendingAction = null;
      }

      state.lastUpdateBy = localPlayerName;
      state.lastMessage = msg;

      if (allLettersRevealed(state)) {
        state.gameStatus = 'won';
        state.winner = localPlayerName;
        state.lastMessage += ' Tutte le lettere sono state rivelate. ' + localPlayerName + ' vince il round!';
      }

      currentState = state;
      await upsertState(state, msg);
      renderAll();
    }

    async function handleTrySolution() {
      if (!currentState) return;
      const state = clone(currentState);
      if (!isPlayersTurn(state, localPlayerName)) return;
      if (state.gameStatus !== 'playing') return;

      const attemptRaw = (solutionInput.value || '').trim();
      solutionInput.value = '';
      if (!attemptRaw) return;

      const attempt = attemptRaw.toUpperCase().replace(/\s+/g, ' ').trim();
      const sol = state.phrase.solution.toUpperCase().replace(/\s+/g, ' ').trim();

      let msg = '';
      if (attempt === sol) {
        state.gameStatus = 'won';
        state.winner = localPlayerName;

        // rivela tutte le lettere
        const idxs = [];
        const s = state.phrase.solution;
        let absIndex = 0;
        const words = s.split(' ');
        words.forEach((word, wIdx) => {
          for (let i = 0; i < word.length; i++) {
            const ch = word[i];
            if (ch.match(/[A-ZÀ-Ù]/)) {
              idxs.push(absIndex);
              absIndex++;
            } else {
              absIndex++;
            }
          }
          if (wIdx < words.length - 1) {
            absIndex++;
          }
        });
        state.phrase.revealedIndices = idxs;

        msg = localPlayerName + ' ha indovinato la soluzione: ' + sol + '. Vince il round!';
      } else {
        msg = localPlayerName + ' ha tentato una soluzione sbagliata.';
        // se ha jolly può tenerlo, altrimenti perde il turno
        if ((state.jollies[localPlayerName] || 0) > 0) {
          state.jollies[localPlayerName] -= 1;
          msg += ' Usa un Jolly e mantiene il turno.';
        } else {
          state.currentPlayerIndex = nextPlayerIndex(state);
          msg += ' Il turno passa al giocatore successivo.';
        }
      }

      state.pendingAction = null;
      state.lastUpdateBy = localPlayerName;
      state.lastMessage = msg;

      currentState = state;
      await upsertState(state, msg);
      renderAll();
    }

    // =========================
    // EVENT LISTENERS
    // =========================
    btnCreateRoom.addEventListener('click', handleCreateRoom);
    btnJoinRoom.addEventListener('click', handleJoinRoom);
    btnSpin.addEventListener('click', handleSpin);
    btnPassTurn.addEventListener('click', handlePassTurn);
    btnSendConsonant.addEventListener('click', handleSendConsonant);
    btnBuyVowel.addEventListener('click', handleBuyVowel);
    btnTrySolution.addEventListener('click', handleTrySolution);

    consonantInput.addEventListener('keyup', (e) => {
      if (e.key === 'Enter') {
        btnSendConsonant.click();
      }
    });

    vowelInput.addEventListener('keyup', (e) => {
      if (e.key === 'Enter') {
        btnBuyVowel.click();
      }
    });

    solutionInput.addEventListener('keyup', (e) => {
      if (e.key === 'Enter') {
        btnTrySolution.click();
      }
    });

    // Inizializza ruota
    renderWheel();
  </script>
</body>
</html>
