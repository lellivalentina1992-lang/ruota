<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>La Ruota</title>
  <link rel="icon" href="data:," />
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
  
  const _supabase = supabase.createClient(
    'https://azcwkpdjbysnivknnino.supabase.co',
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF6Y3drcGRqYnlzbml2a25uaW5vIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2MzAwNDksImV4cCI6MjA3OTIwNjA0OX0.R8wkMJEmsP8cTVUUOcWtD4Rrg_ZhuOE-PYBJ56eGqMU'
  );



  
  window.onerror = function(msg, url, line) {
    if (!msg || typeof msg !== 'string') return false;
    if(msg.includes('ResizeObserver')) return false;

    if (msg.toLowerCase().includes('null') || msg.toLowerCase().includes('undefined') || msg.toLowerCase().includes('tolowercase')) {
      if(document.getElementById('airbag-error-box')) return;
      const box = document.createElement('div');
      box.id = 'airbag-error-box';
      box.setAttribute('role', 'alertdialog');
      box.setAttribute('aria-labelledby', 'error-title');
      box.style = "position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:rgba(40,0,0,0.95); border:4px solid red; color:white; padding:30px; z-index:99999; font-family:sans-serif; text-align:center; box-shadow:0 0 50px red; border-radius:15px; min-width:300px;";
      box.innerHTML = `
        <h2 id='error-title' style='margin-top:0; color:#ff5555'>ERRORE RILEVATO</h2>
        <div style="display:flex; flex-direction:column; gap:10px;">
          <button id="btn-ignore-err" style="padding:15px; background:#444; color:#fff; border:1px solid #fff; font-weight:bold; cursor:pointer; font-size:1.1em;">IGNORA E CONTINUA</button>
          <button onclick="window.location.reload()" style="padding:10px; background:transparent; color:#aaa; border:1px solid #555; cursor:pointer;">Aggiorna Pagina (F5)</button>
        </div>
      `;
      document.body.appendChild(box);
      setTimeout(() => document.getElementById('btn-ignore-err')?.focus(), 100);
      document.getElementById('btn-ignore-err').onclick = function(){ box.remove(); };
      return true; 
    }
  };
</script>

  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-body:#050505; --bg-panel:#1a1a1a;
      --col-text:#fff; --col-accent:#ffd700; --col-neon:#00ffff; --col-green:#00ff00;
      --font-main:'Roboto Condensed',sans-serif;
    }
    body{background:var(--bg-body);color:var(--col-text);font-family:var(--font-main);margin:0;padding:0;text-align:center;overflow-x:hidden;padding-bottom:150px;} 
    body.high-contrast{--bg-body:#000;--bg-panel:#000;--col-text:#fff;--col-accent:#ff0;--col-neon:#0f0;}
    .sr-only{position:absolute;width:1px;height:1px;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);}
    *:focus{outline:none;box-shadow:0 0 0 4px var(--col-neon);border-radius:4px;z-index:10000;}
    .container{max-width:900px;margin:0 auto;padding:10px;display:flex;flex-direction:column;align-items:center;}
    
    .hidden{display:none !important; visibility: hidden !important; pointer-events: none !important;}
    
    .info-bar{width:100%;display:flex;justify-content:space-between;align-items:center;background:linear-gradient(90deg,#222,#333,#222);padding:10px 15px;border-radius:0 0 15px 15px;border-bottom:2px solid #444;box-sizing:border-box;}
    .timer-display{font-size:2em;color:#ff4444;text-shadow:0 0 10px #ff0000;font-weight:900;min-width:60px;}
    .stats-display{text-align:right;font-size:1.1em;line-height:1.2;color:#ddd;}
    .money-box{margin-top:5px;display:flex;gap:15px;justify-content:center;font-size:1.3em;color:var(--col-accent);text-shadow:0 0 5px rgba(255,215,0,.5);}
    .section-header{width:95%;text-align:left;margin:15px 0 5px 0;color:#888;border-bottom:1px solid #444;padding-bottom:5px;font-size:1em;text-transform:uppercase;letter-spacing:1px;display:none;}
    body.accessible-mode .section-header{display:block;}
    .acc-nav { display: none; width: 98%; max-width: 800px; margin: 10px auto 5px auto; gap: 8px; }
    body.accessible-mode .acc-nav { display: grid; grid-template-columns: 1fr; }
    .acc-nav button { font-size: 0.95em; padding: 12px 10px; min-height: 52px; }
    @media (min-width: 769px) { body.accessible-mode .acc-nav { grid-template-columns: repeat(2, 1fr); } }
    
    /* Nascondi pulsanti ridondanti in modalità STANDARD (con tastiera) */
    body:not(.accessible-mode) #btn-inspect-word,
    body:not(.accessible-mode) #btn-letters,
    body:not(.accessible-mode) #btn-chat,
    body:not(.accessible-mode) #btn-management {
      display: none !important;
    }

    #game-panel{width:100%;max-width:800px;margin-top:10px;display:flex;flex-direction:column;gap:5px;}
    .category-box{order:0;margin:5px 0;}
    #live-category{color:var(--col-neon);font-size:1.8em;margin:0;text-transform:uppercase;letter-spacing:2px;text-shadow:0 0 10px var(--col-neon);}
    #category-main{display:block;}
    #round-hint{display:block;color:#fff;font-size:0.67em;font-weight:normal;margin-top:5px;opacity:.8;text-transform:none;letter-spacing:normal;text-shadow:none;}

    .top-controls-wrapper{order:1;width:100%;margin-bottom:5px;}
    .controls-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;width:98%;margin:0 auto;}
    .bottom-controls-wrapper{order:3;width:98%;margin:10px auto;}

    button.action-btn{background:linear-gradient(180deg,#333,#111);color:#fff;border:1px solid #555;border-radius:8px;padding:15px 5px;font-size:1.1em;font-weight:bold;text-transform:uppercase;cursor:pointer;box-shadow:0 4px 0 #000;transition:all .1s;font-family:var(--font-main);display:flex;align-items:center;justify-content:center;min-height:60px;}
    button.action-btn:active{transform:translateY(4px);box-shadow:0 0 0 #000;}
    button.action-btn:disabled{opacity:.5;cursor:not-allowed;filter:grayscale(1);transform:none;box-shadow:none;color:#777;border-color:#333;}

    .btn-spin{background:linear-gradient(180deg,#ffd700,#b8860b);color:#000;border-color:#ffd700;text-shadow:0 1px 0 rgba(255,255,255,.4);font-size:1.3em;}
    .btn-vowel{background:linear-gradient(180deg,#00ffff,#008b8b);color:#000;border-color:#00ffff;}
    .btn-solve{background:linear-gradient(180deg,#ff4444,#8b0000);border-color:#ff4444;width:100%;font-size:1.5em;padding:20px;letter-spacing:2px;}
    .btn-pass{background:#444;color:#aaa;}
    .btn-chat{background:#222;border:1px solid #444;color:#ccc;}

    .board-wrapper{order:2;width:100%;}
    #board-container{display:flex;flex-direction:column;align-items:center;gap:8px;padding:15px;margin:0;min-height:100px;background:rgba(0,50,0,.3);border:2px solid #004400;border-radius:15px;}
    .board-row{display:flex;gap:4px;flex-wrap:wrap;justify-content:center;}
    .tile{width:35px;height:55px;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:1.8em;color:#000;background:#fff;border-radius:4px;box-shadow:2px 2px 5px #000;}
    .tile.empty{background:#003300;border:1px solid #005500;box-shadow:inset 0 0 5px #000;}
    .tile.revealed{background:#fff;animation:popIn .3s cubic-bezier(.175,.885,.32,1.275);}
    .tile.cursor-word{outline:3px solid var(--col-neon);box-shadow:0 0 15px var(--col-neon);}
    .tile.cursor-char{border:4px solid var(--col-accent);transform:scale(1.1);z-index:20;}

    @keyframes popIn{from{transform:scale(0);}to{transform:scale(1);}}

    #accessible-board-container{display:none;width:98%;margin:0 auto;text-align:left;}
    #acc-board-summary{background:#111;color:#aaa;padding:10px;margin-bottom:10px;border:1px solid #333;border-radius:8px;font-size:1em;}
    #acc-word-list{display:flex;flex-direction:column;gap:5px;}
    .acc-word-btn{display:flex;justify-content:space-between;width:100%;background:#222;border:1px solid #555;color:#fff;padding:15px;margin-bottom:8px;border-radius:8px;font-size:1.3em;font-family:monospace;letter-spacing:1px;cursor:pointer;}
    body.accessible-mode #board-container{display:none;}
    body.accessible-mode #accessible-board-container{display:block;}
    
    /* Nascondi sezioni duplicate in Vista Testo */
    body.accessible-mode .top-controls-wrapper{display:none;}
    body.accessible-mode .bottom-controls-wrapper{display:none;}
    body.accessible-mode #wheel-visual-wrap{display:none;}
    body.accessible-mode #audio-panel{display:none;}
    
    /* Disabilita animazioni e effetti pesanti in Vista Testo */
    body.accessible-mode *{
      animation: none !important;
      transition: none !important;
      backdrop-filter: none !important;
      filter: none !important;
      box-shadow: none !important;
      text-shadow: none !important;
      background-image: none !important;
    }
    
    /* Sfondi semplici per i pulsanti principali */
    body.accessible-mode .btn-spin{background: #b8860b !important;}
    body.accessible-mode .btn-vowel{background: #008b8b !important;}
    body.accessible-mode .btn-solve{background: #8b0000 !important;}
    body.accessible-mode button.action-btn{background: #222 !important;}
    
    /* Mantieni solo il focus outline */
    body.accessible-mode *:focus{
      box-shadow: 0 0 0 4px var(--col-neon) !important;
    }

    #wheel-visual-wrap{width:100%;display:flex;flex-direction:column;align-items:center;gap:8px;margin:8px 0;}
    #wheel-visual{
      width:220px;height:220px;border-radius:50%;
      border:4px solid #111;box-shadow:0 0 25px rgba(255,215,0,.15), inset 0 0 10px rgba(0,0,0,.8);
      background:conic-gradient(#ffd700 0deg 30deg,#00ffff 30deg 60deg,#ff4444 60deg 90deg,#00ff00 90deg 120deg,#ffd700 120deg 150deg,#00ffff 150deg 180deg,#ff4444 180deg 210deg,#00ff00 210deg 240deg,#ffd700 240deg 270deg,#00ffff 270deg 300deg,#ff4444 300deg 330deg,#00ff00 330deg 360deg);
      transition:transform 3s cubic-bezier(.12,.75,.2,1);
    }
    #wheel-pointer{width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:18px solid var(--col-accent);filter:drop-shadow(0 0 6px rgba(255,215,0,.6));margin-bottom:-6px;}

    #audio-panel{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;align-items:center;background:#222;border-top:2px solid #333;padding:15px;width:100%;position:relative;margin-top:40px;}
    #audio-panel button{min-height:auto;padding:10px 12px;border-radius:10px;font-size:1.1em;}
    #audio-panel .mutebtn{border-color:#777;background:#222;color:#ddd;}
    #audio-panel .label{color:#777;font-size:.85em;margin-right:6px;}

    #input-area, #privacy-dialog, #chat-overlay, #player-check-overlay, #round-over-panel, #end-panel, #pause-panel, #help-panel, #players-panel, #action-history-panel, #mystery-choice-overlay, #word-inspector-overlay, #result-popup {
      position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important;
      width: 100vw !important; height: 100vh !important; background: rgba(0,0,0,0.96) !important; z-index: 9999 !important;
      display: flex; flex-direction: column; justify-content: center; align-items: center; overflow-y: auto; backdrop-filter: blur(5px);
    }
    #result-popup .modal-content {
      background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
      border: 4px solid var(--col-neon);
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
    }
    #result-text {
      font-size: 2.5em;
      font-weight: bold;
      color: var(--col-accent);
      text-shadow: 0 0 20px var(--col-accent);
      margin: 30px 0;
      text-align: center;
    }
    .modal-content{background:#222;border:2px solid var(--col-neon);padding:20px;width:90%;max-width:500px;max-height: 90vh; overflow-y: auto; border-radius:15px;text-align:center;box-shadow:0 0 30px rgba(0,255,255,.2);}
    .inspector-tile{width:50px;height:70px;display:flex;align-items:center;justify-content:center;font-size:2em;font-weight:bold;background:#fff;color:#000;border-radius:8px;box-shadow:0 4px 8px rgba(0,0,0,.5);}
    .inspector-tile.empty{background:#333;color:#777;}
    .inspector-char-btn{display:flex;flex-direction:column;align-items:center;gap:5px;padding:15px;background:#222;border:2px solid #555;border-radius:8px;cursor:pointer;transition:all .2s;}
    .inspector-char-btn:hover, .inspector-char-btn:focus{background:#333;border-color:var(--col-neon);transform:scale(1.05);}
    input[type=text]{font-size:2em;padding:10px;text-align:center;width:90%;background:#000;color:#fff;border:2px solid #555;border-radius:8px;margin-bottom:20px;font-family:var(--font-main);text-transform:uppercase;}
    .history-item{display:block;width:100%;text-align:left;background:#111;color:#ddd;border:1px solid #333;border-radius:10px;padding:10px;margin:8px 0;font-size:1.05em;}
    .history-item strong{color:var(--col-accent);}

    @media (min-width:769px){
      .tile{width:50px;height:75px;font-size:2.5em;}
      .controls-grid{grid-template-columns:repeat(4,1fr);}
      button.action-btn{font-size:1.2em;}
    }
  </style>
</head>
<body>
  <!-- ✅ NVDA FIX: Cambiato da assertive a polite per evitare conflitti con focus mode
       aria-live="assertive" interrompe NVDA anche quando sta entrando in modalità focus,
       causando confusione e uscita dalla focus mode.
       Con "polite", NVDA legge l'annuncio quando ha finito l'operazione corrente. -->
  <div id="sr-announcer" class="sr-only" aria-live="polite"></div>
  <div id="sr-chat" class="sr-only" aria-live="polite"></div>
  <div id="flash-overlay" aria-hidden="true" style="position:fixed;top:20%;left:50%;transform:translate(-50%,-50%);font-size:2em;font-weight:bold;color:#fff;background:#000;padding:20px;border:3px solid #fff;opacity:0;pointer-events:none;transition:opacity .3s;z-index:5000;"><p id="flash-message"></p></div>

  <div style="display:flex; justify-content:space-between; width:95%; max-width:900px; margin:10px auto;">
    <button onclick="openHelp()" style="background:transparent; border:1px solid #555; color:#888; padding:5px 10px; border-radius:5px; font-size:0.8em;" aria-label="Aiuto tasti rapidi (H)">Aiuto (H)</button>
    <button onclick="toggleContrast()" style="background:transparent; border:1px solid #555; color:#888; padding:5px 10px; border-radius:5px; font-size:0.8em;">Contrasto</button>
    <button onclick="toggleAccessibleMode()" id="btn-acc-mode" style="background:transparent; border:1px solid #555; color:#fff; font-weight:bold; padding:5px 10px; border-radius:5px; font-size:0.8em;" aria-pressed="false">VISTA TESTO</button>
    <button onclick="openActionHistory(true)" style="background:transparent; border:1px solid #555; color:#888; padding:5px 10px; border-radius:5px; font-size:0.8em;">Storico (A)</button>
  </div>

  <audio id="snd-spin" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/ruota.wav"></audio>
  <audio id="snd-hit" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/lettera%20presente.wav"></audio>
  <audio id="snd-miss" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/lettera%20assente.wav"></audio>
  <audio id="snd-turn" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/tocca_a_te.mp3"></audio>
  <audio id="snd-bankrupt" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/bancarotta.mp3"></audio>
  <audio id="snd-win" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/vittoria.mp3"></audio>
  <audio id="snd-clap" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/applausi.mp3"></audio>
  <audio id="snd-laugh" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/risata.mp3"></audio>
  <audio id="snd-boo" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/buuu.mp3"></audio>
  <audio id="snd-ooh" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/peccato.mp3"></audio>

  <div id="setup-panel" class="container">
    <h1 style="color:var(--col-accent); font-size:3em; margin-bottom:10px; text-shadow:0 0 20px rgba(255,215,0,0.3);">LA RUOTA</h1>
    
    <label for="inp-name" style="color:#fff; font-size:1.2em; display:block; margin-bottom:5px;">Nome Giocatore:</label>
    <div style="display:flex; gap:10px; align-items:center; width:90%; margin:0 auto;">
      <input id="inp-name" type="text" placeholder="NOME GIOCATORE" aria-label="Nome giocatore" aria-required="true" style="flex:1; margin-bottom:0;">
      <button onclick="document.getElementById('inp-name').value=''; document.getElementById('inp-name-display').textContent='(vuoto)'; document.getElementById('inp-name').focus();" class="action-btn" aria-label="Cancella nome" style="background:#cc0000; padding:10px 15px; min-height:auto; font-size:1em; margin-bottom:0;">CANC</button>
    </div>
    <div id="inp-name-display" style="color:#0f0; font-size:1.5em; min-height:1.5em; margin:5px 0 10px 0;" aria-hidden="true"></div>
    
    <label for="inp-code" style="color:#fff; font-size:1.2em; display:block; margin-bottom:5px; margin-top:10px;">
      Codice Stanza: <span style="color:#888; font-size:0.9em;">(scegli un codice per creare, es: AMICI23)</span>
    </label>
    <div style="display:flex; gap:10px; align-items:center; width:90%; margin:0 auto;">
      <input id="inp-code" type="text" placeholder="SCRIVI UN CODICE" aria-label="Codice stanza da creare o per entrare" aria-required="true" style="flex:1; margin-bottom:0;">
      <button onclick="document.getElementById('inp-code').value=''; document.getElementById('inp-code-display').textContent='(vuoto)'; document.getElementById('inp-code').focus();" class="action-btn" aria-label="Cancella codice" style="background:#cc0000; padding:10px 15px; min-height:auto; font-size:1em; margin-bottom:0;">CANC</button>
    </div>
    <div id="inp-code-display" style="color:#0f0; font-size:1.5em; min-height:1.5em; margin:5px 0 10px 0;" aria-hidden="true"></div>
    
    <div style="text-align:center; color:#aaa; font-size:1em; margin-bottom:15px;">
      <strong style="color:#fff;">Vuoi creare o entrare?</strong><br>
      CREA NUOVA: Nuova stanza (ignora codice)<br>
      ENTRA: Usa il codice sopra
    </div>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; width:100%;">
      <button id="btn-create-room" class="action-btn btn-spin">CREA NUOVA STANZA</button>
      <button id="btn-join-room" class="action-btn btn-vowel">ENTRA<br><span style="font-size:0.8em;">(con codice)</span></button>
    </div>
    <div id="public-rooms-container" style="width:100%; margin-top:30px;">
      <button id="btn-refresh-rooms" class="action-btn" style="padding:10px;">AGGIORNA LISTA STANZE</button>
      <div id="rooms-list" style="width:100%; padding:10px; color:#aaa;"></div>
    </div>
  </div>

  <div id="pause-panel" class="hidden" role="alert">
    <div class="modal-content">
      <h1 style="color:red; font-size:3em;">PAUSA</h1>
      <p>GIOCO SOSPESO DALL'HOST</p>
      <button id="btn-resume-host" onclick="preResumeCheck()" class="action-btn btn-spin hidden" style="margin-top:20px;">RIPRENDI (HOST)</button>
    </div>
  </div>

  <div id="game-panel" class="container hidden">
    <div class="info-bar">
      <div id="timer-box" role="timer" aria-label="Tempo rimanente" class="timer-display">240</div>
      <div class="stats-display">
        <span id="round-indicator" style="color:#aaa;">R 1/10</span><br>
        <span id="turn-indicator" style="color:var(--col-green); font-weight:bold;">...</span>
      </div>
    </div>
    <div class="money-box">
      <span>GIRO: <span id="score-round" style="color:#fff;">0</span> €</span>
      <span>TOT: <span id="score-total" style="color:#fff;">0</span> €</span>
    </div>

    <div class="category-box">
      <h2 id="live-category" aria-live="polite" aria-atomic="true">
        <span id="category-main">...</span>
        <span id="round-hint"></span>
      </h2>
      <div id="jolly-indicator" class="hidden" style="color:#ff00ff; font-weight:bold; margin-top:5px; font-size:1.1em; text-shadow:0 0 5px #ff00ff;"></div>
      <div id="double-indicator" class="hidden" style="color:orange; font-weight:bold; margin-top:5px; font-size:1.1em; text-shadow:0 0 5px red; border:1px solid red; padding:2px;">RADDOPPIA ATTIVO! GIRA ANCORA!</div>
      <div id="special-round-indicator" class="hidden" style="color:cyan; font-weight:bold; margin-top:5px; font-size:1.1em; text-shadow:0 0 5px cyan; border:1px solid cyan; padding:5px; border-radius:5px;"></div>
    
    <div class="acc-nav" role="navigation" aria-label="Comandi principali touch">
      <!-- Vista Testo semplificata per smartphone -->
      <!-- Ordine: TABELLONE -> GIRA -> VOCALE -> [PASSA solo nei round speciali] -> RISOLVI -> ALTRI COMANDI -->
      
      <!-- NAVIGAZIONE TABELLONE -->
      <button class="action-btn" onclick="navigateTextBoard('first')" style="background:#222;border-color:#555;grid-column:1/-1;">
        TABELLONE - PRIMA PAROLA
      </button>
      
      <!-- GIRA - pulsante principale (focus di default) -->
      <button id="btn-acc-spin" class="action-btn btn-spin" onclick="doSpin()" style="grid-column:1/-1;">GIRA</button>
      
      <!-- VOCALE -->
      <button class="action-btn btn-vowel" onclick="tryOpenVowelInput()" style="grid-column:1/-1;">VOCALE</button>
      
      <!-- PASSA - visibile SOLO nei round speciali (prima di RISOLVI) -->
      <button id="btn-acc-pass-special" class="action-btn btn-pass" onclick="passTurn()" style="grid-column:1/-1;display:none;">PASSA</button>
      
      <!-- RISOLVI -->
      <button class="action-btn btn-solve" onclick="openInput('solve')" style="grid-column:1/-1;">RISOLVI</button>
      
      <!-- Pulsante Altri Comandi -->
      <button id="btn-acc-more" class="action-btn" onclick="toggleAccMoreCommands()" style="background:#333;border-color:#666;grid-column:1/-1;">
        ALTRI COMANDI ▼
      </button>
      
      <!-- COMANDI SECONDARI - nascosti inizialmente -->
      <div id="acc-more-commands" style="display:none;grid-column:1/-1;">
        <div style="display:grid;grid-template-columns:1fr;gap:8px;margin-top:8px;">
          <!-- PASSA TURNO spostato qui -->
          <button class="action-btn btn-pass" onclick="passTurn()">PASSA TURNO</button>
          
          <button class="action-btn" onclick="openChat()">CHAT</button>
          <button class="action-btn" onclick="openPlayersPanel()">CLASSIFICA</button>
          <button class="action-btn" onclick="openHelp()">AIUTO</button>
          
          <!-- ANNUNCI VOCALI -->
          <button class="action-btn" style="background:#1a4d2e; border-color:#2ecc71;" onclick="announceTurn()">ANNUNCIA TURNO</button>
          <button class="action-btn" style="background:#1a4d2e; border-color:#2ecc71;" onclick="announceScore()">LEGGI PUNTEGGI</button>
          <button class="action-btn" onclick="readRevealedLetters()">LETTERE USCITE</button>
          
          <!-- EFFETTI SONORI -->
          <button class="action-btn" style="background:#2c3e50; font-size:0.9em;" onclick="playSharedAudio('snd-clap', 'Applauso')">APPLAUSO</button>
          <button class="action-btn" style="background:#2c3e50; font-size:0.9em;" onclick="playSharedAudio('snd-laugh', 'Risata')">RISATA</button>
          <button class="action-btn" style="background:#2c3e50; font-size:0.9em;" onclick="playSharedAudio('snd-boo', 'Fischi')">FISCHI</button>
          <button class="action-btn" style="background:#2c3e50; font-size:0.9em;" onclick="playSharedAudio('snd-ooh', 'Ooh')">OOH</button>
          
          <button class="action-btn" onclick="openActionHistory(true)">STORICO AZIONI</button>
          <button class="action-btn" onclick="toggleAudio()" id="btn-acc-audio">AUDIO</button>
        </div>
      </div>
    </div>
</div>

    <h3 id="hdr-actions" class="section-header" tabindex="-1">AZIONI DI GIOCO</h3>
    <div class="top-controls-wrapper">
      <div class="controls-grid">
        <button id="btn-spin" class="action-btn btn-spin" onclick="doSpin()">GIRA</button>
        <button id="btn-vowel" class="action-btn btn-vowel" onclick="tryOpenVowelInput()">VOCALE</button>
        <button id="btn-pass" class="action-btn btn-pass" onclick="passTurn()">PASSA</button>
        <button id="btn-pass-opponent" class="action-btn btn-pass" onclick="passToOpponent()">PASSA ALL'AVVERSARIO</button>
        <button id="btn-inspect-word" class="action-btn" style="border-color:#555;background:#222;" onclick="openWordInspector()">ISPEZIONA PAROLA</button>
        <button id="btn-letters" class="action-btn" onclick="readRevealedLetters()" style="border-color:#aaa; background:#111; font-size:0.9em;">LETTERE USCITE</button>
      </div>
    </div>

    <h3 id="hdr-wheel" class="section-header" tabindex="-1">RUOTA</h3>
    <div id="wheel-visual-wrap" role="region" aria-label="Ruota visuale">
      <div id="wheel-pointer" aria-hidden="true"></div>
      <div id="wheel-visual" aria-hidden="true"></div>
    </div>
    <div id="wheel-status-text" tabindex="-1" style="font-size:1.8em;font-weight:900;color:var(--col-accent);margin:10px 0;text-shadow:0 0 15px var(--col-accent);background:rgba(0,0,0,0.7);padding:15px 25px;border-radius:12px;border:2px solid var(--col-accent);min-height:60px;display:flex;align-items:center;justify-content:center;"></div>

    <h2 class="section-header" id="board-section" tabindex="-1">Tabellone</h2>
    <div class="board-wrapper">
      <div id="board-container" role="grid" aria-label="Tabellone di gioco"></div>
    </div>
    <div id="accessible-board-container" role="region" aria-label="Tabellone testuale">
      <div id="acc-board-summary"></div>
      <div id="acc-word-list"></div>
    </div>

    <h3 id="hdr-finish" class="section-header" tabindex="-1">CONCLUDI E INFO</h3>
    <div class="bottom-controls-wrapper">
      <button id="btn-solve" class="action-btn btn-solve" onclick="openInput('solve')">RISOLVI FRASE</button>
      <button id="btn-surrender" class="action-btn hidden" onclick="surrenderSpecialRound()" style="background:linear-gradient(180deg,#8B0000,#400000); color:#fff; margin-top:10px; font-size:1.2em;">HOST: ARRENDITI</button>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px; margin-top:10px;">
        <button id="btn-chat" class="action-btn btn-chat" onclick="openChat()" style="font-size:0.8em; padding:10px;">CHAT (K)</button>
        <button id="btn-management" class="action-btn" onclick="openPlayersPanel()" style="font-size:0.8em; padding:10px; background:#222;">CLASSIFICA (S)</button>
      </div>
      <button id="btn-manual-cons" class="action-btn full-width hidden" style="background:var(--col-green); color:#000; margin-top:10px;" onclick="openInput('letter')">DI UNA CONSONANTE</button>
    </div>

    <button onclick="leaveGame()" style="background:transparent; border:none; color:#555; margin-top:30px; cursor:pointer;">ESCI</button>

    <div id="audio-panel">
      <span class="label">AUDIO:</span>
      <button class="action-btn" onclick="playAudio('snd-clap')" aria-label="Applauso">APPLAUSO</button>
      <button class="action-btn" onclick="playAudio('snd-laugh')" aria-label="Risata">RISATA</button>
      <button class="action-btn" onclick="playAudio('snd-boo')" aria-label="Buuu">BUUU</button>
      <button class="action-btn" onclick="playAudio('snd-ooh')" aria-label="Ohhh">OHHH</button>
      <button id="btn-mute" class="action-btn mutebtn" onclick="toggleMute()">AUDIO ON</button>
      <button id="btn-toggle-audio" class="action-btn mutebtn" onclick="toggleAudio()">Audio ON</button>
    </div>
  </div>

  <div id="input-area" class="hidden">
    <div class="modal-content">
      <h2 id="input-title" style="color:var(--col-accent);">INSERISCI</h2>
      <input id="game-input" type="text" autocomplete="off" aria-label="Campo di inserimento testo" aria-describedby="input-title">
      <div class="controls-grid" style="grid-template-columns:1fr 1fr;">
        <button onclick="submitInput()" class="action-btn btn-spin">OK</button>
        <button id="btn-cancel-input" onclick="tryCancelInput()" class="action-btn btn-pass">ANNULLA</button>
      </div>
    </div>
  </div>

  <!-- Overlay SPECIALE per Vista Testo: input consonante a schermo intero -->
  <div id="accessible-letter-input" class="hidden" style="position:fixed;top:0;left:0;right:0;bottom:0;width:100vw;height:100vh;background:#000;z-index:10000;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:20px;">
    <div style="width:100%;max-width:600px;display:flex;flex-direction:column;gap:20px;">
      <h1 id="accessible-input-title" style="color:var(--col-accent);font-size:2em;margin:0;text-align:center;">INSERISCI CONSONANTE</h1>
      <p id="accessible-input-info" style="color:#fff;font-size:1.3em;margin:0;text-align:center;">Hai girato 800 €</p>
      <input id="accessible-game-input" type="text" autocomplete="off" aria-label="Campo per inserire consonante" style="font-size:3em;padding:20px;text-align:center;width:100%;background:#111;color:#fff;border:4px solid var(--col-accent);border-radius:15px;font-family:var(--font-main);text-transform:uppercase;box-sizing:border-box;">
      <div style="display:grid;grid-template-columns:1fr;gap:15px;width:100%;">
        <button onclick="submitAccessibleLetterInput()" class="action-btn btn-spin" style="font-size:1.5em;padding:25px;">CONFERMA</button>
        <button onclick="showAccessibleRevealedLetters()" class="action-btn" style="background:#2c3e50;border-color:#3498db;font-size:1.3em;padding:20px;">LETTERE CHIAMATE</button>
        <button onclick="closeAccessibleLetterInput()" class="action-btn btn-pass" style="font-size:1.3em;padding:20px;">ANNULLA</button>
      </div>
    </div>
  </div>

  <div id="chat-overlay" class="hidden" role="dialog" aria-modal="true" aria-label="Finestra Chat">
    <div class="modal-content" style="height:80%; max-width:600px; display:flex; flex-direction:column;">
      <h2 style="color:var(--col-neon);">CHAT</h2>
      <div id="chat-messages" tabindex="0" role="log" aria-live="polite" style="flex:1; overflow-y:auto; text-align:left; border:1px solid #444; padding:10px; margin-bottom:10px; background:#000; color:#ddd;"></div>
      <input id="chat-input" type="text" placeholder="Messaggio..." aria-label="Scrivi messaggio chat" style="font-size:1.2em; width:95%; margin-bottom:10px;">
      <div style="display:flex; gap:10px; width:100%;">
        <button onclick="sendChatMessage()" class="action-btn btn-vowel" style="flex:1;">INVIA</button>
        <button onclick="document.getElementById('chat-overlay').classList.add('hidden')" class="action-btn btn-pass" style="flex:1;">CHIUDI</button>
      </div>
    </div>
  </div>

  <div id="help-panel" class="hidden">
    <div class="modal-content" style="max-width:700px; text-align:left; max-height:85vh; overflow-y:auto;">
      <h1 style="color:var(--col-accent); text-align:center; margin-top:10px;">GUIDA COMPLETA</h1>
      
      <h2 style="color:var(--col-neon); margin-top:30px;">PULSANTI PRINCIPALI (in alto)</h2>
      <div style="color:#ddd; line-height:1.6;">
        <ul>
          <li><strong>Aiuto (H)</strong> - Apre questa guida</li>
          <li><strong>Contrasto</strong> - Cambia il tema dei colori per una migliore visibilità. Alterna tra tema normale e tema ad alto contrasto (nero/bianco/giallo/verde). Utile per persone con problemi di vista o in ambienti molto luminosi.</li>
          <li><strong>VISTA TESTO</strong> - Modalità con pulsanti completi per dispositivi touch. 
            <ul style="margin-top:8px; line-height:1.6;">
              <li><strong>SMARTPHONE SENZA TASTIERA:</strong> ATTIVA questa modalità! Il tabellone diventa testuale con pulsanti cliccabili. Avrai accesso a TUTTI i comandi tramite pulsanti dedicati (annuncia turno, punteggi, effetti sonori, ecc.). Ideale per touchscreen e screen reader.</li>
              <li><strong>PC o SMARTPHONE CON TASTIERA ESTERNA:</strong> LASCIA DISATTIVATA questa modalità! Usa il tabellone visuale standard e i tasti rapidi (G, V, R, P, T, D, ecc.). Molto più veloce e comodo con la tastiera.</li>
              <li><strong>Importante:</strong> Se hai una tastiera Bluetooth/USB collegata allo smartphone, usa sempre la modalità STANDARD con i tasti rapidi, non la Vista Testo!</li>
            </ul>
          </li>
          <li><strong>Storico (A)</strong> - Mostra tutte le azioni recenti del gioco (giri, lettere chiamate, passaggi di turno, ecc.)</li>
        </ul>
      </div>
      
      <h2 style="color:var(--col-neon); margin-top:30px;">PULSANTI HOST (solo per il creatore della stanza)</h2>
      <div style="color:#ddd; line-height:1.6;">
        <p>Questi pulsanti appaiono nella schermata <strong>CLASSIFICA (S)</strong> e sono disponibili solo per l'host:</p>
        <ul>
          <li><strong>PAUSA</strong> - Mette in pausa il gioco. Tutti i giocatori vedranno una schermata di pausa. Utile per fare una pausa o risolvere problemi tecnici. Premi di nuovo per riprendere.</li>
          <li><strong>RESET PARTITA</strong> - Azzera tutti i punteggi e ricomincia da capo. ATTENZIONE: questa azione cancella tutti i progressi!</li>
          <li><strong>ARRENDITI</strong> - L'host si arrende alla frase corrente. Il round termina e si passa al round successivo. Usalo se la frase è troppo difficile o se nessuno riesce a risolverla.</li>
          <li><strong>BOT</strong> - Aggiunge un giocatore automatico (bot) alla partita. Il bot gioca in automatico quando è il suo turno.</li>
        </ul>
      </div>
      
      <h2 style="color:var(--col-neon); margin-top:30px;">TASTI RAPIDI</h2>
      <ul style="line-height:1.8; color:#ddd; font-size:1.1em;">
        <li><strong>G</strong> o <strong>Ctrl+G</strong>: Gira la ruota</li>
        <li><strong>V</strong> o <strong>Ctrl+V</strong>: Compra vocale</li>
        <li><strong>R</strong> o <strong>Ctrl+R</strong>: Risolvi</li>
        <li><strong>P</strong> o <strong>Ctrl+P</strong>: Passa</li>
        <li><strong>T</strong> o <strong>Ctrl+T</strong>: Di chi è il turno</li>
        <li><strong>K</strong> o <strong>Ctrl+K</strong>: Chat</li>
        <li><strong>S</strong> o <strong>Ctrl+S</strong>: Controlli e Classifica</li>
        <li><strong>L</strong> o <strong>Ctrl+L</strong>: Lettere uscite</li>
        <li><strong>A</strong> o <strong>Ctrl+A</strong>: Storico azioni</li>
        <li><strong>D</strong> o <strong>Ctrl+D</strong>: Ascolta punteggio (parziale e totale)</li>
        <li><strong>B</strong> o <strong>Ctrl+B</strong>: Aggiungi Bot veloce (Solo Host)</li>
        <li><strong>H</strong> o <strong>Ctrl+H</strong>: Aiuto</li>
        <li><strong>I</strong> o <strong>Ctrl+I</strong>: Ispeziona parola (modalità accessibile) - Apre una finestra che mostra tutte le lettere della parola corrente, sia quelle trovate che quelle nascoste. Puoi cliccare su una lettera per selezionarla.</li>
        <li><strong>Spazio</strong>: Riapri ultimo input</li>
        <li><strong>Frecce ↑↓←→ (NAVIGAZIONE CON TASTIERA)</strong>: 
          <ul style="margin-top:8px; line-height:1.6;">
            <li><strong>Freccia DESTRA (→)</strong>: Passa al carattere successivo nella stessa parola</li>
            <li><strong>Freccia SINISTRA (←)</strong>: Torna al carattere precedente nella stessa parola</li>
            <li><strong>Freccia SU (↑)</strong>: Passa alla parola precedente</li>
            <li><strong>Freccia GIÙ (↓)</strong>: Passa alla parola successiva</li>
            <li><em>Nota: Le frecce sinistra/destra NON cambiano parola, rimangono sempre all'interno della parola corrente. Per cambiare parola usa SU/GIÙ.</em></li>
            <li><em>Il carattere selezionato viene evidenziato con un bordo dorato brillante per facilitare la navigazione visiva.</em></li>
          </ul>
        </li>
        <li><strong>ESC</strong>: Chiudi finestre</li>
        <li><strong>1-4</strong>: Effetti sonori (1=applauso, 2=risata, 3=fischi, 4=ooh)</li>
      </ul>
      
      <h2 style="color:var(--col-neon); margin-top:30px;">REGOLE DEL GIOCO</h2>
      <div style="color:#ddd; line-height:1.6;">
        <p><strong>La Ruota della Fortuna</strong> è un gioco dove devi indovinare frasi nascoste lettera per lettera.</p>
        
        <h3 style="color:var(--col-accent);">Come si gioca:</h3>
        <ul>
          <li><strong>Gira la ruota (G)</strong> per scoprire quanto vale ogni consonante che indovini</li>
          <li><strong>Di una consonante</strong> quando la ruota si ferma - se è presente guadagni il valore della ruota moltiplicato per il numero di volte che appare!</li>
          <li><strong>Compra vocale (V)</strong> costa tra 250€ e 2000€ (dipende dalla lunghezza della frase) ma ti aiuta a capire la frase. Puoi comprare solo una vocale per giro di ruota.</li>
          <li><strong>Risolvi (R)</strong> quando pensi di sapere la frase completa - se sbagli perdi il turno!</li>
          <li><strong>Passa (P)</strong> se non sai cosa fare - il turno passa al prossimo giocatore</li>
        </ul>
        
        <h3 style="color:var(--col-accent);">Settori speciali della ruota:</h3>
        <ul>
          <li><strong>BANCAROTTA / PERDE TUTTO</strong> - Perdi tutto il punteggio del round corrente E il punteggio totale! Il settore più pericoloso.</li>
          <li><strong>PASSA TURNO</strong> - Il turno passa automaticamente al giocatore successivo</li>
          <li><strong>JOLLY</strong> - Ti protegge da bancarotta e passa turno per 5 round! Viene consumato automaticamente quando peschi uno di questi settori.</li>
          <li><strong>MISTERO (?)</strong> - Scegli se aprire (rischio/opportunità) o prendere 500€ sicuri. Aprendo il mistero puoi trovare: RADDOPPIA, BANCAROTTA, +1000€, JOLLY, PASSA TURNO o PASSA ALL'AVVERSARIO</li>
          <li><strong>RADDOPPIA</strong> - Il prossimo giro vale il doppio! Quando lo peschi, devi girare di nuovo e il valore sarà moltiplicato x2.</li>
          <li><strong>+1000€</strong> - Aggiungi 1000€ al tuo punteggio di round e gira di nuovo!</li>
        </ul>
        
        <h3 style="color:var(--col-accent);">Punteggio:</h3>
        <ul>
          <li>Ogni consonante presente vale quanto indicato dalla ruota moltiplicato per quante volte appare</li>
          <li>Chi risolve la frase guadagna 1000€ bonus</li>
          <li>Il punteggio del round si aggiunge al totale quando qualcuno risolve</li>
          <li>Vince chi ha più soldi alla fine della partita (default: 10 round)!</li>
        </ul>
        
        <h3 style="color:var(--col-accent);">Timer:</h3>
        <ul>
          <li>Hai 4 minuti (240 secondi) per ogni turno</li>
          <li>Il timer appare in alto a sinistra e diventa rosso quando è il tuo turno</li>
          <li>Se il tempo scade, il turno passa automaticamente</li>
        </ul>
      </div>
      
      <h2 style="color:var(--col-neon); margin-top:30px;">ALTRI PULSANTI</h2>
      <div style="color:#ddd; line-height:1.6;">
        <ul>
          <li><strong>ISPEZIONA PAROLA</strong> - Apre una finestra dettagliata della parola su cui ti trovi, mostrando tutte le lettere</li>
          <li><strong>LETTERE USCITE</strong> - Legge ad alta voce tutte le lettere già chiamate nel round corrente</li>
          <li><strong>CHAT (K)</strong> - Apre la chat per comunicare con gli altri giocatori</li>
          <li><strong>CLASSIFICA (S)</strong> - Mostra la classifica attuale, i punteggi di tutti i giocatori e (per l'host) i pulsanti di controllo del gioco</li>
          <li><strong>ESCI</strong> - Esci dalla stanza (in basso alla pagina)</li>
          <li><strong>Effetti audio</strong> - In fondo alla pagina trovi pulsanti per effetti sonori (applauso, risata, fischi, ooh) e controlli audio</li>
        </ul>
      </div>
      
      <button onclick="closeHelp()" class="action-btn btn-solve" style="margin:30px 0; width:100%;">CHIUDI (ESC)</button>
    </div>
  </div>

  <div id="players-panel" class="hidden" role="dialog">
    <div class="modal-content" style="max-width:700px; text-align:left;">
      <h2 style="color:var(--col-neon);">GIOCATORI E CLASSIFICA</h2>
      <div id="players-list" style="margin:20px 0;"></div>
      <button onclick="closePlayers()" class="action-btn full-width">CHIUDI (ESC)</button>
    </div>
  </div>

  <div id="action-history-panel" class="hidden" role="dialog" aria-label="Storico azioni">
    <div class="modal-content" style="max-width:700px; text-align:left;">
      <h2 style="color:var(--col-neon);">STORICO</h2>
      <div id="action-history-list" style="max-height:420px; overflow-y:auto;"></div>
      <button onclick="closeActionHistory()" class="action-btn full-width" style="margin-top:10px;">CHIUDI</button>
    </div>
  </div>

  <div id="mystery-choice-overlay" class="hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <h2 id="mystery-title" style="color:var(--col-neon);">MISTERO</h2>
      <p id="mystery-desc" style="color:#ddd; font-size:1.1em; line-height:1.4;">
        Vuoi aprire il Mistero oppure prendere <strong>500€</strong> in palio?
      </p>
      <div style="display:grid; grid-template-columns:1fr; gap:10px; margin-top:15px;">
        <button id="btn-mystery-open" class="action-btn btn-spin" onclick="chooseMystery(true)">APRI IL MISTERO</button>
        <button id="btn-mystery-500" class="action-btn btn-vowel" onclick="chooseMystery(false)">PRENDI 500€ IN PALIO</button>
      </div>
      <button onclick="chooseMystery(false)" style="margin-top:10px; background:none; border:none; color:#aaa;">ANNULLA (ESC)</button>
    </div>
  </div>

  <div id="word-inspector-overlay" class="hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <h2 id="inspector-title" style="color:var(--col-neon);">ISPEZIONA PAROLA</h2>
      <div id="inspector-letters-container" style="margin:20px 0;"></div>
      <button onclick="closeWordInspector()" class="action-btn full-width">CHIUDI (ESC)</button>
    </div>
  </div>

  <div id="player-check-overlay" class="hidden" role="dialog" aria-modal="true" aria-label="Appello presenze">
    <div class="modal-content">
      <h2 style="color:orange;">APPELLO PRESENZE</h2>
      <p style="color:#ddd; line-height:1.4;">Controlla chi risulta in stanza.</p>
      <div id="player-check-list" style="text-align:left; margin:20px 0; max-height:300px; overflow-y:auto;"></div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; width:100%;">
        <button id="btn-confirm-resume" onclick="confirmResumeGame()" class="action-btn btn-spin">RIPRENDI ORA</button>
        <button onclick="closePlayerCheckOverlay()" class="action-btn btn-pass">ASPETTA</button>
      </div>
    </div>
  </div>

  <div id="round-over-panel" class="hidden">
    <div class="modal-content">
      <h2 style="color:var(--col-green);">FINE ROUND</h2>
      <p id="round-winner-msg" style="font-size:1.2em; color:#fff;"></p>
      <p id="solution-msg" style="color:var(--col-accent); font-size:1.5em; font-weight:bold; margin:20px 0;"></p>
      <p>Prossimo round: <span id="next-round-timer">15</span>s</p>
      <button onclick="startNewRound()" id="btn-host-next" class="action-btn btn-spin full-width hidden">AVVIA ORA (HOST)</button>
    </div>
  </div>

  <div id="end-panel" class="hidden">
    <div class="modal-content">
      <h2 style="color:var(--col-accent);">CLASSIFICA FINALE</h2>
      <ul id="ranking-list" style="list-style:none; padding:0; text-align:left;"></ul>
      <button id="btn-new-game" onclick="resetGame()" class="action-btn btn-spin full-width hidden" style="margin:10px 0;">NUOVA PARTITA (HOST)</button>
      <button onclick="leaveGame()" class="action-btn btn-pass full-width">ESCI</button>
    </div>
  </div>

  <div id="privacy-dialog" class="hidden">
    <div class="modal-content">
      <h2>TIPO STANZA</h2>
      <div style="display:flex; gap:10px;">
        <button onclick="createRoomFinal(true)" class="action-btn btn-vowel" style="flex:1;">PUBBLICA</button>
        <button onclick="createRoomFinal(false)" class="action-btn btn-pass" style="flex:1;">PRIVATA</button>
      </div>
      <button onclick="document.getElementById('privacy-dialog').classList.add('hidden')" style="margin-top:10px; background:none; border:none; color:#aaa;">ANNULLA</button>
    </div>
  </div>

  <div id="result-popup" class="hidden">
    <div class="modal-content">
      <h2 style="color:var(--col-neon); margin-bottom:20px;">RISULTATO</h2>
      <div id="result-text"></div>
      <button onclick="closeResultPopup()" class="action-btn btn-spin" style="font-size:1.5em; padding:20px 40px; margin-top:20px;">OK</button>
    </div>
  </div>

  <script>
    

    const NATO = {
      'A':'Ancona','B':'Bologna','C':'Como','D':'Domodossola','E':'Empoli','F':'Firenze','G':'Genova','H':'Hotel','I':'Imola',
      'J':'Jolly','K':'Kappa','L':'Livorno','M':'Milano','N':'Napoli','O':'Otranto','P':'Palermo','Q':'Quadro','R':'Roma',
      'S':'Savona','T':'Torino','U':'Udine','V':'Venezia','W':'Washington','X':'Xilofono','Y':'Yogurt','Z':'Zara',
      'À':'A accentata','È':'E aperta','É':'E chiusa','Ì':'I accentata','Ò':'O accentata','Ù':'U accentata',
      "'":"Apostrofo","?":"Punto di domanda","!":"Punto esclamativo",".":"Punto",",":"Virgola"
    };

    const WHEEL_VALUES=[100,200,300,400,500,600,700,800,900,1000,2000,'MISTERO','PASSA','BANCAROTTA','JOLLY'];
    const MISTERO_VALUES=['RADDOPPIA','BANCAROTTA','PASSA','PASSA_AVVERSARIO','+1000','JOLLY'];
    const TURN_LIMIT_SEC=240;
    const MAX_PLAYERS=3;

    let myId, myIndex, roomId, isHost=false;
    let currentFrase=null, currentStanza=null, currentPuzzleText="", currentHintText="", fullSolutionText="";
    let lastTimestamp="", isSpinning=false, inputMode=null, parsedBoard=[];
    let isFetching=false, isProcessingInput=false, isHandlingTimeout=false;
    let vowelsBoughtThisTurn=0, wasMyTurn=false, wasBotTurn=false;
    let actionHistory=[];
    let isAccessibleMode=false;
    let speechTimeouts=[];
    let nextRoundInterval=null;
    let isMuted=false;
    let wheelRotation=0;
    let navWordIdx = 0, navCharIdx = 0;
    let lastInputMode = null;
    let spellingTimer = null;
    let nextRoundSec = 15;
    let lastSpinTimestamp = null; 
    
    let specialPhase = 0; 
    let lastAutoPassTime = 0;
    let isBotThinking = false;
    const BOT_BREATH_TIME = 1200; // Pausa tra azioni bot per far "respirare" il gioco
    
    // ✅ FIX MEMORY LEAK: Funzione globale per convertire input in maiuscolo
    // Definita una sola volta, può essere rimossa e ri-aggiunta senza accumulo
    const uppercaseInputHandler = function(e) {
      const cursorPos = e.target.selectionStart;
      const upperValue = e.target.value.toUpperCase();
      e.target.value = upperValue;
      e.target.setSelectionRange(cursorPos, cursorPos);
    };
    
    // Helper per resettare isBotThinking con delay
    function botFinishAction(delayMs = BOT_BREATH_TIME) {
      setTimeout(() => {
        isBotThinking = false;
      }, delayMs);
    }
    let previousPlayersList = []; 
    
    
    let isSpecialRound = false;
    let specialPhraseIndex = 0; 
    let specialPhraseIds = []; 
    let specialConsonantsUsed = 0; 
    let specialVowelsPhase = true; 
    let specialVowelsGiven = 0; 
    let lettersCalledThisRound = []; 
    
    // Cleanup variables
    let gameChannel = null;
    let playersChannel = null; // ✅ CORREZIONE CHATGPT: Channel per subscription giocatori
    let chatChannel = null;
    let turnTimerInterval = null;
    let pingInterval = null; // ✅ CORREZIONE CHATGPT: Intervallo per ping periodico
    
    
    (function(){
      
      
      Object.defineProperty(window, 'currentPuzzleText', {
        get: function(){ return '***'; },
        set: function(v){ currentPuzzleText = v; }
      });
      Object.defineProperty(window, 'fullSolutionText', {
        get: function(){ return '***'; },
        set: function(v){ fullSolutionText = v; }
      });
    })(); 

    
    
    const FREQ_CONS_GROUPS = [
      ['R','T','N'],        
      ['S','L','C'],        
      ['D','P','M'],        
      ['G','B','F','V']     
    ];
    const FREQ_VOW_GROUPS = [
      ['A','E'],            
      ['I','O'],            
      ['U']                 
    ];

    document.addEventListener('DOMContentLoaded', () => {
      // ✅ FIX: Non pre-compilare i campi automaticamente
      // Gli utenti con screen reader preferiscono campi vuoti
      // I valori vengono comunque salvati quando si entra in una stanza
      
      const inpName = document.getElementById('inp-name');
      const inpCode = document.getElementById('inp-code');
      const displayName = document.getElementById('inp-name-display');
      const displayCode = document.getElementById('inp-code-display');
      
      // Inizializza i display come vuoti
      if(displayName) displayName.textContent = '(vuoto)';
      if(displayCode) displayCode.textContent = '(vuoto)';
      
      document.getElementById('btn-create-room')?.addEventListener('click', () => askPrivacy());
      document.getElementById('btn-join-room')?.addEventListener('click', () => joinGame(false));
      document.getElementById('btn-refresh-rooms')?.addEventListener('click', () => fetchPublicRooms());

      
      document.getElementById('inp-name')?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          
          const name = document.getElementById('inp-name').value.trim();
          if (name) {
            document.getElementById('inp-code')?.focus();
          }
        }
      });
      
      document.getElementById('inp-code')?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          
          const code = document.getElementById('inp-code').value.trim();
          if (code) {
            joinGame(false);
          } else {
            askPrivacy();
          }
        }
      });
      
      // Aggiorna display per inp-name
      document.getElementById('inp-name')?.addEventListener('input', (e) => {
        const value = e.target.value;
        const display = document.getElementById('inp-name-display');
        if(display){
          display.textContent = value || '(vuoto)';
        }
      });
      
      // Aggiorna display per inp-code
      document.getElementById('inp-code')?.addEventListener('input', (e) => {
        const value = e.target.value;
        const display = document.getElementById('inp-code-display');
        if(display){
          display.textContent = value || '(vuoto)';
        }
      });

      document.getElementById('game-input')?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            submitInput();
        }
      });
      
      document.getElementById('chat-input')?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            sendChatMessage();
        }
      });
      
      
      const hash = window.location.hash;
      if(hash && hash.startsWith('#stanza=')){
        const roomCode = hash.replace('#stanza=', '').toUpperCase();
        if(roomCode){
          
          document.getElementById('inp-code').value = roomCode;
          speak(`Link rilevato: stanza ${roomCode}. Inserisci il tuo nome e premi Entra.`);
        }
      }
    });

    function clearSpeechQueue(){ if(speechTimeouts && Array.isArray(speechTimeouts)) speechTimeouts.forEach(t=>clearTimeout(t)); speechTimeouts=[]; }
    function speak(t){
      if(!t) return;
      const e=document.getElementById('sr-announcer');
      
      // ✅ NVDA FIX: NON usare il "flicker" (svuota/riempi)
      // Il pattern e.textContent=''; setTimeout(()=>e.textContent=t, 50);
      // causa un "sussulto" del cursore virtuale che può far uscire NVDA da Focus Mode
      // 
      // SOLUZIONE: Aggiungi un carattere zero-width space invisibile per forzare
      // NVDA a rilevare il cambiamento senza causare il flicker visivo del DOM
      clearSpeechQueue();
      
      // Alterna tra testo normale e testo con zero-width space
      // Questo forza NVDA a rilevare il cambiamento anche se il testo è uguale
      const currentText = e.textContent;
      const hasZWS = currentText.endsWith('\u200B');
      const newText = hasZWS ? t : t + '\u200B';
      
      e.textContent = newText;
    }
    function speakChat(t){
      if(!t) return;
      const e=document.getElementById('sr-chat');
      
      // ✅ NVDA FIX: Stesso problema di speak() - elimina il flicker
      // Usa zero-width space invece di svuotare/riempire
      const currentText = e.textContent;
      const hasZWS = currentText.endsWith('\u200B');
      const newText = hasZWS ? t : t + '\u200B';
      
      e.textContent = newText;
    }
    function playAudio(id){
      if(isMuted) return;
      const a=document.getElementById(id);
      if(a){ a.pause(); a.currentTime=0; a.play().catch(()=>{}); }
    }
    
    async function playSharedAudio(soundId, soundName){
      // Riproduci localmente
      playAudio(soundId);
      
      // Condividi con tutti i giocatori
      if(roomId && myId){
        const myName = document.getElementById('inp-name').value;
        const message = `[SOUND:${soundId}]${soundName}`;
        await _supabase.from('chat_messaggi').insert({
          stanza_id: roomId, 
          giocatore_nome: myName, 
          messaggio: message
        });
      }
    }
    let multipleHitsTimeouts = []; // ✅ FIX: Array per tracciare i timeout attivi
    
    function playMultipleHits(count) {
        // ✅ FIX: Cancella qualsiasi timeout precedente ancora in esecuzione
        if(multipleHitsTimeouts && Array.isArray(multipleHitsTimeouts)) multipleHitsTimeouts.forEach(timeout => clearTimeout(timeout));
        multipleHitsTimeouts = [];
        
        // ✅ FIX: Riproduci UN beep per OGNI lettera trovata
        // Il primo beep parte subito, poi uno ogni 250ms
        if(count >= 1) {
            playAudio('snd-hit'); // Primo beep immediato
            
            // Beep successivi con delay
            for(let i = 1; i < count; i++) {
                const timeout = setTimeout(() => playAudio('snd-hit'), i * 250);
                multipleHitsTimeouts.push(timeout);
            }
        }
    }
    function toggleMute(){
      isMuted=!isMuted;
      document.getElementById('btn-mute').textContent = isMuted ? 'AUDIO OFF' : 'AUDIO ON';
      speak(isMuted ? "Audio disattivato" : "Audio attivato");
    }
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    function cleanStr(s){ return (s && typeof s === 'string') ? s.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/[^a-z0-9]/g,"") : ""; }
    
    
    function getNextConsonantHuman(alreadyRevealed){
      // 🧠 INTELLIGENZA SEMANTICA: Prova a completare parole quasi finite
      const smartLetter = tryCompleteWord(alreadyRevealed);
      if(smartLetter) {
        return smartLetter;
      }
      
      // Fallback: usa frequenze statistiche
      for(let group of FREQ_CONS_GROUPS){
        const shuffled = [...group].sort(() => Math.random() - 0.5);
        for(let c of shuffled){
          if(!alreadyRevealed.includes(c)) return c;
        }
      }
      return null;
    }
    
    function tryCompleteWord(alreadyRevealed){
      // Analizza il parsedBoard per trovare parole con 1-2 lettere mancanti
      if(!parsedBoard || parsedBoard.length === 0) return null;
      
      const vowels = ['A','E','I','O','U'];
      const allRevealed = alreadyRevealed.map(l => l.toUpperCase());
      
      // Costruisci una rappresentazione delle parole con _ per lettere nascoste
      const wordsWithBlanks = parsedBoard.map(wordObj => {
        let word = '';
        wordObj.chars.forEach(charData => {
          if(!charData.isLetter) {
            word += charData.char; // Punteggiatura rimane
          } else if(charData.isRevealed) {
            word += charData.char; // Lettera rivelata
          } else {
            word += '_'; // Lettera nascosta
          }
        });
        return word.toUpperCase();
      });
      
      // Dizionario di pattern comuni per parole italiane
      const patterns = [
        // Pattern con 1 lettera mancante
        {pattern: /^G_TTO$/i, missing: 1, suggest: 'A'}, // GATTO
        {pattern: /^C_NE$/i, missing: 1, suggest: 'A'}, // CANE
        {pattern: /^C_SA$/i, missing: 1, suggest: 'A'}, // CASA
        {pattern: /^M_RE$/i, missing: 1, suggest: 'A'}, // MARE
        {pattern: /^P_NE$/i, missing: 1, suggest: 'A'}, // PANE
        {pattern: /^S_LE$/i, missing: 1, suggest: 'O'}, // SOLE
        {pattern: /^L_NA$/i, missing: 1, suggest: 'U'}, // LUNA
        {pattern: /^V_NO$/i, missing: 1, suggest: 'I'}, // VINO
        {pattern: /^F_ME$/i, missing: 1, suggest: 'A'}, // FAME
        {pattern: /^R_SO$/i, missing: 1, suggest: 'I'}, // RISO
        {pattern: /^_ORA$/i, missing: 1, suggest: 'O'}, // ORA -> MORA, NORA...
        {pattern: /^PI_ZA$/i, missing: 1, suggest: 'Z'}, // PIZZA
        {pattern: /^PA_TA$/i, missing: 1, suggest: 'S'}, // PASTA
        {pattern: /^_ORTE$/i, missing: 1, suggest: 'P'}, // PORTE
        {pattern: /^LI_RO$/i, missing: 1, suggest: 'B'}, // LIBRO
        {pattern: /^MO_DO$/i, missing: 1, suggest: 'N'}, // MONDO
        {pattern: /^TE_PO$/i, missing: 1, suggest: 'M'}, // TEMPO
        {pattern: /^_IOCO$/i, missing: 1, suggest: 'G'}, // GIOCO
        {pattern: /^_UOCO$/i, missing: 1, suggest: 'F'}, // FUOCO
        {pattern: /^FI_ME$/i, missing: 1, suggest: 'L'}, // FILME
        {pattern: /^_ONTE$/i, missing: 1, suggest: 'F'}, // FONTE
        {pattern: /^CA_TO$/i, missing: 1, suggest: 'N'}, // CANTO
        {pattern: /^_ESTO$/i, missing: 1, suggest: 'T'}, // TESTO
        {pattern: /^VI_A$/i, missing: 1, suggest: 'T'}, // VITA
        
        // Pattern con 2 lettere mancanti
        {pattern: /^G__TO$/i, missing: 2, suggest: 'T'}, // GATTO (manca T se manca anche A)
        {pattern: /^C__E$/i, missing: 2, suggest: 'N'}, // CANE (manca N)
        {pattern: /^C__A$/i, missing: 2, suggest: 'S'}, // CASA (manca S)
        {pattern: /^M__E$/i, missing: 2, suggest: 'R'}, // MARE (manca R)
        {pattern: /^P__E$/i, missing: 2, suggest: 'N'}, // PANE (manca N)
        {pattern: /^S__E$/i, missing: 2, suggest: 'L'}, // SOLE (manca L)
        {pattern: /^L__A$/i, missing: 2, suggest: 'N'}, // LUNA (manca N)
        {pattern: /^V__O$/i, missing: 2, suggest: 'N'}, // VINO (manca N)
        {pattern: /^PI__A$/i, missing: 2, suggest: 'Z'}, // PIZZA (manca Z)
        {pattern: /^PA__A$/i, missing: 2, suggest: 'S'}, // PASTA (manca S)
        {pattern: /^LI__O$/i, missing: 2, suggest: 'B'}, // LIBRO (manca B)
        {pattern: /^MO__O$/i, missing: 2, suggest: 'N'}, // MONDO (manca N)
        {pattern: /^TE__O$/i, missing: 2, suggest: 'M'}, // TEMPO (manca M)
        
        // Pattern comuni di fine parola
        {pattern: /_IONE$/i, missing: 0, suggest: 'Z'}, // -ZIONE
        {pattern: /_MENTE$/i, missing: 0, suggest: 'L'}, // -MENTE
        {pattern: /_ZZO$/i, missing: 0, suggest: 'P'}, // -AZZO, -OZZO
        {pattern: /AZIO_E$/i, missing: 0, suggest: 'N'}, // -AZIONE
        {pattern: /_TTO$/i, missing: 0, suggest: 'T'}, // -ETTO, -ATTO, -OTTO
      ];
      
      // Analizza ogni parola
      for(const word of wordsWithBlanks){
        const blankCount = (word.match(/_/g) || []).length;
        
        // Considera solo parole con 1-2 lettere mancanti
        if(blankCount < 1 || blankCount > 2) continue;
        
        // Prova ogni pattern
        for(const p of patterns){
          if(p.pattern.test(word)){
            const suggestedLetter = p.suggest.toUpperCase();
            
            // Verifica che non sia già stata chiamata e non sia una vocale
            if(!allRevealed.includes(suggestedLetter) && !vowels.includes(suggestedLetter)){
              return suggestedLetter;
            }
          }
        }
        
        // Analisi generica: se manca solo 1 lettera, prova consonanti comuni nell'ordine
        if(blankCount === 1){
          const commonConsonants = ['N', 'R', 'T', 'L', 'S', 'C', 'D', 'P', 'M', 'B', 'G', 'V', 'F', 'Z'];
          for(const c of commonConsonants){
            if(!allRevealed.includes(c)){
              return c;
            }
          }
        }
      }
      
      return null; // Nessun completamento trovato
    }
    
    function getNextVowelHuman(alreadyRevealed){
      for(let group of FREQ_VOW_GROUPS){
        const shuffled = [...group].sort(() => Math.random() - 0.5);
        for(let v of shuffled){
          if(!alreadyRevealed.includes(v)) return v;
        }
      }
      return null;
    }
    
    function setBtnState(id,d){ const b=document.getElementById(id); if(!b) return; if(d){ b.disabled=true; b.setAttribute('aria-disabled','true'); } else { b.disabled=false; b.setAttribute('aria-disabled','false'); } }
    function isBtnDisabled(id){ const b=document.getElementById(id); return b && b.getAttribute('aria-disabled')==='true'; }
    function showFlashMessage(msg,type){
      const ov=document.getElementById('flash-overlay'),txt=document.getElementById('flash-message');
      txt.textContent=msg; txt.style.color=type==='bad'?'#f00':(type==='good'?'#0f0':'#ffd700');
      ov.style.borderColor=txt.style.color; ov.style.opacity=1; setTimeout(()=>{ ov.style.opacity=0; },4000);
    }

    function jumpToSection(id){
      const el = document.getElementById(id);
      if(!el) return;
      el.scrollIntoView({behavior:'smooth', block:'start'});
      setTimeout(()=>{ try{ el.focus({preventScroll:true}); } catch(e){ try{ el.focus(); }catch(_){ } } }, 250);
    }

    function toggleContrast(){ document.body.classList.toggle('high-contrast'); speak("Contrasto cambiato"); }
    function openHelp(){ 
      const panel = document.getElementById('help-panel');
      panel.classList.remove('hidden'); 
      // ✅ FIX: Rendi il pannello focusable e dai il focus
      panel.setAttribute('tabindex', '0');
      panel.setAttribute('role', 'dialog');
      panel.setAttribute('aria-modal', 'true');
      panel.setAttribute('aria-label', 'Aiuto e tasti rapidi');
      setTimeout(() => {
        panel.focus();
        speak("Aiuto aperto. Usa frecce per scorrere, ESC o bottone Chiudi per uscire.");
      }, 100);
    }
    function closeHelp(){ 
      document.getElementById('help-panel').classList.add('hidden'); 
      speak("Aiuto chiuso");
    }
    function addActionToHistory(txt){
      actionHistory.unshift({text:txt, time:new Date().toLocaleTimeString()});
      if(actionHistory.length>50) actionHistory.pop();
    }
    
    
    function showResultPopup(message, speakMessage = null){
      document.getElementById('result-text').textContent = message;
      document.getElementById('result-popup').classList.remove('hidden');
      speak(speakMessage || message);
      addActionToHistory(message); 
      setTimeout(() => {
        const btn = document.getElementById('result-popup').querySelector('button');
        if(btn) btn.focus();
      }, 100);
    }
    
    function closeResultPopup(){
      document.getElementById('result-popup').classList.add('hidden');
      // In vista testo, ritorna focus su GIRA
      if(isAccessibleMode){
        setTimeout(()=> document.getElementById('btn-acc-spin')?.focus(), 100);
      }
    }
    
    function openActionHistory(focusFirst=false){
      document.getElementById('action-history-panel').classList.remove('hidden');
      const c=document.getElementById('action-history-list'); c.innerHTML='';
      if(!actionHistory.length){
        c.innerHTML='<p style="color:#aaa;">Nessuna azione.</p>';
      } else {
        if(actionHistory && Array.isArray(actionHistory)) actionHistory.forEach((a, idx)=>{
          const b=document.createElement('button');
          b.className='history-item';
          b.type='button';
          b.dataset.idx=idx;
          b.innerHTML = `<strong>${a.time}</strong> — ${a.text}`;
          b.onclick = ()=> speak(`${a.time}. ${a.text}`);
          c.appendChild(b);
        });
      }
      speak("Storico aperto. Usa freccia su e giù per navigare.");
      if(focusFirst){
        setTimeout(()=>{ const first=c.querySelector('.history-item'); if(first) first.focus(); },60);
      }
    }
    function closeActionHistory(){ document.getElementById('action-history-panel').classList.add('hidden'); }

    let mysteryChoiceResolver = null;
    let isMysteryModalOpen = false;

    function openMysteryModal(){
      if(isMysteryModalOpen) return;
      isMysteryModalOpen = true;
      const ov = document.getElementById('mystery-choice-overlay');
      if(ov) ov.classList.remove('hidden');
      speak("Mistero! Scegli: Apri il mistero, oppure prendi 500 in palio.");
      setTimeout(()=>{ const b=document.getElementById('btn-mystery-open'); if(b) b.focus(); }, 120);
    }
    function closeMysteryModal(){
      isMysteryModalOpen = false;
      const ov = document.getElementById('mystery-choice-overlay');
      if(ov) ov.classList.add('hidden');
    }
    function chooseMystery(openIt){
      const res = mysteryChoiceResolver;
      mysteryChoiceResolver = null;
      closeMysteryModal();
      if(typeof res === 'function') res(!!openIt);
    }
    function askMysteryChoice(){
      return new Promise(resolve=>{
        mysteryChoiceResolver = resolve;
        openMysteryModal();
      });
    }
    const NATO_ALPHABET = {
      'A':'Ancona', 'B':'Bologna', 'C':'Como', 'D':'Domodossola', 'E':'Empoli',
      'F':'Firenze', 'G':'Genova', 'H':'Hotel', 'I':'Imola', 'J':'Jersey',
      'K':'Kappa', 'L':'Livorno', 'M':'Milano', 'N':'Napoli', 'O':'Otranto',
      'P':'Padova', 'Q':'Quarto', 'R':'Roma', 'S':'Savona', 'T':'Torino',
      'U':'Udine', 'V':'Venezia', 'W':'Washington', 'X':'Xilofono', 'Y':'York', 'Z':'Zara'
    };

    async function readRevealedLetters(){
      if(!currentStanza || !currentPuzzleText) return;
      
      // ✅ RICOSTRUISCE le lettere chiamate dal puzzle e dagli indici rivelati
      // Questo garantisce che TUTTE le lettere chiamate (anche da altri giocatori o da bot) 
      // vengano incluse nell'elenco, non solo quelle che hai chiamato tu
      
      const revealedIndices = currentStanza.lettere_rivelate || [];
      const allRevealedLetters = new Set();
      
      // Scansiona il puzzle e trova quali lettere corrispondono agli indici rivelati
      const sol = currentPuzzleText.toUpperCase();
      let globalIdx = 0;
      
      for(let i = 0; i < sol.length; i++) {
        if(sol[i].match(/[A-ZÀ-Ù]/)) {
          if(revealedIndices.includes(globalIdx)) {
            const cleanLetter = cleanStr(sol[i]);
            allRevealedLetters.add(cleanLetter);
          }
          globalIdx++;
        }
      }
      
      // Converti Set in array ordinato
      const list = [...allRevealedLetters].sort();
      
      if(list.length === 0) {
        speak("Nessuna lettera chiamata ancora in questo round.");
        return;
      }
      
      clearSpeechQueue();
      speak(`Lettere chiamate: ${list.length}`);
      
      for(let i=0; i<list.length; i++){
        await new Promise(r => setTimeout(r, 500));
        const letter = list[i].toUpperCase(); // ✅ Maiuscolo per trovare in NATO_ALPHABET
        const word = NATO_ALPHABET[letter] || letter;
        speak(`${letter}, ${word}`);
      }
    }
    
    function moveWordNav(d) {
      clearSpeechQueue();
      if(spellingTimer) clearTimeout(spellingTimer);
      if(!parsedBoard.length) return;
      let n = navWordIdx + d;
      if(n < 0) n = 0;
      else if(n >= parsedBoard.length) n = parsedBoard.length - 1;
      
      if(n !== navWordIdx) {
        navWordIdx = n;
        navCharIdx = -1; // ✅ FIX 3: Reset sempre a -1 quando cambi parola
        highlightNav();
        let w = parsedBoard[n];
        if(!w) return; 
        let letterCount = (w && w.chars) ? w.chars.length : 0;
        let spelling = "";
        if(w && w.chars && Array.isArray(w.chars)) w.chars.forEach(c => {
          if(c && c.isLetter && !c.isRevealed) spelling += " asterisco";
          else spelling += " " + (c.char ? c.char.toLowerCase() : "");
        });
        speak(`Parola ${n + 1}, ${letterCount} lettere.${spelling}`);
      } else {
        // ✅ FIX 3: Anche se non cambia parola, resetta il carattere
        navCharIdx = -1;
        highlightNav();
        let w = parsedBoard[n];
        if(!w) return;
        let letterCount = (w && w.chars) ? w.chars.length : 0;
        let spelling = "";
        if(w && w.chars && Array.isArray(w.chars)) w.chars.forEach(c => {
          if(c && c.isLetter && !c.isRevealed) spelling += " asterisco";
          else spelling += " " + (c.char ? c.char.toLowerCase() : "");
        });
        speak(`Parola ${n + 1}, ${letterCount} lettere.${spelling}`);
      }
    }

    function moveNav(d) {
      clearSpeechQueue();
      if(spellingTimer) clearTimeout(spellingTimer);
      if(!parsedBoard.length) return;
      
      // ✅ SALVA la parola corrente PRIMA di fare qualsiasi calcolo
      const savedWordIdx = navWordIdx;
      let currentW = parsedBoard[navWordIdx];
      if(!currentW) return; 
      
      let newCharIdx = navCharIdx + d;
      
      // ✅ FIX: Se navCharIdx è -1 (nessuna lettera selezionata)
      if(navCharIdx === -1) {
        if(d > 0) {
          // Freccia destra da inizio parola: vai alla prima lettera (se esiste)
          if(currentW.chars.length > 0) {
            navCharIdx = 0;
            highlightNav();
            readSingleChar();
          } else {
            speak("Parola vuota");
          }
        } else {
          // Freccia sinistra da inizio parola: NON fare nulla
          speak("Inizio parola");
        }
        return;
      }
      
      // ✅ FIX CRITICO: Blocca COMPLETAMENTE il movimento oltre i limiti
      // NON permettere MAI di cambiare parola con le frecce orizzontali!
      if(newCharIdx < 0) {
        // Tentativo di andare prima del primo carattere
        speak("Inizio parola"); 
        return; // ← RETURN IMMEDIATO, non cambiare NULLA
      }
      
      if(newCharIdx >= currentW.chars.length) {
        // Tentativo di andare oltre l'ultimo carattere
        speak("Fine parola"); 
        return; // ← RETURN IMMEDIATO, non cambiare NULLA
      }
      
      // ✅ Movimento valido DENTRO la stessa parola
      navCharIdx = newCharIdx;
      
      // ✅ VERIFICA POST-MODIFICA: assicurati che non sia cambiata la parola
      if(navWordIdx !== savedWordIdx) {
        navWordIdx = savedWordIdx; // Ripristina se qualcosa ha cambiato la parola
      }
      
      highlightNav();
      readSingleChar();
    }

    function highlightNav() {
      document.querySelectorAll('.cursor-char').forEach(e => e.classList.remove('cursor-char'));
      document.querySelectorAll('.cursor-word').forEach(e => e.classList.remove('cursor-word'));
      document.getElementById(`row-${navWordIdx}`)?.classList.add('cursor-word');
      if(navCharIdx >= 0) {
        document.getElementById(`tile-${navWordIdx}-${navCharIdx}`)?.classList.add('cursor-char');
      }
    }

    function readSingleChar() {
      if(!parsedBoard[navWordIdx]) return;
      const c = parsedBoard[navWordIdx].chars[navCharIdx];
      if(!c) return;
      
      
      const totalLetters = parsedBoard[navWordIdx].chars.length;
      const position = navCharIdx + 1; 
      
      const charText = c.isLetter && !c.isRevealed ? "Asterisco" : (NATO[c.char] || c.char);
      speak(`${charText}, ${position} di ${totalLetters}`);
    }

    function openWordInspector() {
      if(!parsedBoard.length) return speak("Nessuna parola.");
      const w = parsedBoard[navWordIdx];
      if(!w) return;
      const cont = document.getElementById('inspector-letters-container');
      cont.innerHTML = "";
      w.chars.forEach((c, idx) => {
        const btn = document.createElement('div');
        btn.className = 'inspector-char-btn';
        btn.setAttribute('role', 'button');
        btn.setAttribute('tabindex', '0');
        let visualChar = (c.isLetter && !c.isRevealed) ? "_" : c.char;
        let spelling = "";
        if(!c.isLetter) spelling = (NATO[c.char] || c.char);
        else if(!c.isRevealed) spelling = `Nascosta`;
        else spelling = `${c.char}, ${NATO[c.char] || ''}`;
        
        btn.innerHTML = `<span>Lettera ${idx + 1}</span> <strong>${visualChar}</strong>`;
        btn.onclick = () => speak(spelling);
        btn.onkeydown = (e) => {
          if(e.key === 'Enter' || e.key === ' ') speak(spelling);
        };
        cont.appendChild(btn);
      });
      document.getElementById('word-inspector-overlay').classList.remove('hidden');
      setTimeout(() => { const first = cont.querySelector('.inspector-char-btn'); if(first) first.focus(); }, 100);
      
      // ✅ FIX: Annuncia il numero di consonanti nel round speciale
      const s = currentStanza;
      const isSpecialRound = s && s.round_giocati === 7;
      const specialVowelsPhase = s && s.fase_speciale === 100;
      
      if(isSpecialRound && !specialVowelsPhase && s.fase_speciale === 101) {
        const match = (s.ultimo_messaggio || '').match(/\((\d+)\/10\)/);
        const consonantsCount = match ? parseInt(match[1]) : 0;
        speak(`Dettaglio parola ${navWordIdx + 1}. Consonanti usate: ${consonantsCount} su 10. Usa tab per scorrere le lettere.`);
      } else {
        speak(`Dettaglio parola ${navWordIdx + 1}. Usa tab per scorrere le lettere.`);
      }
    }

    function closeWordInspector() {
      document.getElementById('word-inspector-overlay').classList.add('hidden');
      document.getElementById('btn-inspect-word').focus();
    }

    function reopenLastInput() {
      if(lastInputMode && !inputMode) {
        const typeMsg = lastInputMode === 'vowel' ? "vocale" : lastInputMode === 'letter' ? "consonante" : "soluzione";
        openInput(lastInputMode);
        speak(`Campo ${typeMsg} riaperto.`);
      }
    }

    async function reorganizePlayers(){
      if(!isHost || !roomId) return;
      
      
      // ✅ UUID: Salva l'UUID del giocatore corrente (non l'indice!)
      const {data: currentStanza} = await _supabase
        .from('stanze')
        .select('id_giocatore_corrente')
        .eq('id', roomId)
        .single();
      
      const currentPlayerUUID = currentStanza?.id_giocatore_corrente; // Ora è UUID!
      
      // Ottieni tutti i giocatori
      const {data: players, error} = await _supabase
        .from('giocatori')
        .select('*')
        .eq('stanza_id', roomId)
        .order('indice');
        
      if(error || !players || players.length === 0){
        return;
      }
      
      
      // ✅ UUID: Trova il giocatore che aveva il turno (per UUID)
      const currentPlayer = players.find(p => p.id === currentPlayerUUID);
      
      // Riassegna indici consecutivi 0, 1, 2...
      for(let i = 0; i < players.length; i++){
        if(players[i].indice !== i){
          await _supabase
            .from('giocatori')
            .update({indice: i})
            .eq('id', players[i].id);
        }
      }
      
      // ✅ UUID: Ripristina il turno usando UUID (se il giocatore esiste ancora)
      let newTurnUUID = null;
      if(currentPlayer){
        // Il giocatore è ancora attivo, mantieni il suo UUID
        newTurnUUID = currentPlayer.id;
      } else {
        // Il giocatore è uscito, passa al primo disponibile
        newTurnUUID = players[0]?.id || null;
      }
      
      await _supabase
        .from('stanze')
        .update({
          id_giocatore_corrente: newTurnUUID, // ← UUID invece di indice!
          ultima_azione: 'riorganizza',
          ultimo_messaggio: 'Turni riorganizzati',
          azione_timestamp: new Date().toISOString()
        })
        .eq('id', roomId);
        
      
      // Refresh
      await fetchFullState();
    }

    async function togglePause() {
      if(!isHost || !currentStanza) return;
      const newState = !currentStanza.in_pausa;
      
      // ✅ FIX TIMER PAUSA: Non aggiornare azione_timestamp qui
      // Sarà aggiornato da reorganizePlayers() quando si toglie la pausa
      await _supabase.from('stanze').update({
        in_pausa: newState, 
        ultimo_messaggio: newState ? "GIOCO IN PAUSA" : "GIOCO RIPRESO"
      }).eq('id', roomId);
      
      // Se togli la pausa, riorganizza i giocatori (che aggiornerà azione_timestamp)
      if(!newState){
        await reorganizePlayers();
      } else {
        // Se METTI in pausa, aggiorna timestamp ora (per fermare il timer)
        await _supabase.from('stanze').update({
          azione_timestamp: new Date().toISOString()
        }).eq('id', roomId);
        await fetchFullState();
      }
    }

    async function preResumeCheck() {
      if(!isHost) return;
      
      
      await checkAndRemoveDisconnectedPlayers();
      
      const { data: pl } = await _supabase.from('giocatori').select('*').eq('stanza_id', roomId).order('indice');
      const listDiv = document.getElementById('player-check-list');
      listDiv.innerHTML = "";
      pl.forEach(p => {
        const row = document.createElement('div');
        row.style = "display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid #555;padding:10px;";
        
        
        const lastPing = p.ultimo_ping ? new Date(p.ultimo_ping) : null;
        const now = new Date();
        const secondsSinceLastPing = lastPing ? Math.floor((now - lastPing) / 1000) : 9999;
        const statusColor = secondsSinceLastPing > 15 ? '#ff4444' : '#00ff00';
        const statusText = secondsSinceLastPing > 15 ? 'OFFLINE' : 'ONLINE';
        
        row.innerHTML = `<span style="font-size:1.2em;color:#fff;">${p.nome} <span style="color:${statusColor};font-size:0.85em;">${statusText}</span></span>`;
        const delBtn = document.createElement('button');
        delBtn.textContent = "ELIMINA";
        delBtn.className = "action-btn";
        delBtn.style = "padding:8px 15px;font-size:.9em;background:red;border:none;min-height:auto;";
        delBtn.onclick = async () => {
          if(confirm("Eliminare " + p.nome + "?")) {
            await _supabase.from('giocatori').delete().eq('id', p.id);
            row.remove();
            speak(`${p.nome} eliminato`);
          }
        };
        row.appendChild(delBtn);
        listDiv.appendChild(row);
      });
      document.getElementById('player-check-overlay').classList.remove('hidden');
      speak("Controllo presenze. I giocatori offline sono stati rimossi automaticamente. Verifica e conferma.");
      setTimeout(() => document.getElementById('btn-confirm-resume').focus(), 150);
    }
    
    async function checkAndRemoveDisconnectedPlayers() {
      if(!isHost || !roomId) return;
      
      const { data: players } = await _supabase.from('giocatori').select('*').eq('stanza_id', roomId);
      if(!players || players.length === 0) return;
      
      const now = new Date();
      const TIMEOUT_SECONDS = 45; // ✅ FIX CHATGPT: Da 15s a 45s (ping ogni 10s)
      
      for(const player of players) {
        const lastPing = player.ultimo_ping ? new Date(player.ultimo_ping) : null;
        const secondsSinceLastPing = lastPing ? Math.floor((now - lastPing) / 1000) : 9999;
        
        
        if(secondsSinceLastPing > TIMEOUT_SECONDS) {
          await _supabase.from('giocatori').delete().eq('id', player.id);
          showFlashMessage(`${player.nome} disconnesso e rimosso`, 'bad');
          speak(`${player.nome} si è disconnesso`);
        }
      }
    }

    async function confirmResumeGame() {
      document.getElementById('player-check-overlay').classList.add('hidden');
      await togglePause();
    }

    function closePlayerCheckOverlay(){
      document.getElementById('player-check-overlay').classList.add('hidden');
      speak("Rimaniamo in pausa.");
    }

    function announceTurn(){
      if(!currentStanza) return;
      // ✅ UUID: Confronta per UUID
      const currentPlayer = currentStanza.giocatori.find(p=>p.id===currentStanza.id_giocatore_corrente);
      const isMe = (currentStanza.id_giocatore_corrente === myId);
      const turnMsg = isMe ? "È il tuo turno!" : `Turno di ${currentPlayer?.nome || 'sconosciuto'}`;
      
      
      let totalWords = parsedBoard.length;
      let totalLetters = 0;
      let revealedLetters = 0;
      
      parsedBoard.forEach(w => {
        if(w && w.chars && Array.isArray(w.chars)) w.chars.forEach(c => {
          if(c.isLetter){
            totalLetters++;
            if(c.isRevealed) revealedLetters++;
          }
        });
      });
      
      const boardMsg = `Tabellone: ${totalWords} parole, ${totalLetters} lettere totali, ${revealedLetters} scoperte.`;
      
      // ✅ Leggi categoria e tema dai due span dentro l'H2
      const categoryMain = document.getElementById('category-main')?.textContent || '';
      const hintText = document.getElementById('round-hint')?.textContent || '';
      
      let categoryMsg = '';
      if(categoryMain && categoryMain !== '...') {
        categoryMsg = ` Categoria: ${categoryMain}.`;
        
        // Se c'è un tema/argomento, leggilo separatamente
        if(hintText) {
          categoryMsg += ` ${hintText}.`;
        }
      }
      
      speak(`${turnMsg} ${boardMsg}${categoryMsg}`);
    }

    function announceScore(){
      if(!currentStanza) return;
      const me = currentStanza.giocatori.find(p=>p.id===myId);
      if(!me){
        speak("Nessun giocatore trovato");
        return;
      }
      
      const roundScore = me.punteggio_round || 0;
      const totalScore = me.punteggio_totale || 0;
      
      speak(`Punteggio parziale: ${roundScore} euro. Punteggio totale: ${totalScore} euro.`);
    }

    async function openPlayersPanel(){
      const panel = document.getElementById('players-panel');
      panel.classList.remove('hidden');
      
      const list = document.getElementById('players-list');
      list.innerHTML = '<p style="color:#888; text-align:center; padding:20px;">Caricamento...</p>';
      
      
      if(roomId){
        const {data: freshStanza} = await _supabase.from('stanze').select('*, giocatori(*)').eq('id', roomId).maybeSingle();
        if(freshStanza && freshStanza.giocatori && freshStanza.giocatori.length > 0){
          list.innerHTML = '<h3 style="color:var(--col-accent); margin-bottom:15px;">CLASSIFICA</h3>';
          
          
          const sorted = [...freshStanza.giocatori].sort((a,b) => (b.punteggio_totale||0) - (a.punteggio_totale||0));
          sorted.forEach((p, i) => {
            const div = document.createElement('div');
            div.style = 'background:#111; border:1px solid #333; padding:15px; margin-bottom:20px; border-radius:8px; display:flex; flex-direction:column; gap:10px;';
            
            const info = document.createElement('span');
            info.style = 'color:#ddd; font-size:1.1em;';
            info.innerHTML = `<strong style="color:var(--col-accent);">${i+1}.</strong> ${p.nome} - <strong>${p.punteggio_totale||0} €</strong> (Giro: ${p.punteggio_round||0} €)`;
            div.appendChild(info);
            
            
            if(isHost && p.id !== myId){
              const btnContainer = document.createElement('div');
              btnContainer.style = 'display:flex; gap:8px; flex-wrap:wrap;';
              
              
              const btnHost = document.createElement('button');
              btnHost.textContent = 'PASSA HOST';
              btnHost.className = 'action-btn';
              btnHost.style = 'padding:10px 15px; font-size:0.9em; background:#1a5490; border-color:#4a90e2; min-height:auto;';
              btnHost.onclick = () => transferHost(p.id, p.nome);
              btnContainer.appendChild(btnHost);
              
              
              const btnDel = document.createElement('button');
              btnDel.textContent = 'ELIMINA';
              btnDel.className = 'action-btn';
              btnDel.style = 'padding:10px 15px; font-size:0.9em; background:#8b0000; border-color:#ff0000; min-height:auto;';
              btnDel.onclick = () => removePlayer(p.id, p.nome);
              btnContainer.appendChild(btnDel);
              
              div.appendChild(btnContainer);
            }
            
            list.appendChild(div);
          });
          
          speak("Pannello giocatori aperto");
          
          
          if(isHost){
            const hostControls = document.createElement('div');
            hostControls.style = 'margin-top:25px; padding-top:20px; border-top:2px solid #444;';
            hostControls.innerHTML = '<h3 style="color:#888; margin-bottom:15px; text-transform:uppercase;">CONTROLLI HOST</h3>';
            
            const controlsGrid = document.createElement('div');
            controlsGrid.style = 'display:grid; grid-template-columns:1fr 1fr; gap:10px;';
            
            
            const btnShare = document.createElement('button');
            btnShare.textContent = 'CONDIVIDI LINK';
            btnShare.className = 'action-btn';
            btnShare.style = 'padding:12px; font-size:1em; background:#1a5490; border-color:#4a90e2; min-height:auto;';
            btnShare.onclick = shareRoom;
            controlsGrid.appendChild(btnShare);
            
            
            const btnBot = document.createElement('button');
            btnBot.textContent = 'AGGIUNGI BOT (B)';
            btnBot.className = 'action-btn';
            btnBot.style = 'padding:12px; font-size:1em; background:#1a1a5a; border-color:cyan; color:cyan; min-height:auto;';
            btnBot.onclick = () => { addBot(); closePlayers(); };
            controlsGrid.appendChild(btnBot);
            
            
            const btnPause = document.createElement('button');
            btnPause.textContent = 'PAUSA';
            btnPause.className = 'action-btn';
            btnPause.style = 'padding:12px; font-size:1em; background:#5a3a1a; border-color:orange; min-height:auto;';
            btnPause.onclick = () => { togglePause(); closePlayers(); };
            controlsGrid.appendChild(btnPause);
            
            
            const btnReset = document.createElement('button');
            btnReset.textContent = 'RESET PARTITA';
            btnReset.className = 'action-btn';
            btnReset.style = 'padding:12px; font-size:1em; background:#1a1a5a; border-color:blue; min-height:auto;';
            btnReset.onclick = () => { resetGame(); closePlayers(); };
            controlsGrid.appendChild(btnReset);
            
            
            const btnClose = document.createElement('button');
            btnClose.textContent = 'CHIUDI STANZA';
            btnClose.className = 'action-btn';
            btnClose.style = 'padding:12px; font-size:1em; background:#5a1a1a; border-color:red; min-height:auto;';
            btnClose.onclick = closeRoom;
            controlsGrid.appendChild(btnClose);
            
            hostControls.appendChild(controlsGrid);
            list.appendChild(hostControls);
          }
          
          
          setTimeout(() => {
            const firstBtn = list.querySelector('button') || panel.querySelector('button');
            if(firstBtn) firstBtn.focus();
          }, 100);
          
        } else {
          list.innerHTML = '<p style="color:#888; text-align:center; padding:20px;">Nessun giocatore presente.</p>';
          speak("Nessun giocatore");
        }
      } else {
        list.innerHTML = '<p style="color:#888; text-align:center; padding:20px;">Nessuna partita attiva.</p>';
        speak("Nessuna partita attiva");
      }
    }

    function closePlayers(){
      document.getElementById('players-panel').classList.add('hidden');
    }

    async function removePlayer(playerId, playerName){
      if(!isHost) return;
      if(!confirm(`Eliminare ${playerName}?`)) return;
      
      try {
        
        // Elimina il giocatore
        const {error: deleteError} = await _supabase
          .from('giocatori')
          .delete()
          .eq('stanza_id', roomId)
          .eq('id', playerId);
          
        if(deleteError){
          alert('Errore nell\'eliminazione: ' + deleteError.message);
          return;
        }
        
        showFlashMessage(`${playerName} eliminato dal database...`, 'info');
        
        // Riorganizza tutti i giocatori rimasti
        await reorganizePlayers();
        
        speak(`${playerName} eliminato. Turni riorganizzati. Tutti i giocatori sono stati risincronizzati.`);
        showFlashMessage(`${playerName} eliminato e turni riorganizzati`, 'success');
        
        // Riapri il pannello giocatori aggiornato
        setTimeout(() => openPlayersPanel(), 500);
        
      } catch(e){
        alert('Errore: ' + e.message);
      }
    }

    async function transferHost(newHostId, newHostName){
      if(!isHost) return;
      if(!confirm(`Passare il controllo della stanza a ${newHostName}?`)) return;
      
      try {
        // Rimuovi host al vecchio
        const {error: removeError} = await _supabase.from('giocatori').update({is_host: false}).eq('id', myId);
        if(removeError){
          alert('Errore: ' + removeError.message);
          return;
        }
        
        // Assegna host al nuovo
        const {error: assignError} = await _supabase.from('giocatori').update({is_host: true}).eq('id', newHostId);
        if(assignError){
          alert('Errore: ' + assignError.message);
          return;
        }
        
        // Aggiorna stato locale
        isHost = false;
        
        // Aggiorna database stanza
        await _supabase.from('stanze').update({
          ultima_azione: 'passa_host',
          ultimo_messaggio: `${newHostName} è ora l'host`,
          azione_timestamp: new Date().toISOString()
        }).eq('id', roomId);
        
        speak(`${newHostName} è ora l'host della stanza.`);
        
        // Aggiorna stato
        await fetchFullState();
        
        // Riapri pannello aggiornato
        setTimeout(() => openPlayersPanel(), 300);
        
      } catch(e){
        alert('Errore: ' + e.message);
      }
    }

    async function shareRoom(){
      if(!currentStanza) return;
      
      const roomCode = currentStanza.codice;
      const shareUrl = `${window.location.origin}${window.location.pathname}#stanza=${roomCode}`;
      
      
      if(navigator.share){
        
        try {
          await navigator.share({
            title: 'La Ruota - Unisciti alla partita!',
            text: `Entra nella stanza "${roomCode}"`,
            url: shareUrl
          });
          speak("Link condiviso");
        } catch(e){
          
          if(e.name !== 'AbortError') {
            speak("Condivisione annullata");
          }
        }
      } else {
        
        try {
          await navigator.clipboard.writeText(shareUrl);
          speak("Link copiato negli appunti!");
          alert(`Link della stanza copiato!\n\n${shareUrl}\n\nCondividilo con altri giocatori.`);
        } catch(e){
          
          speak("Copia questo link");
          prompt("Copia questo link per condividere la stanza:", shareUrl);
        }
      }
    }

    function readAllScores(){
      if(!currentStanza) return;
      let txt="Classifica: ";
      currentStanza.giocatori.forEach(p=> txt += `${p.nome} ${p.punteggio_totale}, `);
      speak(txt);
    }

    function parseAndRenderBoard(text, rev, resetNavigation = false) {
      rev = Array.isArray(rev) ? rev : [];
      
      // ✅ FIX CRITICO: SALVA la posizione corrente prima di ricostruire il tabellone
      // SOLO se non vogliamo resettare (es: quando è la stessa frase ma si aggiorna)
      const savedWordIdx = resetNavigation ? 0 : navWordIdx;
      const savedCharIdx = resetNavigation ? -1 : navCharIdx;
      
      const c = document.getElementById('board-container');
      c.innerHTML = '';
      parsedBoard = [];
      let gI = 0;
      let totalLetters = 0;
      let revealedLetters = 0;
      if(!text) return; 

      text.toUpperCase().split(' ').forEach(wS => {
        let wO = { str: wS, chars: [] };
        const r = document.createElement('div');
        r.className = 'board-row';
        r.id = `row-${parsedBoard.length}`;
        r.setAttribute('role', 'row');
        r.setAttribute('aria-label', `Parola ${parsedBoard.length + 1}`);
        
        for(let j = 0; j < wS.length; j++) {
          const ch = wS[j];
          const isL = ch.match(/[A-ZÀ-Ù]/);
          const isR = !isL || rev.includes(gI);
          wO.chars.push({ char: ch, isRevealed: isR, isLetter: !!isL });
          const d = document.createElement('div');
          d.className = 'tile' + (isL && !isR ? ' empty' : '') + (isL ? '' : ' punct');
          if(isL && isR) d.classList.add('revealed');
          if(isL && !isR) d.textContent = '';
          else d.textContent = ch;
          
          if(isL && !isR) d.setAttribute('aria-label', 'Lettera nascosta');
          else if(isL && isR) {
            const natoWord = NATO[ch] || ch;
            d.setAttribute('aria-label', `${ch}, ${natoWord}`);
          } else d.setAttribute('aria-label', NATO[ch] || ch);
          
          d.id = `tile-${parsedBoard.length}-${j}`;
          d.setAttribute('tabindex', '-1');
          r.appendChild(d);
          if(isL) { gI++; totalLetters++; if(isR) revealedLetters++; }
        }
        c.appendChild(r);
        parsedBoard.push(wO);
      });
      
      // ✅ FIX CRITICO: RIPRISTINA la posizione salvata, con clamp ai limiti
      // Se la parola salvata esiste ancora, torna lì
      if(savedWordIdx >= 0 && savedWordIdx < parsedBoard.length) {
        navWordIdx = savedWordIdx;
        const currentWord = parsedBoard[navWordIdx];
        // Clamp navCharIdx ai limiti della parola corrente
        if(savedCharIdx >= currentWord.chars.length) {
          navCharIdx = currentWord.chars.length - 1; // Vai all'ultimo carattere
        } else if(savedCharIdx < -1) {
          navCharIdx = -1; // Nessun carattere selezionato
        } else {
          navCharIdx = savedCharIdx; // Ripristina posizione esatta
        }
      } else {
        // La parola salvata non esiste più (frase cambiata), resetta
        navWordIdx = 0;
        navCharIdx = -1;
      }
      
      const numWords = parsedBoard.length;
      const summary = `Tabellone: ${numWords} parole, ${totalLetters} lettere totali, ${revealedLetters} scoperte.`;
      c.setAttribute('aria-label', summary);
      highlightNav();
      if(isAccessibleMode) updateAccessibleBoard();
    }

    window.addEventListener('keydown', (e)=>{
      if(!e.key) return;
      
      // ✅ GESTIONE NAVIGAZIONE PANNELLO CRONOLOGIA (prima di tutto)
      const historyPanel=document.getElementById('action-history-panel');
      const historyOpen = historyPanel && !historyPanel.classList.contains('hidden');
      if(historyOpen) {
        const list=document.getElementById('action-history-list');
        const items=[...list.querySelectorAll('.history-item')];
        if(items.length) {
          const key = (e.key || "").toLowerCase();
          if(['arrowdown','arrowup','home','end'].includes(key)) {
            e.preventDefault();
            const active=document.activeElement;
            let idx=items.indexOf(active);
            if(idx<0) idx=0;
            if(key==='arrowdown') idx=Math.min(items.length-1, idx+1);
            if(key==='arrowup') idx=Math.max(0, idx-1);
            if(key==='home') idx=0;
            if(key==='end') idx=items.length-1;
            items[idx].focus();
            return;
          }
        }
      }

      // ✅ GESTIONE TASTI RAPIDI DI GIOCO
      if((e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'r') || e.key.toLowerCase() === 'f5') return;
      
      const k = (e.key || "").toLowerCase();
      
      // ✅ FIX: I tasti rapidi di gioco funzionano SOLO quando sei nella stanza
      // Non interferire con i campi di input nella schermata di setup
      const isInSetup = !document.getElementById('game-panel').classList.contains('hidden') === false;
      const setupPanel = document.getElementById('setup-panel');
      const isInSetupScreen = setupPanel && !setupPanel.classList.contains('hidden');
      
      // ESC deve funzionare SEMPRE, anche in input mode
      if(k === 'escape'){
         e.preventDefault();
         
         // ✅ FIX: Prima controlla se c'è un pannello informativo aperto
         const infoPanels = ['action-history-panel', 'help-panel', 'players-panel', 'chat-overlay', 'player-check-overlay', 'word-inspector-overlay', 'mystery-choice-overlay'];
         let panelClosed = false;
         
         for(const panelId of infoPanels) {
           const panel = document.getElementById(panelId);
           if(panel && !panel.classList.contains('hidden')) {
             panel.classList.add('hidden');
             panelClosed = true;
           }
         }
         
         // Se abbiamo chiuso un pannello, termina qui
         if(panelClosed) {
           speak("Pannello chiuso.");
           return;
         }
         
         // ✅ Altrimenti controlla se è il caso di chiudere l'input
         const s = currentStanza;
         const isMe = (s?.id_giocatore_corrente === myId);
         
         // Se sei in modalità consonante (letter) E è ancora il tuo turno, NON chiudere!
         if(inputMode === 'letter' && isMe){
           speak("Non puoi annullare la consonante! Devi inserirla.");
           return;
         }
         
         // Altrimenti chiudi l'input
         const inputArea = document.getElementById('input-area');
         if(inputArea && !inputArea.classList.contains('hidden')) {
           inputArea.classList.add('hidden');
           closeInput();
           speak("Input chiuso.");
         }
         
         return;
      }
      
      // Blocca altri tasti se sei in input mode, MA permetti Ctrl+Tasto
      if(inputMode && !e.ctrlKey) return;

      const isInInput = document.activeElement && document.activeElement.tagName==='INPUT';
      
      // ✅ FIX: Se sei in un campo di input del gioco (consonante/vocale/soluzione/chat),
      // blocca SOLO Ctrl+V (deve incollare) e Ctrl+A (deve selezionare tutto)
      // MA lascia passare tutti gli altri Ctrl (G, L, T, ecc.) che attivano le funzioni del gioco
      const gameInput = document.getElementById('game-input');
      const chatInput = document.getElementById('chat-input');
      if(isInInput && (document.activeElement === gameInput || document.activeElement === chatInput)) {
        if(e.ctrlKey && k === 'v') {
          // Lascia passare Ctrl+V al browser per incollare
          return;
        }
        if(e.ctrlKey && k === 'a') {
          // Lascia passare Ctrl+A al browser per selezionare tutto
          return;
        }
        // Tutti gli altri Ctrl continuano nel codice sotto per attivare funzioni del gioco
      }
      
      // ✅ FIX: Se sei nella schermata di setup (prima di entrare in stanza),
      // NON intercettare i tasti - lascia funzionare tutto normalmente (Ctrl+A, ecc)
      if(isInSetupScreen && !e.key.toLowerCase().startsWith('f')) {
        // Permetti solo F5 e simili, tutto il resto passa al browser
        return;
      }
      
      if(isMysteryModalOpen){
        const btn1 = document.getElementById('btn-mystery-open');
        const btn2 = document.getElementById('btn-mystery-500');
        if(['arrowleft','arrowright','arrowup','arrowdown'].includes(k)){
          e.preventDefault();
          if(document.activeElement === btn1 && btn2) btn2.focus();
          else if(btn1) btn1.focus();
          return;
        }
        if(k==='enter'){ e.preventDefault(); if(document.activeElement) document.activeElement.click(); return; }
        if(e.ctrlKey || /^[a-z]$/.test(k)) { e.preventDefault(); return; }
      }

      // ✅ FIX: Se sei in un campo input, permetti le frecce per navigare nel testo
      // NON intercettare le frecce quando l'utente sta editando testo
      if(isInInput && ['arrowleft','arrowright','arrowup','arrowdown','home','end'].includes(k)){
        // Lascia che il browser gestisca normalmente la navigazione nel campo input
        return; // Non fare e.preventDefault(), lascia funzionare normalmente
      }
      
      // ✅ FIX: Se il pannello aiuto è aperto, permetti frecce per scorrere
      const helpPanel = document.getElementById('help-panel');
      if(helpPanel && !helpPanel.classList.contains('hidden')) {
        if(['arrowup','arrowdown','pageup','pagedown','home','end'].includes(k)){
          // Lascia che il browser scrolli il pannello normalmente
          return;
        }
      }

      if(k==='arrowup'){ e.preventDefault(); moveWordNav(-1); return; }
      if(k==='arrowdown'){ e.preventDefault(); moveWordNav(1); return; }
      if(k==='arrowleft'){ e.preventDefault(); moveNav(-1); return; }
      if(k==='arrowright'){ e.preventDefault(); moveNav(1); return; }
      if(k===' ' && !isInInput){ e.preventDefault(); reopenLastInput(); return; }
      if((k==='i' && !isInInput) || (e.ctrlKey && k==='i')){ e.preventDefault(); openWordInspector(); return; }
      
      if(k==='1'){ playSharedAudio('snd-clap', 'Applauso'); return; }
      if(k==='2'){ playSharedAudio('snd-laugh', 'Risata'); return; }
      if(k==='3'){ playSharedAudio('snd-boo', 'Fischi'); return; }
      if(k==='4'){ playSharedAudio('snd-ooh', 'Ooh'); return; }
      
      
      if((k==='h' && !isInInput) || (e.ctrlKey && k==='h')){ e.preventDefault(); const p=document.getElementById('help-panel'); if(p.classList.contains('hidden')) openHelp(); else closeHelp(); return; }
      if((k==='g' && !isInInput) || (e.ctrlKey && k==='g')){ e.preventDefault(); doSpin(); return; }
      // ✅ Ctrl+V apre vocale SOLO se NON sei in un campo input (altrimenti Ctrl+V = incolla)
      if((k==='v' && !isInInput) || (e.ctrlKey && k==='v' && !isInInput)){ e.preventDefault(); tryOpenVowelInput(); return; }
      if((k==='p' && !isInInput) || (e.ctrlKey && k==='p')){ 
      e.preventDefault(); 
      // ✅ CORREZIONE CHATGPT: Passa solo se è il tuo turno o sei host
      if(isMe || isHost){
        passTurn();
      } else {
        speak("Non è il tuo turno");
      } return; }
      if((k==='r' && !isInInput) || (e.ctrlKey && k==='r')){ e.preventDefault(); openInput('solve'); return; }
      if((k==='t' && !isInInput) || (e.ctrlKey && k==='t')){ e.preventDefault(); announceTurn(); return; }
      if((k==='k' && !isInInput) || (e.ctrlKey && k==='k')){ e.preventDefault(); openChat(); return; }
      if((k==='s' && !isInInput) || (e.ctrlKey && k==='s')){ 
        e.preventDefault(); 
        openPlayersPanel(); 
        return;
      }
      if((k==='l' && !isInInput) || (e.ctrlKey && k==='l')){ e.preventDefault(); readRevealedLetters(); return; }
      if(k==='a' && !isInInput){ 
        e.preventDefault(); 
        openActionHistory(true); 
        return; 
      }
      if(e.ctrlKey && k==='a' && !isInInput){ 
        e.preventDefault(); 
        openActionHistory(true); 
        return; 
      }
      if((k==='d' && !isInInput) || (e.ctrlKey && k==='d')){ 
        e.preventDefault(); 
        announceScore(); 
        return;
      }
      if((k==='b' && !isInInput) || (e.ctrlKey && k==='b')){ e.preventDefault(); addBot(); return; } 
    });

    function toggleAccessibleMode(){
      isAccessibleMode=!isAccessibleMode;
      document.body.classList.toggle('accessible-mode', isAccessibleMode);
      const btn=document.getElementById('btn-acc-mode');
      btn.setAttribute('aria-pressed', isAccessibleMode);
      btn.style.background=isAccessibleMode ? "#fff" : "transparent";
      btn.style.color=isAccessibleMode ? "#000" : "#fff";
      if(isAccessibleMode){
        updateAccessibleBoard();
        document.getElementById('board-container').setAttribute('aria-hidden','true');
        speak("Vista Testo attivata.");
        // Porta focus su GIRA
        setTimeout(()=> document.getElementById('btn-acc-spin')?.focus(), 200);
      } else {
        document.getElementById('board-container').setAttribute('aria-hidden','false');
        speak("Vista Grafica attivata.");
      }
    }
    function updateAccessibleBoard(){
      if(!currentFrase || !parsedBoard.length) return;
      const container=document.getElementById('acc-word-list');
      container.innerHTML="";
      let totalRevealed=0,totalLetters=0;
      parsedBoard.forEach(w=>w.chars.forEach(c=>{ if(c.isLetter){ totalLetters++; if(c.isRevealed) totalRevealed++; } }));
      document.getElementById('acc-board-summary').textContent = `Frase di ${parsedBoard.length} parole. Lettere scoperte: ${totalRevealed} su ${totalLetters}.`;

      parsedBoard.forEach((w, idx)=>{
        const btn=document.createElement('button');
        btn.className="acc-word-btn";
        let visualText="", srText=`Parola ${idx+1}: `;
        w.chars.forEach(c=>{
          if(c.isLetter){
            if(c.isRevealed){ visualText+=c.char+" "; srText+=c.char+" "; }
            else { visualText+="_ "; srText+="Nascosta "; }
          } else { visualText+=c.char+" "; srText+=(NATO[c.char] || c.char) + " "; }
        });
        btn.innerHTML=`<span>${idx+1}.</span> <strong>${visualText}</strong>`;
        btn.onclick=()=>{
          navWordIdx = idx;
          textNavWordIdx = idx;
          speak(srText);
          // Apri menu rapido con opzioni
          openWordQuickMenu(idx);
        };
        container.appendChild(btn);
      });
    }
    
    // Menu rapido per azioni sulla parola nel tabellone
    function openWordQuickMenu(wordIdx){
      const overlay = document.getElementById('word-quick-menu-overlay');
      if(!overlay) {
        // Crea overlay se non esiste
        const newOverlay = document.createElement('div');
        newOverlay.id = 'word-quick-menu-overlay';
        newOverlay.className = 'hidden';
        newOverlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;width:100vw;height:100vh;background:rgba(0,0,0,0.96);z-index:9999;display:flex;flex-direction:column;justify-content:center;align-items:center;backdrop-filter:blur(5px);';
        newOverlay.innerHTML = `
          <div class="modal-content" style="max-width:400px;">
            <h2 style="color:var(--col-neon);margin-bottom:20px;">PAROLA <span id="quick-menu-word-num"></span></h2>
            <div style="display:flex;flex-direction:column;gap:10px;">
              <button id="btn-quick-inspect" class="action-btn" style="background:#1a4d2e;border-color:#2ecc71;font-size:1.2em;padding:18px;">ISPEZIONA PAROLA</button>
              <button id="btn-quick-spin" class="action-btn btn-spin" style="font-size:1.2em;padding:18px;">GIRA LA RUOTA</button>
              <button id="btn-quick-letters" class="action-btn" style="background:#2c3e50;border-color:#3498db;font-size:1.1em;padding:18px;">LETTERE SCOPERTE</button>
              <button id="btn-quick-close" class="action-btn btn-pass" style="font-size:1.1em;">CHIUDI</button>
            </div>
          </div>
        `;
        document.body.appendChild(newOverlay);
      }
      
      // Mostra overlay e aggiorna numero parola
      const menuOverlay = document.getElementById('word-quick-menu-overlay');
      const wordNumSpan = document.getElementById('quick-menu-word-num');
      if(wordNumSpan) wordNumSpan.textContent = (wordIdx + 1);
      
      menuOverlay.classList.remove('hidden');
      
      // Riconfigura event listeners con il wordIdx corretto (closure)
      document.getElementById('btn-quick-inspect').onclick = () => {
        closeWordQuickMenu();
        openWordInspectorForWord(wordIdx);
      };
      document.getElementById('btn-quick-spin').onclick = () => {
        closeWordQuickMenu();
        doSpin();
      };
      document.getElementById('btn-quick-letters').onclick = () => {
        closeWordQuickMenu();
        readRevealedLetters();
      };
      document.getElementById('btn-quick-close').onclick = () => {
        closeWordQuickMenu();
      };
      
      // Focus sul primo pulsante
      setTimeout(() => document.getElementById('btn-quick-inspect')?.focus(), 100);
    }
    
    function closeWordQuickMenu(){
      const overlay = document.getElementById('word-quick-menu-overlay');
      if(overlay) overlay.classList.add('hidden');
      
      // Ritorna focus su GIRA in vista accessibile
      if(isAccessibleMode){
        setTimeout(() => document.getElementById('btn-acc-spin')?.focus(), 100);
      }
    }
    
    // Variabile per tracciare l'indice della parola corrente nella navigazione
    let textNavWordIdx = 0;
    
    // Toggle pannello "Altri Comandi"
    function toggleAccMoreCommands(){
      const panel = document.getElementById('acc-more-commands');
      const btn = document.getElementById('btn-acc-more');
      if(panel.style.display === 'none' || !panel.style.display){
        panel.style.display = 'grid';
        btn.textContent = 'ALTRI COMANDI ▲';
        btn.style.background = '#444';
      } else {
        panel.style.display = 'none';
        btn.textContent = 'ALTRI COMANDI ▼';
        btn.style.background = '#333';
        // Ritorna focus su GIRA
        setTimeout(()=> document.getElementById('btn-acc-spin')?.focus(), 100);
      }
    }
    
    // Navigazione tabellone in vista testo
    function navigateTextBoard(direction){
      if(!parsedBoard.length) return;
      
      if(direction === 'first'){
        textNavWordIdx = 0;
      } else if(direction === 'next'){
        textNavWordIdx = Math.min(textNavWordIdx + 1, parsedBoard.length - 1);
      } else if(direction === 'prev'){
        textNavWordIdx = Math.max(textNavWordIdx - 1, 0);
      }
      
      announceCurrentWord();
    }
    
    // Annuncia la parola corrente
    function announceCurrentWord(){
      if(!parsedBoard[textNavWordIdx]) return;
      
      const word = parsedBoard[textNavWordIdx];
      let srText = `Parola ${textNavWordIdx + 1}: `;
      
      word.chars.forEach(c=>{
        if(c.isLetter){
          if(c.isRevealed){ 
            srText += c.char + " "; 
          } else { 
            srText += "Nascosta "; 
          }
        } else { 
          srText += (NATO[c.char] || c.char) + " "; 
        }
      });
      
      speak(srText);
    }
    
    // Apri inspector per parola specifica
    function openWordInspectorForWord(wordIdx){
      if(!parsedBoard[wordIdx]) return;
      navWordIdx = wordIdx;
      openWordInspector();
    }


    function askPrivacy(){
      const nm=document.getElementById('inp-name').value.trim();
      if(!nm) return speak("Inserisci nome.");
      document.getElementById('privacy-dialog').classList.remove('hidden');
      setTimeout(()=>{ const b=document.getElementById('privacy-dialog').querySelector('button'); if(b) b.focus(); },100);
    }
    async function createRoomFinal(isPublic){
      document.getElementById('privacy-dialog').classList.add('hidden');
      let cd=document.getElementById('inp-code').value.trim().toUpperCase();
      if(!cd) {
        speak("Devi inserire un codice stanza");
        document.getElementById('setup-panel').classList.remove('hidden');
        document.getElementById('inp-code').focus();
        return;
      }
      joinGame(true, cd, isPublic);
    }
    async function fetchPublicRooms(){
      const l=document.getElementById('rooms-list'); l.innerHTML="Cerco...";
      const {data:s}=await _supabase.from('stanze').select('codice,stato').eq('is_public',true).neq('stato','terminata').limit(10);
      if(!s||!s.length){ l.innerHTML="Nessuna stanza."; return; }
      l.innerHTML="";
      s.forEach(r=>{
        const b=document.createElement('button'); b.className='action-btn'; b.style="width:100%;margin:5px 0;padding:10px;font-size:0.8em;";
        b.textContent=`${r.codice} (${r.stato})`;
        b.onclick=()=>{ document.getElementById('inp-code').value=r.codice; joinGame(false); };
        l.appendChild(b);
      });
    }

    async function joinGame(cr, forcedCode=null, isPublic=false){
      const nm=document.getElementById('inp-name').value.trim().toUpperCase();
      const cd=forcedCode || document.getElementById('inp-code').value.trim().toUpperCase();
      if(!nm) return speak("Nome mancante");

      try{
        let st;
        if(cr){
          // ✅ FIX: Controlla se il codice esiste già prima di creare
          const {data: existing} = await _supabase.from('stanze').select('codice').eq('codice', cd).maybeSingle();
          
          if(existing){
            speak(`Errore: esiste già una stanza con codice ${cd}. Scegline un altro!`);
            alert(`ERRORE: Esiste già una stanza con il codice "${cd}".\n\nScegli un codice diverso o entra nella stanza esistente usando il pulsante ENTRA.`);
            document.getElementById('privacy-dialog').classList.add('hidden');
            document.getElementById('setup-panel').classList.remove('hidden');
            document.getElementById('inp-code').focus();
            return;
          }
          
          const {data:fr}=await _supabase.from('frasi').select('id,categoria').neq('categoria','SITUAZIONI QUOTIDIANE').limit(500);
          if(!fr || fr.length === 0){
            speak("Errore: nessuna frase disponibile");
            return;
          }
          
          const validPhrases = fr.filter(f => f.categoria !== 'SITUAZIONI QUOTIDIANE');
          if(validPhrases.length === 0){
            speak("Errore: tutte le frasi sono SITUAZIONI QUOTIDIANE");
            return;
          }
          const rid=validPhrases[Math.floor(Math.random()*validPhrases.length)].id;
          const {data}=await _supabase.from('stanze').insert({
            codice:cd, 
            frase_corrente_id:rid, 
            is_public:isPublic, 
            round_giocati:1, 
            fase_speciale:0,
            stato:'gioco',
            in_pausa:false,
            montepremi_round:0,
            lettere_rivelate:[],
            ultima_azione:'creazione', 
            azione_timestamp:new Date().toISOString()
          }).select().maybeSingle();
          st=data;
        } else {
          const {data}=await _supabase.from('stanze').select('*').eq('codice',cd).maybeSingle();
          if(!data) {
            return speak("Stanza inesistente");
          }
          st=data;
        }
        roomId=st.id;
        
        
        localStorage.setItem('lastRoomCode', cd);
        localStorage.setItem('lastPlayerName', nm);

        const {data:exist}=await _supabase.from('giocatori').select('*').eq('stanza_id',roomId).eq('nome',nm).maybeSingle();
        if(exist){ 
          myId=exist.id; 
          myIndex=exist.indice; 
          isHost=exist.is_host;
          
          // Verifica che myId sia un UUID valido
          if(typeof myId === 'number') {
            alert("ERRORE DATABASE: Il tuo ID giocatore è un numero vecchio. Devi ricreare la stanza!");
          }
        }
        else{
          // ✅ CONTROLLO LIMITE: Massimo 3 giocatori per stanza
          const {data:allPlayers}=await _supabase.from('giocatori').select('id').eq('stanza_id',roomId);
          if(allPlayers && allPlayers.length >= 3){
            alert("Stanza piena! Massimo 3 giocatori.");
            speak("Stanza piena. Massimo tre giocatori.");
            return;
          }
          
          const {data:mx}=await _supabase.from('giocatori').select('indice').eq('stanza_id',roomId).order('indice',{ascending:false}).limit(1).maybeSingle();
          myIndex=(mx)?mx.indice+1:0; isHost=(myIndex===0);
          const {data:pl, error:plError}=await _supabase.from('giocatori').insert({
            stanza_id:roomId,
            nome:nm,
            indice:myIndex,
            is_host:isHost,
            ultimo_ping: new Date().toISOString()
          }).select().maybeSingle();
          
          if(plError || !pl) {
            speak('Errore database: ' + (plError?.message || 'Controlla che il campo ultimo_ping esista nella tabella giocatori'));
            return;
          }
          myId=pl.id;
          
          // ✅ UUID: Se sono il primo giocatore (host), imposto il mio UUID come turno corrente
          if(isHost && myIndex === 0){
            await _supabase.from('stanze').update({
              id_giocatore_corrente: pl.id // ← UUID del primo giocatore!
            }).eq('id', roomId);
          }
        }

        document.getElementById('setup-panel').classList.add('hidden');
        document.getElementById('game-panel').classList.remove('hidden');
        document.getElementById('btn-host-next').classList.toggle('hidden', !isHost);
        document.getElementById('btn-resume-host').classList.toggle('hidden', !isHost);
        
        
        const btnManagement = document.getElementById('btn-management');
        if(btnManagement) {
          btnManagement.textContent = isHost ? 'CONTROLLI E CLASSIFICA (S)' : 'CLASSIFICA (S)';
        }

        gameChannel = _supabase.channel('game').on('postgres_changes',{event:'UPDATE',schema:'public',table:'stanze',filter:`id=eq.${roomId}`},fetchFullState).subscribe();
        
        // ✅ CORREZIONE CHATGPT: Subscription realtime su giocatori (INSERT, UPDATE, DELETE)
        playersChannel = _supabase.channel('players').on('postgres_changes',{event:'*',schema:'public',table:'giocatori',filter:`stanza_id=eq.${roomId}`}, async (payload) => {
          
          // Ricarica stato completo quando cambia la lista giocatori
          await fetchFullState();
          
          // Annuncia cambiamenti significativi
          if(payload.eventType === 'INSERT' && payload.new){
            speak(`${payload.new.nome} è entrato nella stanza`);
          } else if(payload.eventType === 'DELETE' && payload.old){
            speak(`${payload.old.nome} ha lasciato la stanza`);
          }
        }).subscribe();
        
        chatChannel = _supabase.channel('chat').on('postgres_changes',{event:'INSERT',schema:'public',table:'chat_messaggi',filter:`stanza_id=eq.${roomId}`},payload=>{
          
          const message = payload.new.messaggio;
          const senderName = payload.new.giocatore_nome;
          
          // Check if it's a sound effect
          if(message.startsWith('[SOUND:')){
            const soundMatch = message.match(/\[SOUND:([^\]]+)\](.+)/);
            if(soundMatch){
              const soundId = soundMatch[1];
              const soundName = soundMatch[2];
              
              // Play the sound for everyone (including sender)
              playAudio(soundId);
              
              // Speak it if it's from someone else
              if(senderName !== nm) {
                speakChat(`${senderName} ha fatto: ${soundName}`);
              }
              
              // Show a visual notification
              showFlashMessage(`${senderName} ${soundName}`, 'info');
            }
          } else {
            // Normal chat message
            if(senderName !== nm) {
              speakChat(`${senderName} scrive: ${message}`);
            }
          }
          
          const chatOverlay = document.getElementById('chat-overlay');
          if(chatOverlay && !chatOverlay.classList.contains('hidden')) {
            fetchChat(false); 
          }
        }).subscribe();

        fetchFullState();
        turnTimerInterval = setInterval(checkTurnTimer, 1000);
        
        // ✅ CORREZIONE CHATGPT: Avvia ping periodico dopo join
        startPeriodicPing();
        
        
        
        /* if(isHost) {
          setInterval(async () => {
            await checkAndRemoveDisconnectedPlayers();
          }, 10000);
        } */
      } catch(e){
        speak("Errore connessione.");
      }
    }

    async function fetchFullState(){
      if(isFetching) return; isFetching=true;
      const {data:s}=await _supabase.from('stanze').select('*,frasi(*),giocatori(*)').eq('id',roomId).maybeSingle();
      isFetching=false;
      if(s) updateUI(s);
    }

    function getVowelCost(){
      const len=(currentPuzzleText||"").length;
      if(!len) return 1000;
      if(len<=50) return 500;
      if(len<=80) return 1000;
      return 2000;
    }
    
    function tryOpenVowelInput(){
      // ✅ SICUREZZA: Verifica che sia il TUO turno
      if(!currentStanza) return;
      const isMyTurn = (currentStanza.id_giocatore_corrente === myId);
      
      if(!isMyTurn) {
        speak("Non è il tuo turno!");
        playAudio('snd-miss');
        return;
      }
      
      // Controlla condizioni PRIMA di aprire l'input
      const cost = getVowelCost();
      const me = currentStanza?.giocatori?.find(p=>p.id===myId);
      const myRoundMoney = me ? (me.punteggio_round||0) : 0;
      
      // Controlla se hai abbastanza soldi
      if(myRoundMoney < cost){
        playAudio('snd-miss');
        speak(`Non hai abbastanza soldi! Servono ${cost} euro, hai ${myRoundMoney} euro.`);
        alert(`Non hai abbastanza soldi per la vocale!\nCosto: €${cost}\nHai: €${myRoundMoney}`);
        return;
      }
      
      // Controlla se hai già comprato una vocale
      if(vowelsBoughtThisTurn >= 1){
        playAudio('snd-miss');
        speak("Hai già comprato una vocale! Devi girare la ruota prima di comprarne un'altra.");
        alert("Hai già comprato una vocale in questo giro!\nGira la ruota prima di comprarne un'altra.");
        return;
      }
      
      // Ok, apri l'input
      openInput('vowel');
    }

    function hasActiveJolly(me, stanza){
      return !!(me && typeof me.scadenza_jolly === 'number' && me.scadenza_jolly >= stanza.round_giocati);
    }
    async function consumeJolly(){ await _supabase.from('giocatori').update({scadenza_jolly:0}).eq('id', myId); }

    async function tryUseJollyToAvoid(kindLabel){
      const {data:freshStanza} = await _supabase.from('stanze').select('*, giocatori(*)').eq('id', roomId).maybeSingle();
      if(!freshStanza) return false;
      
      const me = freshStanza.giocatori.find(p=>p.id===myId);
      if(!hasActiveJolly(me, freshStanza)) return false;
      
      const ok = confirm(`Hai un JOLLY attivo. Vuoi usarlo per evitare: ${kindLabel}?`);
      if(!ok) return false;
      
      await consumeJolly();
      await _supabase.from('stanze').update({montepremi_round:0,fase_speciale:0,ultima_azione:'jolly',ultimo_messaggio:`JOLLY usato: evitato ${kindLabel}`,azione_timestamp: new Date().toISOString()}).eq('id', roomId);
      return true;
    }

    
    async function addBot(){
      if(!isHost || !roomId) return;
      
      
      const {data: freshStanza} = await _supabase.from('stanze').select('*, giocatori(*)').eq('id', roomId).maybeSingle();
      if(!freshStanza) return;
      
      
      if(freshStanza.giocatori.length >= MAX_PLAYERS) {
        speak("Stanza piena! Massimo " + MAX_PLAYERS + " giocatori.");
        return;
      }
      
      const botNames = [
        "BOT Giulia", "BOT Matteo", "BOT Sofia", "BOT Luca",
        "BOT Elena", "BOT Marco", "BOT Chiara", "BOT Andrea",
        "BOT Francesca", "BOT Alessandro", "BOT Federico", "BOT Lorenzo"
      ];
      const usedNames = freshStanza.giocatori.map(p => p.nome);
      const name = botNames.find(n => !usedNames.includes(n)) || "BOT " + Math.floor(Math.random()*1000);
      const lastInd = freshStanza.giocatori[freshStanza.giocatori.length-1].indice;
      
      await _supabase.from('giocatori').insert({
        stanza_id:roomId, 
        nome:name, 
        indice:lastInd+1, 
        is_host:false,
        ultimo_ping: new Date().toISOString()
      });
      speak("Bot aggiunto: " + name);
      
      
      await fetchFullState();
    }

    async function playBotTurn(botPlayer){
       if(isBotThinking) return;
       isBotThinking = true;
       
       
       await _supabase.from('giocatori').update({
         ultimo_ping: new Date().toISOString()
       }).eq('id', botPlayer.id);

       
       const thinkTime = 2000 + Math.random() * 2000;
       await new Promise(r => setTimeout(r, thinkTime));

       const s = currentStanza;
       const totalLetters = currentPuzzleText.replace(/[^A-ZÀ-Ù]/g, '').length;
       const revealedIndices = s.lettere_rivelate || [];
       
       // ✅ CORREZIONE: Conta solo le lettere DELLA FRASE CORRENTE (non di tutto il round)
       const phraseUpper = currentPuzzleText.toUpperCase();
       let revealedInCurrentPhrase = 0;
       let posInBoard = 0;
       
       for(let i = 0; i < phraseUpper.length; i++) {
         if(phraseUpper[i].match(/[A-ZÀ-Ù]/)) {
           if(revealedIndices.includes(posInBoard)) {
             revealedInCurrentPhrase++;
           }
           posInBoard++;
         }
       }
       
       const ratio = revealedInCurrentPhrase / totalLetters;
       
       // ✅ Vincolo minimo: deve essere rivelato almeno l'80% DELLA FRASE + minimo 5 lettere
       const minLettersNeeded = Math.max(5, Math.floor(totalLetters * 0.5));
       
       if(ratio >= 0.80 && revealedInCurrentPhrase >= minLettersNeeded && Math.random() > 0.3) {
          //⏱️ PAUSA DRAMMATICA: Il bot "pensa" prima di tentare la soluzione
          const thinkTimeBeforeSolve = 1500 + Math.random() * 1500; // 1.5-3 secondi
          await new Promise(r => setTimeout(r, thinkTimeBeforeSolve));
          
          if(Math.random() < 0.10) {
             await _supabase.from('stanze').update({ultima_azione: 'errore', ultimo_messaggio: `${botPlayer.nome} tenta ma sbaglia la soluzione!`, azione_timestamp: new Date().toISOString()}).eq('id', roomId);
             await passTurnBot();
             botFinishAction();
             return;
          }
          
          await _supabase.from('giocatori').update({punteggio_totale:(botPlayer.punteggio_totale||0)+(botPlayer.punteggio_round||0)+1000, punteggio_round:0}).eq('id', botPlayer.id);
          await _supabase.from('stanze').update({stato:'finito',ultima_azione:'vittoria',ultimo_messaggio:`${botPlayer.nome} HA RISOLTO LA FRASE!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
          botFinishAction();
          return;
       }

       
       if(Math.random() < 0.07 && lettersCalledThisRound.length > 3) {
          const errorChar = lettersCalledThisRound[Math.floor(Math.random()*lettersCalledThisRound.length)];
          await _supabase.from('stanze').update({ultima_azione: 'errore', ultimo_messaggio: `${botPlayer.nome} richiama la "${errorChar}" già provata!`, azione_timestamp: new Date().toISOString()}).eq('id', roomId);
          await passTurnBot();
          botFinishAction();
          return;
       }

       
       let chosenChar = null;
       let isVowel = false;
       const costVowel = getVowelCost();
       const botMoney = botPlayer.punteggio_round || 0;

       
       
       if(botMoney >= costVowel && ratio < 0.65 && Math.random() < 0.35 && vowelsBoughtThisTurn < 1) {
           // ⏱️ PAUSA REALISTICA: Il bot "pensa" prima di comprare la vocale
           const thinkTimeBeforeVowel = 1000 + Math.random() * 1000; // 1-2 secondi
           await new Promise(r => setTimeout(r, thinkTimeBeforeVowel));
           
           chosenChar = getNextVowelHuman(lettersCalledThisRound);
           if(chosenChar) isVowel = true;
       }

       if(s.montepremi_round === 0 && !isVowel) {
           
           let val = WHEEL_VALUES[Math.floor(Math.random()*WHEEL_VALUES.length)];
           
           
           
           
           // ✅ FIX COMPLETO: Gestione settori speciali corretta
           
           // MISTERO: il bot sceglie intelligentemente
           if(val === 'MISTERO') {
              let takeSafe = 0.5; // default 50%
              
              // ✅ LOGICA CORRETTA: 
              // Pochi soldi → rischia di più (non ha niente da perdere)
              // Tanti soldi → più conservativo (ha molto da perdere con bancarotta)
              if(botMoney < 500) {
                 takeSafe = 0.20; // 20% prende sicuro, 80% rischia (coraggioso!)
              } else if(botMoney > 1500) {
                 takeSafe = 0.75; // 75% prende sicuro, 25% rischia (conservativo)
              }
              
              if(Math.random() < takeSafe) {
                 // Prende 500€ sicuri
                 await _supabase.from('stanze').update({montepremi_round:500,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} gira MISTERO: prende 500€ sicuri!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
                 botFinishAction();
                 return;
              } else {
                 // Apre il mistero - pesca un valore random da MISTERO_VALUES
                 const MISTERO_VALUES_BOT = ['RADDOPPIA','BANCAROTTA','PASSA','+1000','JOLLY'];
                 val = MISTERO_VALUES_BOT[Math.floor(Math.random()*MISTERO_VALUES_BOT.length)];
                 // Continua sotto per processare il valore pescato
              }
           }
           
           // JOLLY: salvalo e gira ancora
           if(val === 'JOLLY') {
              const startR = s.round_giocati;
              const newEndR = Math.min(startR + 4, 10);
              await _supabase.from('giocatori').update({scadenza_jolly:newEndR}).eq('id', botPlayer.id);
              await _supabase.from('stanze').update({montepremi_round:0,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} pesca JOLLY! Attivo fino al round ${newEndR}`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
              botFinishAction();
              return;
           }
           
           // +1000: aggiungi 1000€ e gira ancora
           if(val === '+1000') {
              await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)+1000}).eq('id', botPlayer.id);
              await _supabase.from('stanze').update({montepremi_round:0,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} becca +1000€! Gira ancora!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
              botFinishAction();
              return;
           }
           
           // RADDOPPIA: attiva raddoppio e gira ancora
           if(val === 'RADDOPPIA') {
              await _supabase.from('stanze').update({montepremi_round:0,fase_speciale:2,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} trova RADDOPPIA! Gira ancora!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
              botFinishAction();
              return;
           }
           
           // BANCAROTTA: usa JOLLY se disponibile, altrimenti perde solo il round (NON il totale!)
           if(val === 'BANCAROTTA') {
               // ✅ Controlla se ha un JOLLY attivo
               const hasJolly = botPlayer.scadenza_jolly && botPlayer.scadenza_jolly >= s.round_giocati;
               
               if(hasJolly) {
                  // Usa il JOLLY per evitare la bancarotta
                  await _supabase.from('giocatori').update({scadenza_jolly:0}).eq('id', botPlayer.id);
                  await _supabase.from('stanze').update({montepremi_round:0,fase_speciale:0,ultima_azione:'jolly',ultimo_messaggio:`${botPlayer.nome} usa JOLLY per evitare BANCAROTTA!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
                  botFinishAction();
                  return;
               }
               
               // ✅ BANCAROTTA: azzera punteggio_round E punteggio_totale (perde tutto)!
               await _supabase.from('giocatori').update({punteggio_round:0, punteggio_totale:0}).eq('id', botPlayer.id);
               await _supabase.from('stanze').update({montepremi_round:0,fase_speciale:0,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} gira: BANCAROTTA! Perde tutto.`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
               await passTurnBot();
               botFinishAction();
               return;
           }

           // PASSA/PASSA_TURNO: usa JOLLY se disponibile
           if(val === 'PASSA' || val === 'PASSA_TURNO') {
               const hasJolly = botPlayer.scadenza_jolly && botPlayer.scadenza_jolly >= s.round_giocati;
               
               if(hasJolly) {
                  await _supabase.from('giocatori').update({scadenza_jolly:0}).eq('id', botPlayer.id);
                  await _supabase.from('stanze').update({montepremi_round:0,fase_speciale:0,ultima_azione:'jolly',ultimo_messaggio:`${botPlayer.nome} usa JOLLY per evitare PASSA TURNO!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
                  botFinishAction();
                  return;
               }
               
               await _supabase.from('stanze').update({montepremi_round:0,fase_speciale:0,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} gira: PASSA TURNO!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
               await passTurnBot();
               botFinishAction();
               return;
           }

           let prize = (typeof val === 'number') ? val : 0;
           
           
           if(prize >= 1000) {
               await new Promise(r => setTimeout(r, 800));
           }
           
           await _supabase.from('stanze').update({montepremi_round:prize,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} gira: ${val}€`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
           botFinishAction(); 
           return; 
       } else {
           
           if(!chosenChar) {
               // ⏱️ PAUSA REALISTICA: Il bot "pensa" prima di scegliere la consonante
               const thinkTimeBeforeChoice = 1000 + Math.random() * 1000; // 1-2 secondi
               await new Promise(r => setTimeout(r, thinkTimeBeforeChoice));
               
               chosenChar = getNextConsonantHuman(lettersCalledThisRound);
           }

           if(!chosenChar) chosenChar = "Z"; 

           // ✅ FIX: Aggiungi la lettera chiamata PRIMA di verificare se è presente
           // Altrimenti il bot richiamerà all'infinito lettere sbagliate!
           if(!lettersCalledThisRound.includes(chosenChar)) {
               lettersCalledThisRound.push(chosenChar);
           }

           
           let foundIndices = []; let gIdx = 0;
           const sol = currentPuzzleText.toUpperCase();
           const cleanChar = cleanStr(chosenChar);
           for(let i=0; i<sol.length; i++) {
               if(sol[i].match(/[A-ZÀ-Ù]/)) {
                   if(cleanStr(sol[i]) === cleanChar) foundIndices.push(gIdx);
                   gIdx++;
               }
           }
           const newFound = foundIndices.filter(idx => !s.lettere_rivelate.includes(idx));

           if(newFound.length > 0) {
               const newRev = [...s.lettere_rivelate, ...newFound];
               let gain = 0;
               if(isVowel) {
                   await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)-costVowel}).eq('id', botPlayer.id);
                   vowelsBoughtThisTurn++; // ✅ FIX: Incrementa contatore vocali
               } else {
                   // ✅ FIX: Calcola gain con moltiplicatore RADDOPPIA (fase_speciale=2)
                   const multiplier = (s.fase_speciale === 2) ? 2 : 1;
                   gain = (s.fase_speciale === 3) ? (s.montepremi_round||0) * multiplier : ((s.montepremi_round||0) * newFound.length * multiplier);
                   await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)+gain}).eq('id', botPlayer.id);
               }
               await _supabase.from('stanze').update({lettere_rivelate:newRev,montepremi_round:0,fase_speciale:0,ultima_azione:'chiama_lettera',ultimo_messaggio:`${botPlayer.nome}: Trovate ${newFound.length} "${chosenChar}"!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
           } else {
               if(isVowel) await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)-costVowel}).eq('id', botPlayer.id);
               vowelsBoughtThisTurn++; // ✅ FIX: Incrementa contatore vocali anche se non trovata
               await _supabase.from('stanze').update({ultima_azione:'errore',ultimo_messaggio:`${botPlayer.nome}: La "${chosenChar}" è assente.`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
               botFinishAction(); // Pausa prima di passare il turno
               await passTurnBot();
               return; 
           }
       }
       botFinishAction(); // Pausa prima della prossima azione
    }

    function isLetterAlreadyRevealedOnBoard(char, stanza) {
        let found = false; let gIdx = 0;
        const sol = currentPuzzleText.toUpperCase();
        for(let i=0; i<sol.length; i++){
            if(sol[i].match(/[A-ZÀ-Ù]/)){
                if(cleanStr(sol[i]) === cleanStr(char) && stanza.lettere_rivelate.includes(gIdx)) found = true;
                gIdx++;
            }
        }
        return found;
    }

    async function passTurnBot(){
      const s=currentStanza;
      if(!s || !s.giocatori || s.giocatori.length === 0) {
        return;
      }
      
      // ✅ UUID: Trova giocatore corrente per UUID
      let currIdx=s.giocatori.findIndex(p=>p.id===s.id_giocatore_corrente);
      
      
      if(currIdx === -1) {
        currIdx = 0;
      }
      
      let nextIdx = (currIdx + 1) % s.giocatori.length;
      let nextPlayerUUID = s.giocatori[nextIdx].id; // ← UUID invece di indice!
      
      // ✅ FIX ASYNC: await per evitare race conditions
      await _supabase.from('stanze').update({id_giocatore_corrente:nextPlayerUUID,montepremi_round:0,fase_speciale:0,ultima_azione:'timeout',ultimo_messaggio:'Cambio turno',azione_timestamp:new Date().toISOString()}).eq('id', roomId);
    }

    async function updateUI(s){
      if (!s || !s.giocatori) return;
      currentStanza=s;
      s.giocatori.sort((a,b)=>a.indice-b.indice);
      
      // ✅ SINCRONIZZA variabili round speciale con il database
      // Questo è critico perché solo l'host esegue i loop, ma TUTTI i client devono sapere lo stato
      if(s.fase_speciale === 100) {
        // Fase vocali
        isSpecialRound = true;
        specialVowelsPhase = true;
      } else if(s.fase_speciale === 101) {
        // Fase consonanti
        isSpecialRound = true;
        specialVowelsPhase = false;
      } else if(s.fase_speciale === 102) {
        // Tutti possono risolvere
        isSpecialRound = true;
        specialVowelsPhase = false;
      } else if(s.fase_speciale === 0 && isSpecialRound) {
        // Round speciale terminato
        isSpecialRound = false;
        specialVowelsPhase = true;
      }
      
      // ✅ Mostra/nascondi pulsante PASSA nella vista accessibile in base al round speciale
      const btnAccPassSpecial = document.getElementById('btn-acc-pass-special');
      if(btnAccPassSpecial) {
        btnAccPassSpecial.style.display = isSpecialRound ? 'flex' : 'none';
      }
      
      // ✅ Estrai specialPhraseIndex dal messaggio (formato: "Frase X/4")
      if(isSpecialRound) {
        const phraseMatch = (s.ultimo_messaggio || '').match(/Frase (\d+)\/4/);
        if(phraseMatch) {
          specialPhraseIndex = parseInt(phraseMatch[1]) - 1; // Converti da 1-based a 0-based
        }
      }
      
      // ✅ FIX CHATGPT: Usa is_host dal DB come fonte di verità (non indice 0)
      if(myId){
        const me = s.giocatori.find(p => p.id === myId);
        if(me){
          myIndex = me.indice;
          isHost = me.is_host; // ← Usa is_host dal database, non "indice 0"
        }
      }
      
      
      if(previousPlayersList.length > 0) {
        
        const currentIds = s.giocatori.map(p => p.id);
        const previousIds = previousPlayersList.map(p => p.id);
        
        // ✅ FIX CHATGPT: Annunci rimossi da qui (già gestiti in playersChannel)
        // Non più showFlashMessage/speak qui per evitare duplicati
        
        // Controlla solo se tutti sono usciti (caso speciale)
        if(s.giocatori.length < 1 && previousPlayersList.length > 0) {
          showFlashMessage('Tutti i giocatori sono usciti. La stanza rimane aperta.', 'info');
        }
      }
      
      
      previousPlayersList = s.giocatori.map(p => ({id: p.id, nome: p.nome}));
      
      // ✅ FIX CHATGPT: Failover host automatico se l'host esce
      if(s.giocatori.length > 0){
        const currentHost = s.giocatori.find(p => p.is_host);
        
        // Se nessuno è host, promuovi il primo giocatore
        if(!currentHost){
          const newHost = s.giocatori[0];
          
          await _supabase.from('giocatori').update({is_host: true}).eq('id', newHost.id);
          
          // Se ero io, aggiorno subito localmente
          if(newHost.id === myId){
            isHost = true;
            speak("Sei diventato l'host della stanza");
          }
          
          showFlashMessage(`${newHost.nome} è il nuovo host`, 'info');
        }
      }
      
      
      // ✅ UUID: Controlla se il giocatore corrente esiste ancora (per UUID)
      if(s.stato === 'gioco' && !s.in_pausa && isHost && s.id_giocatore_corrente !== null && s.id_giocatore_corrente !== undefined) {
        const currentPlayerExists = s.giocatori.some(p => p.id === s.id_giocatore_corrente);
        if(!currentPlayerExists) {
          showFlashMessage('Il giocatore corrente è uscito. Passaggio automatico del turno.', 'info');
          setTimeout(() => passTurn(), 1500); // ✅ Aumentato a 1.5 secondi
        }
      }

      document.getElementById('pause-panel').classList.toggle('hidden', !s.in_pausa);
      document.getElementById('game-panel').classList.toggle('hidden', s.in_pausa);
      if(s.in_pausa) return;

      if(s.stato==='terminata'){
        document.getElementById('game-panel').classList.add('hidden');
        document.getElementById('end-panel').classList.remove('hidden');
        const l=document.getElementById('ranking-list'); l.innerHTML="";
        [...s.giocatori].sort((a,b)=>b.punteggio_totale-a.punteggio_totale).forEach((p,i)=> l.innerHTML+=`<li>${i+1}. ${p.nome}: €${p.punteggio_totale}</li>`);
        
        
        document.getElementById('btn-new-game').classList.toggle('hidden', !isHost);
        
        return;
      }

      if(s.stato==='finito'){
        document.getElementById('round-over-panel').classList.remove('hidden');
        document.getElementById('round-winner-msg').textContent=s.ultimo_messaggio;
        document.getElementById('solution-msg').textContent=fullSolutionText;
        if(!nextRoundInterval){
          let sec=15;
          document.getElementById('next-round-timer').textContent=sec;
          nextRoundInterval=setInterval(()=>{
            sec--;
            document.getElementById('next-round-timer').textContent=sec;
            if(sec<=0){
              clearInterval(nextRoundInterval); nextRoundInterval=null;
              if(isHost) startNewRound();
            }
          },1000);
        }
        if(s.azione_timestamp !== lastTimestamp){
          lastTimestamp=s.azione_timestamp;
          playAudio('snd-win');
          speak(`Fine round. ${s.ultimo_messaggio}`);
        }
        return;
      } else {
        if(nextRoundInterval){ clearInterval(nextRoundInterval); nextRoundInterval=null; }
        document.getElementById('round-over-panel').classList.add('hidden');
      }

      if(!currentFrase || currentFrase.id !== s.frasi.id){
        currentFrase=s.frasi;
        fullSolutionText=currentFrase.soluzione;
        
        
        // ✅ PRIORITÀ 1: Usa il campo 'tema' se presente nel database
        if(currentFrase.tema){
          currentHintText = currentFrase.tema;
          currentPuzzleText = fullSolutionText;
        }
        // ✅ PRIORITÀ 2: Usa il campo 'hint' (per retrocompatibilità)
        else if(currentFrase.hint){
          currentHintText = currentFrase.hint;
          currentPuzzleText = fullSolutionText;
        }
        // ✅ PRIORITÀ 3: Split sul trattino (per frasi vecchie come CURIOSITÀ)
        else if(fullSolutionText.includes(" - ") || fullSolutionText.includes("–") || fullSolutionText.includes(" – ")){
          // Gestisci diversi formati di trattino
          let p;
          if(fullSolutionText.includes(" – ")){
            p = fullSolutionText.split(" – ");
          } else if(fullSolutionText.includes("–")){
            p = fullSolutionText.split("–");
          } else {
            p = fullSolutionText.split(" - ");
          }
          currentHintText=p[0].trim();
          currentPuzzleText=p[1].trim();
        } else {
          currentHintText="";
          currentPuzzleText=fullSolutionText;
        }
        
        // ✅ Mostra categoria + hint (se presente) in elementi separati ma dentro lo stesso H2
        // Così NVDA legge tutto quando naviga con H
        document.getElementById('category-main').textContent = currentFrase.categoria;
        document.getElementById('round-hint').textContent = currentHintText;
        vowelsBoughtThisTurn=0;
        parseAndRenderBoard(currentPuzzleText, s.lettere_rivelate, true); // ✅ Reset navigazione per nuova frase
        
//         const speakText = currentHintText 
//           ? `Nuovo Round. Categoria: ${currentFrase.categoria}. ${currentHintText}` 
//           : `Nuovo Round. Categoria: ${currentFrase.categoria}`;
//         speak(speakText);
      }

      document.getElementById('round-indicator').textContent = `R ${s.round_giocati}/10`;
      
      // ✅ Aggiorna sempre la categoria con hint (se presente) - persiste anche dopo cambio fase
      // Ma SOLO se è cambiata (per evitare troppi aggiornamenti DOM)
      if(currentFrase) {
        const categoryMain = document.getElementById('category-main');
        const roundHint = document.getElementById('round-hint');
        
        if(categoryMain && categoryMain.textContent !== currentFrase.categoria) {
          categoryMain.textContent = currentFrase.categoria;
        }
        
        if(roundHint && roundHint.textContent !== currentHintText) {
          roundHint.textContent = currentHintText;
        }
      }
      
      // ✅ UUID: Trova giocatore corrente per UUID (non per indice!)
      const currentPlayer = s.giocatori.find(p=>p.id===s.id_giocatore_corrente);
      const isMe=(s.id_giocatore_corrente===myId); // ← Confronta UUID con UUID!
      
      if(currentPlayer) {
      }
      
      const isBotTurn = isHost && currentPlayer && currentPlayer.nome.startsWith("BOT");
      
      if(isBotTurn){
          // Annuncia SOLO se il turno è appena cambiato al bot
          if(!wasBotTurn) {
            // Avvisa l'utente che c'è un bot (potrebbe essere non voluto)
            const botWarning = `Rilevato ${currentPlayer.nome}. Se non l'hai aggiunto tu, puoi eliminarlo dal pannello Giocatori (tasto S).`;
            showFlashMessage(botWarning, 'warning');
            speak(`Turno del bot: ${currentPlayer.nome}`);
          }
          
          playBotTurn(currentPlayer);
      } else {
      }

      if(!wasMyTurn && isMe){ 
        vowelsBoughtThisTurn=0; 
        lastSpinTimestamp = new Date().toISOString(); 
        
        // ✅ NON suonare il beep di cambio turno durante la fase consonanti del round speciale
        const isConsonantPhase = isSpecialRound && !specialVowelsPhase && s.fase_speciale === 101;
        if(!isConsonantPhase) {
          speak("Tocca a te."); 
          playAudio('snd-turn');
        } else {
          // ✅ Round speciale fase consonanti: solo "Tocca a te"
          speak("Tocca a te.");
        }
      }
      
      // ✅ FIX: Chiudi overlay di input quando il turno cambia e non è più il mio turno
      if(wasMyTurn && !isMe && inputMode){
        closeInput();
        speak("Turno cambiato durante l'inserimento");
      }
      
      wasMyTurn=isMe;
      wasBotTurn=isBotTurn;
      
      const who=currentPlayer?.nome;
      document.getElementById('turn-indicator').textContent=isMe ? "TOCCA A TE" : `Turno di ${who||'...'}`;
      document.getElementById('turn-indicator').style.color=isMe ? "var(--col-green)" : "#fff";

      const isRaddoppiaActive=(s.fase_speciale===2);
      const isMysteryFlat=(s.fase_speciale===3);
      document.getElementById('double-indicator').classList.toggle('hidden', !isRaddoppiaActive);

      const me=s.giocatori.find(p=>p.id===myId);
      const myRoundMoney=me ? (me.punteggio_round||0) : 0;
      const vCost=getVowelCost();
      const jInd=document.getElementById('jolly-indicator');
      if(hasActiveJolly(me, s)){
        jInd.textContent=`JOLLY ATTIVO (FINO A ROUND ${me.scadenza_jolly})`;
        jInd.classList.remove('hidden');
      } else jInd.classList.add('hidden');
      
      
      const specialInd=document.getElementById('special-round-indicator');
      if(isSpecialRound){
        if(specialVowelsPhase){
          specialInd.textContent=`ROUND SPECIALE - FASE VOCALI (${specialVowelsGiven}/3) - Frase ${specialPhraseIndex + 1}/4`;
        } else {
          // ✅ Estrai il numero di consonanti dal messaggio DB
          const match = (s.ultimo_messaggio || '').match(/\((\d+)\/10\)/);
          const consonantsCount = match ? parseInt(match[1]) : 0;
          specialInd.textContent=`ROUND SPECIALE - CONSONANTI (${consonantsCount}/10) - Frase ${specialPhraseIndex + 1}/4`;
        }
        specialInd.classList.remove('hidden');
      } else {
        specialInd.classList.add('hidden');
      }

      let canSpin=isMe && !isSpinning && !inputMode && s.montepremi_round===0 && !isProcessingInput;
      let canSolve=isMe && !isSpinning && !inputMode && !isProcessingInput; // ✅ Puoi sempre risolvere quando è il tuo turno
      let canPass=isMe && !isSpinning && !isProcessingInput;
      let canVowel=isMe && !isSpinning && !inputMode && !isProcessingInput;
      
      
      if(isSpecialRound){
        if(specialVowelsPhase){
          // FASE VOCALI
          canSpin = false;
          
          // ✅ FIX: Con 1 giocatore il sistema regala le vocali, non deve premere VOCALE
          const numPlayers = s.giocatori.length;
          if(numPlayers === 1) {
            canVowel = false; // Sistema le regala automaticamente
          } else {
            canVowel = isMe && !isSpinning && !inputMode;
          }
          
          canSolve = false; 
          canPass = false;
        } else {
          // Fase consonanti - Estrai contatore dal DB
          const match = (s.ultimo_messaggio || '').match(/\((\d+)\/10\)/);
          const consonantsCount = match ? parseInt(match[1]) : 0;
          
          canSpin = isMe && !isSpinning && !inputMode && s.montepremi_round===0 && consonantsCount < 10;
          canVowel = false; 
          // ✅ Durante il proprio turno si può SEMPRE risolvere, anche prima delle 10 consonanti
          canSolve = isMe && !isSpinning && !inputMode;
          canPass = false; 
          
          // Solo dopo 10 consonanti tutti possono risolvere (anche se non è il proprio turno)
          if(consonantsCount >= 10 || s.fase_speciale === 102){
            canSpin = false;
            canSolve = !isSpinning && !inputMode; // Tutti possono risolvere
          }
        }
      } else {
        
        if(myRoundMoney < vCost) canVowel=false;
        if(vowelsBoughtThisTurn>=1) canVowel=false;
        if(isRaddoppiaActive) canVowel=false;
      }
      
      // ✅ FIX: Raddoppia deve sovrascrivere TUTTO, anche in round speciale
      // Mettilo DOPO i controlli del round speciale così ha priorità
      if(isRaddoppiaActive && isMe) {
        canSpin = true; // Forza abilitazione anche se altri controlli dicono di no
      }

      setBtnState('btn-spin', !canSpin);
      setBtnState('btn-solve', !canSolve);
      setBtnState('btn-pass', !canPass);
      
      // ✅ PASSA ALL'AVVERSARIO: disabilitato nei round speciali e se sei da solo
      let canPassOpponent = canPass && s.giocatori.length > 1 && !isSpecialRound;
      setBtnState('btn-pass-opponent', !canPassOpponent);
      
      const btnV=document.getElementById('btn-vowel');
      setBtnState('btn-vowel', !canVowel);
      btnV.textContent=`VOCALE (€${vCost})`;

      let canManual=isMe && !isSpinning && !inputMode && s.montepremi_round>0;
      
      const btnSurrender = document.getElementById('btn-surrender');
      if(btnSurrender) {
        const showSurrender = isHost && isSpecialRound && s.fase_speciale === 102;
        btnSurrender.classList.toggle('hidden', !showSurrender);
      }
      
      // CORREZIONE: Salva il focus PRIMA di qualsiasi modifica al DOM
      const focusedElement = document.activeElement;
      const focusedId = focusedElement?.id;
      const focusedTag = focusedElement?.tagName;
      const wasInputModeNull = !inputMode; // Salva lo stato prima di openInput
      
      // ✅ APERTURA AUTOMATICA CAMPO CONSONANTE: 
      // Si apre SOLO se non c'è già un campo aperto (inputMode è null)
      // Se l'utente ha manualmente aperto vocale o risolvi, NON sovrascrivere
      // NON riapre se è ancora in fase di processing (evita riapertura dopo submit)
      const willOpenInput = canManual && wasInputModeNull && !isProcessingInput;
      if(willOpenInput) {
        openInput('letter');
      }

      // ✅ GUARD: Non re-render se l'utente sta scrivendo
      // IMPORTANTE: Usa inputMode invece di document.activeElement per evitare il paradosso:
      // - openInput() imposta inputMode PRIMA di fare focus (a T=0ms)
      // - Il focus arriva solo dopo 100ms
      // - Se usiamo activeElement, isTyping è FALSE durante quei 100ms
      // - Questo causa un re-render del DOM proprio mentre NVDA sta atterrando sul campo
      const inputArea_check = document.getElementById('input-area');
      const isTyping = inputArea_check && !inputArea_check.classList.contains('hidden') && inputMode !== null;
      
      if (!isTyping) {
        parseAndRenderBoard(currentPuzzleText, s.lettere_rivelate);
      }
      if(isAccessibleMode) updateAccessibleBoard();
      
      // ✅ FIX NVDA FOCUS: Il focus viene impostato SOLO quando il campo viene aperto per la prima volta
      // NON viene più forzato continuamente durante gli aggiornamenti
      // Questo evita che NVDA esca dalla modalità focus mentre l'utente sta scrivendo
      // Il focus viene gestito ESCLUSIVAMENTE in openInput(), non qui
      
      if(me){
        const roundScore = me.punteggio_round||0;
        const totalScore = me.punteggio_totale||0;
        document.getElementById('score-round').textContent=roundScore;
        document.getElementById('score-total').textContent=totalScore;
      } else {
        document.getElementById('score-round').textContent='?';
        document.getElementById('score-total').textContent='?';
      }
      let statusTxt="";
      if(s.montepremi_round>0) statusTxt = isMysteryFlat ? `IN PALIO: €${s.montepremi_round} (Piatto)` : `IN PALIO: €${s.montepremi_round}`;
      else if(isRaddoppiaActive) statusTxt="RADDOPPIA ATTIVO! GIRA!";
      document.getElementById('wheel-status-text').textContent=statusTxt;

      if(s.azione_timestamp !== lastTimestamp){
        lastTimestamp=s.azione_timestamp;
        addActionToHistory(s.ultimo_messaggio || s.ultima_azione || "Azione");
        if(s.ultima_azione==='errore') playAudio('snd-miss');
        else if(s.ultima_azione==='gira_ruota' && (s.ultimo_messaggio||"").includes("BANCAROTTA")) playAudio('snd-bankrupt');
        else if(s.ultima_azione==='chiama_lettera') {
            // ✅ FIX: Riproduci il suono SOLO se il timestamp è cambiato
            // Questo previene sovrapposizioni quando updateUI viene chiamato più volte
            const match = (s.ultimo_messaggio || "").match(/Trovate (\d+)/);
            const count = match ? parseInt(match[1]) : 0; // ✅ FIX: Default 0 invece di 1
            
            // ✅ Riproduci beep SOLO se count > 0
            if(count > 0 && count <= 20) {  // Sanity check: max 20 beep
              playMultipleHits(count);
            }
        }
        showFlashMessage(s.ultimo_messaggio, 'info');
        
        // ✅ Sempre fare speak di ultimo_messaggio
        speak(s.ultimo_messaggio);
      }
      
      
      const btnManagement = document.getElementById('btn-management');
      if(btnManagement) {
        btnManagement.textContent = isHost ? 'CONTROLLI E CLASSIFICA (S)' : 'CLASSIFICA (S)';
      }
    }

    function animateWheelSpin(){
      const wheel=document.getElementById('wheel-visual');
      wheelRotation += 720 + Math.floor(Math.random()*720);
      wheel.style.transform=`rotate(${wheelRotation}deg)`;
    }

    async function doSpin(){
      if(isBtnDisabled('btn-spin') || !currentStanza) return;
      
      // ✅ SICUREZZA CRITICA: Verifica che sia il TUO turno
      const s = currentStanza;
      const isMyTurn = (s.id_giocatore_corrente === myId);
      
      if(!isMyTurn) {
        speak("Non è il tuo turno!");
        playAudio('snd-miss');
        return;
      }
      
      isSpinning=true;
      
      speak("Giro la ruota...");
      playAudio('snd-spin');
      animateWheelSpin();
      await new Promise(r=>setTimeout(r,3000));
      let val=WHEEL_VALUES[Math.floor(Math.random()*WHEEL_VALUES.length)];
      
      const myName=document.getElementById('inp-name').value;
      
      const me=currentStanza.giocatori.find(p=>p.id===myId);
      
      const activeMultiplier=(currentStanza.fase_speciale===2) ? 2 : 1;
      let nextFaseSpeciale=0;
      let mysterySafeFlat=false;

      if(val==='MISTERO'){
        // ✅ Nel round speciale: MISTERO dà automaticamente 500€ (no scelta, no rischi)
        if(isSpecialRound && !specialVowelsPhase) {
          val = 500;
          mysterySafeFlat = true;
          speak("Mistero nel round speciale: 500 euro automatici!");
          await _supabase.from('stanze').update({
            ultimo_messaggio:`${myName} becca MISTERO - 500€ automatici nel round speciale`,
            azione_timestamp:new Date().toISOString()
          }).eq('id', roomId);
        } else {
          // Round normale: chiedi scelta
          const openIt = await askMysteryChoice(); 
          if(!openIt){
            val = 500;
            mysterySafeFlat = true;
            speak("Hai scelto 500 euro sicuri");
          } else {
            val = MISTERO_VALUES[Math.floor(Math.random()*MISTERO_VALUES.length)];
            
            
            let mysteryResultText = "";
            if(val === 'BANCAROTTA') mysteryResultText = "BANCAROTTA!";
            else if(val === 'RADDOPPIA') mysteryResultText = "RADDOPPIA!";
            else if(val === '+1000') mysteryResultText = "+1000 EURO!";
            else if(val === 'JOLLY') mysteryResultText = "JOLLY!";
            else if(val === 'PASSA' || val === 'PASSA_TURNO') mysteryResultText = "PASSA TURNO";
            else if(val === 'PASSA_AVVERSARIO') mysteryResultText = "PASSA ALL'AVVERSARIO";
            else mysteryResultText = `${val}`;
            
            speak(`Mistero svelato: ${mysteryResultText}`);
          }
        }
      }

      if(val==='BANCAROTTA'){
        isSpinning=false;
        
        
        const saved=await tryUseJollyToAvoid("BANCAROTTA");
        if(saved) return;
        
        
        // ✅ Nel round speciale, BANCAROTTA rigira automaticamente - devi prendere soldi per chiamare!
        if(isSpecialRound && !specialVowelsPhase){
          await _supabase.from('stanze').update({
            ultimo_messaggio:`${myName} becca BANCAROTTA! Nel round speciale RIGIRA AUTOMATICAMENTE! (${specialConsonantsUsed}/10 consonanti)`,
            azione_timestamp:new Date().toISOString()
          }).eq('id', roomId);
          
          speak("BANCAROTTA nel round speciale! Rigiri automaticamente!");
          showFlashMessage('RIGIRA AUTOMATICAMENTE!', 'bad');
          
          // Rigira automaticamente dopo 2 secondi
          setTimeout(() => {
            doSpin();
          }, 2000);
          return;
        }
        
        // Round normale: perde tutto e passa turno
        await _supabase.from('giocatori').update({punteggio_round:0, punteggio_totale:0}).eq('id', myId);
        await _supabase.from('stanze').update({
          fase_speciale:0,
          ultima_azione:'gira_ruota',
          ultimo_messaggio:`${myName} becca BANCAROTTA! Perde tutto!`,
          azione_timestamp:new Date().toISOString()
        }).eq('id', roomId);
        
        addActionToHistory(`${myName} BANCAROTTA! Perde tutto`);
        speak("BANCAROTTA! Hai perso tutto e passi il turno!");
        showFlashMessage('BANCAROTTA!', 'bad');
        
        passTurn();
        return;
      }

      if(val==='PASSA' || val==='PASSA_TURNO' || val==='PASSA_AVVERSARIO'){
        isSpinning=false;
        const label=(val==='PASSA_AVVERSARIO') ? "PASSA ALL'AVVERSARIO" : "PASSA TURNO";
        const saved=await tryUseJollyToAvoid(label);
        if(saved) return;
        
        // ✅ Nel round speciale, PASSA non esiste - rigira automaticamente!
        if(isSpecialRound && !specialVowelsPhase) {
          await _supabase.from('stanze').update({
            ultimo_messaggio:`${myName} becca ${label}! Nel round speciale RIGIRA AUTOMATICAMENTE! (${specialConsonantsUsed}/10 consonanti)`,
            azione_timestamp:new Date().toISOString()
          }).eq('id', roomId);
          
          speak("PASSA nel round speciale! Rigiri automaticamente!");
          showFlashMessage('RIGIRA AUTOMATICAMENTE!', 'bad');
          
          // Rigira automaticamente dopo 2 secondi
          setTimeout(() => {
            doSpin();
          }, 2000);
          return;
        }
        
        // Round normale: azzera fase_speciale e passa turno
        await _supabase.from('stanze').update({
          fase_speciale:0,
          ultima_azione:'gira_ruota',
          ultimo_messaggio:`${myName} becca ${label}!`,
          azione_timestamp:new Date().toISOString()
        }).eq('id', roomId);
        
        addActionToHistory(`${myName} ${label}`);
        speak(`${label}! Passi il turno.`);
        showFlashMessage(`${label}`, 'bad');
        
        passTurn();
        return;
      }

      let finalPrize=0;
      let msg=`${myName} gira: ${val}`;
      
      if(typeof val==='number'){
        if(mysterySafeFlat){
          finalPrize = val;
          msg = `${myName} prende ${val}€ (piatto)!`;
          nextFaseSpeciale = 3;
        } else {
          finalPrize = val * activeMultiplier;
          if(activeMultiplier>1) {
            msg = `${myName} gira ${val} x 2 = ${finalPrize}!`;
          }
          nextFaseSpeciale = 0;
        }
      } else if(val==='+1000'){
        await _supabase.from('giocatori').update({punteggio_round:(me.punteggio_round||0)+1000}).eq('id', myId);
        finalPrize=0;
        msg=`${myName} becca +1000€! Gira ancora!`;
        nextFaseSpeciale=0;
      } else if(val==='RADDOPPIA'){
        finalPrize=0;
        msg=`${myName} trova RADDOPPIA! Gira ancora!`;
        nextFaseSpeciale=2;
      } else if(val==='JOLLY'){
        const startR=currentStanza.round_giocati;
        
        // ✅ FIX: Il Jolly dura 5 round completi dal round SUCCESSIVO
        // Esempio: Se sei al round 4, dura fino al round 8 (round 5, 6, 7, 8 = 4 round di protezione)
        // Ma il messaggio deve dire "fino al round 8" (5 round totali: 4, 5, 6, 7, 8)
        const idealEndR = startR + 4; // Esempio: round 4 + 4 = 8
        const newEndR = Math.min(idealEndR, 10); // Cap a round 10
        
        const currentJollyEnd = me && me.scadenza_jolly ? me.scadenza_jolly : 0;
        
        // Se hai già un Jolly attivo, NON estendere ma avvisare
        if(currentJollyEnd >= startR) {
          msg=`${myName} pesca un altro JOLLY! Hai già un Jolly attivo (fino al round ${currentJollyEnd})`;
          // Non aggiornare la scadenza, mantieni quella esistente
        } else {
          // Nuovo Jolly
          await _supabase.from('giocatori').update({scadenza_jolly:newEndR}).eq('id', myId);
          const roundsProtected = newEndR - startR; // Calcola quanti round di protezione
          if(newEndR === 10 && idealEndR > 10) {
            msg=`${myName} pesca il JOLLY! Attivo fino alla fine della partita (round ${newEndR})`;
          } else {
            msg=`${myName} pesca il JOLLY! Protegge per ${roundsProtected + 1} round (fino al round ${newEndR})`;
          }
        }
        
        finalPrize=0;
        nextFaseSpeciale=0;
      }

      isSpinning=false;
      lastSpinTimestamp = new Date().toISOString();
      
      const updateResult = await _supabase.from('stanze').update({
        montepremi_round:finalPrize,
        fase_speciale:nextFaseSpeciale,
        ultima_azione:'gira_ruota',
        ultimo_messaggio:msg,
        azione_timestamp:new Date().toISOString()
      }).eq('id', roomId);
      
      if(updateResult.error) {
        alert('ERRORE: ' + updateResult.error.message);
        return;
      }
      
      addActionToHistory(msg);
      
      // ✅ FIX NVDA: NON gestire il focus qui - viene già gestito da openInput()
      // Rimuovere questo blocco elimina il conflitto tra doSpin e updateUI
      // che causava doppi comandi di focus e faceva uscire NVDA dalla modalità focus
      
      await fetchFullState();
      
      
      if(finalPrize > 0 && !mysterySafeFlat) {
        
        
        
        if(currentStanza) {
          currentStanza.montepremi_round = finalPrize;
          currentStanza.fase_speciale = nextFaseSpeciale;
          currentStanza.ultima_azione = 'gira_ruota';
          currentStanza.ultimo_messaggio = msg;
        }
        
        // openInput('letter') viene chiamato automaticamente da updateUI quando montepremi_round > 0
      } else {
        // ✅ CORREZIONE: Aggiorna manualmente currentStanza per sincronizzazione immediata
        if(currentStanza) {
          currentStanza.montepremi_round = finalPrize;
          currentStanza.fase_speciale = nextFaseSpeciale;
          currentStanza.ultima_azione = 'gira_ruota';
          currentStanza.ultimo_messaggio = msg;
        }
        
        if(val === 'JOLLY') {
          // ✅ FIX: Usa la scadenza dal database (potrebbe essere invariata se già attivo)
          const me = currentStanza.giocatori.find(p => p.id === myId);
          const endR = me?.scadenza_jolly || (currentStanza.round_giocati + 4);
          speak(`Hai pescato il JOLLY! Protegge da bancarotta e passa turno fino al round ${endR}. Ora gira di nuovo!`);
          showFlashMessage(`JOLLY ATTIVO! (fino a round ${endR})`, 'good');
        } else if(val === '+1000') {
          speak(`Hai guadagnato mille euro! Ora gira di nuovo!`);
          showFlashMessage(`+1000 EURO GUADAGNATI!`, 'good');
        } else if(val === 'RADDOPPIA') {
          speak(`Raddoppia attivo! Il prossimo giro vale il doppio. Gira ora!`);
          showFlashMessage(`RADDOPPIA ATTIVO!`, 'good');
        }
      }
    }

    async function passTurn(){
      // ✅ BLOCCO NEI ROUND SPECIALI: Non si può passare il turno volontariamente
      if(isSpecialRound) {
        speak("Non puoi passare il turno nel round speciale");
        playAudio('snd-miss');
        return;
      }
      
      // ✅ CORREZIONE CHATGPT: Protezione - solo host o giocatore di turno possono passare
      if(!isHost && !isMe){
        speak("Non puoi passare il turno");
        return;
      }
      
      if(isHandlingTimeout) {
        return;
      }
      
      isHandlingTimeout=true;
      vowelsBoughtThisTurn=0;
      const s=currentStanza;
      
      if(!s || !s.giocatori || s.giocatori.length === 0) {
        isHandlingTimeout=false;
        return;
      }
      
      // ✅ UUID: Trova giocatore corrente per UUID (non per indice!)
      let currIdx=s.giocatori.findIndex(p=>p.id===s.id_giocatore_corrente);
      
      // Se non trovato (UUID non esiste più), torna al primo
      if(currIdx === -1) {
        currIdx = 0;
      }
      
      // Passa al prossimo giocatore
      let nextIdx = (currIdx + 1) % s.giocatori.length;
      let nextPlayerUUID = s.giocatori[nextIdx].id; // ← UUID invece di indice!
      
      
      const {error} = await _supabase.from('stanze').update({
        id_giocatore_corrente:nextPlayerUUID, // ← UUID invece di indice!
        montepremi_round:0,
        fase_speciale:0,
        ultima_azione:'passa_turno',
        ultimo_messaggio:'Cambio turno',
        azione_timestamp:new Date().toISOString()
      }).eq('id', roomId);
      
      if(error){
      } else {
      }
      
      isHandlingTimeout=false;
      
      // Forza refresh
      await fetchFullState();
    }
    
    async function passToOpponent(){
      // ✅ BLOCCO NEI ROUND SPECIALI: Non si può passare all'avversario
      if(isSpecialRound) {
        speak("Non puoi passare all'avversario nel round speciale");
        playAudio('snd-miss');
        return;
      }
      
      // ✅ Solo il giocatore di turno o l'host possono passare
      if(!isHost && !isMe){
        speak("Non puoi passare all'avversario");
        return;
      }
      
      const s=currentStanza;
      if(!s || !s.giocatori || s.giocatori.length === 0) return;
      
      // ✅ Se 1 giocatore: non puoi passare
      if(s.giocatori.length === 1) {
        speak("Non puoi passare all'avversario se sei da solo");
        playAudio('snd-miss');
        return;
      }
      
      // ✅ Se 2 giocatori: passa automaticamente all'altro
      if(s.giocatori.length === 2) {
        let currIdx=s.giocatori.findIndex(p=>p.id===s.id_giocatore_corrente);
        if(currIdx === -1) currIdx = 0;
        let nextIdx = (currIdx + 1) % 2;
        let nextPlayerUUID = s.giocatori[nextIdx].id;
        
        await _supabase.from('stanze').update({
          id_giocatore_corrente:nextPlayerUUID,
          montepremi_round:0,
          fase_speciale:0,
          ultima_azione:'passa_avversario',
          ultimo_messaggio:`Turno passato a ${s.giocatori[nextIdx].nome}`,
          azione_timestamp:new Date().toISOString()
        }).eq('id', roomId);
        
        speak(`Hai passato il turno a ${s.giocatori[nextIdx].nome}`);
        await fetchFullState();
        return;
      }
      
      // ✅ Se 3+ giocatori: chiedi a chi passare
      const currIdx=s.giocatori.findIndex(p=>p.id===s.id_giocatore_corrente);
      const opponents = s.giocatori.filter((p, idx) => idx !== currIdx);
      
      // Mostra dialog per scegliere
      const choiceHTML = opponents.map((p, idx) => 
        `<button onclick="confirmPassTo('${p.id}')" style="display:block; width:100%; padding:15px; margin:5px 0; background:#333; color:#fff; border:2px solid #555; border-radius:8px; font-size:1.2em; cursor:pointer;">${p.nome}</button>`
      ).join('');
      
      const overlay = document.createElement('div');
      overlay.id = 'pass-choice-overlay';
      overlay.style = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:9999; display:flex; align-items:center; justify-content:center;';
      overlay.innerHTML = `
        <div style="background:#222; border:3px solid var(--col-neon); padding:30px; border-radius:15px; max-width:400px; width:90%;">
          <h2 style="color:var(--col-neon); margin-top:0;">Passa il turno a...</h2>
          ${choiceHTML}
          <button onclick="document.getElementById('pass-choice-overlay').remove()" style="display:block; width:100%; padding:10px; margin-top:15px; background:#555; color:#aaa; border:1px solid #666; border-radius:8px; cursor:pointer;">ANNULLA</button>
        </div>
      `;
      document.body.appendChild(overlay);
      speak("Scegli a chi passare il turno");
    }
    
    async function confirmPassTo(targetPlayerUUID) {
      const s=currentStanza;
      const targetPlayer = s.giocatori.find(p => p.id === targetPlayerUUID);
      
      document.getElementById('pass-choice-overlay')?.remove();
      
      // ✅ Verifica che il giocatore esista ancora
      if(!targetPlayer) {
        speak("Errore: giocatore non trovato");
        playAudio('snd-miss');
        return;
      }
      
      await _supabase.from('stanze').update({
        id_giocatore_corrente:targetPlayerUUID,
        montepremi_round:0,
        fase_speciale:0,
        ultima_azione:'passa_avversario',
        ultimo_messaggio:`Turno passato a ${targetPlayer.nome}`,
        azione_timestamp:new Date().toISOString()
      }).eq('id', roomId);
      
      speak(`Hai passato il turno a ${targetPlayer.nome}`);
      await fetchFullState();
    }

    // ✅ ACCESSIBILITÀ: Variabile per salvare l'elemento che ha aperto l'input
    let lastFocusedElement = null;
    
    function openInput(mode){
      // ✅ NUOVO: In Vista Testo, usa overlay speciale per le consonanti
      if(isAccessibleMode && mode === 'letter'){
        const montepremi = currentStanza?.montepremi_round || 0;
        openAccessibleLetterInput(montepremi);
        inputMode = 'letter'; // Mantieni il flag per compatibilità
        return;
      }
      
      // ✅ SICUREZZA: Per 'solve', verifica che sia il TUO turno (o che sia la fase 102 del round speciale)
      if(mode === 'solve' && currentStanza) {
        const isMyTurn = (currentStanza.id_giocatore_corrente === myId);
        const canEveryoneSolve = (currentStanza.fase_speciale === 102); // Round speciale, 10 consonanti usate
        
        if(!isMyTurn && !canEveryoneSolve) {
          speak("Non è il tuo turno!");
          playAudio('snd-miss');
          return;
        }
      }
      
      // ✅ PROBLEMA 2: Controllo della "porta aperta"
      // Se il campo è già aperto, NON fare NULLA
      // Questo evita di re-forzare il focus mentre l'utente sta scrivendo
      const inputArea = document.getElementById('input-area');
      const isAlreadyOpen = inputArea && !inputArea.classList.contains('hidden');
      
      if(isAlreadyOpen && inputMode) {
        // Il campo è già aperto - NON toccare nulla
        // L'utente sta già scrivendo, non disturbare
        return;
      }
      
      // ✅ Il campo è chiuso - possiamo aprirlo
      // ✅ ACCESSIBILITÀ: Salva l'elemento attualmente focalizzato
      lastFocusedElement = document.activeElement;
      
      inputMode=mode;
      lastInputMode=mode; 
      inputArea.classList.remove('hidden');
      
      // ✅ NVDA FIX: NON usare role="dialog" e aria-modal="true"!
      // Questi attributi forzano NVDA in Browse Mode (modalità navigazione)
      // invece di permettere l'ingresso automatico in Focus Mode
      // Il campo di input è semplicemente un overlay, non un dialog da esplorare
      
      const inp=document.getElementById('game-input');
      
      
      inp.onkeydown = (e) => {
        if(e.key === 'Enter') {
          e.preventDefault();
          submitInput();
        }
      };
      
      if(mode==='solve') {
        
        let template = "";
        for(let i=0; i<currentPuzzleText.length; i++){
          const char = currentPuzzleText[i].toUpperCase();
          if(!char.match(/[A-ZÀ-Ù]/)){
            template += char; 
          } else {
            
            let gIdx = 0;
            for(let j=0; j<=i; j++){
              if(currentPuzzleText[j].match(/[A-ZÀ-Ù]/)){
                if(j === i) break;
                gIdx++;
              }
            }
            
            const isRevealed = currentStanza?.lettere_rivelate?.includes(gIdx);
            template += isRevealed ? char : '*';
          }
        }
        inp.value = template;
        
        // ✅ NVDA FIX: NON sostituire l'elemento (replaceChild rompe NVDA)
        // Invece, rimuovi i vecchi listener duplicando solo i listener necessari
        // L'elemento rimane lo stesso, NVDA mantiene il riferimento
        
        // Rimuovi vecchi listener onkeydown se esistono
        inp.onkeydown = null;
        
        // ✅ ACCESSIBILITÀ: Aggiungi label e descrizione per screen reader
        inp.setAttribute('aria-label', 'Campo per risolvere la frase. Completa gli asterischi con le lettere mancanti.');
        // ✅ MOBILE: Ottimizza tastiera per testo completo
        inp.setAttribute('inputmode', 'text');
        
        // ✅ FIX MEMORY LEAK: Rimuovi vecchio listener prima di aggiungerne uno nuovo
        // Usa la funzione globale uppercaseInputHandler
        inp.removeEventListener('input', uppercaseInputHandler);
        inp.addEventListener('input', uppercaseInputHandler);
        
        // Re-aggiungi listener per Enter
        inp.onkeydown = (e) => {
          if(e.key === 'Enter') {
            e.preventDefault();
            submitInput();
          }
        };
        
        // ✅ NVDA FIX: speak() viene chiamato DOPO il setTimeout del focus
        // Vedi più in basso (dopo il setTimeout)
      } else {
        inp.value='';
        // ✅ ACCESSIBILITÀ: Label appropriata per ogni modalità
        if(mode==='vowel') {
          inp.setAttribute('aria-label', 'Campo per inserire una vocale');
          // ✅ MOBILE: Ottimizza tastiera per lettere
          inp.setAttribute('inputmode', 'text');
          // ✅ NVDA FIX: speak() viene chiamato DOPO il setTimeout del focus
          // Vedi più in basso (dopo il setTimeout)
        } else {
          const montepremi = currentStanza?.montepremi_round || 0;
          inp.setAttribute('aria-label', `Campo per inserire una consonante. Hai girato ${montepremi} euro.`);
          // ✅ MOBILE: Ottimizza tastiera per lettere
          inp.setAttribute('inputmode', 'text');
          // ✅ NVDA FIX: speak() viene chiamato DOPO il setTimeout del focus
          // Vedi più in basso (dopo il setTimeout)
        }
      }
      
      // Nascondi/mostra bottone ANNULLA in base al mode
      const btnCancel = document.getElementById('btn-cancel-input');
      if(btnCancel){
        if(mode === 'letter'){
          // Consonante: nascondi ANNULLA
          btnCancel.style.display = 'none';
        } else {
          // Vocale/Risolvi: mostra ANNULLA
          btnCancel.style.display = 'flex';
        }
      }
      
      // ✅ FIX NVDA: Focus viene impostato UNA SOLA VOLTA quando il campo viene aperto
      // NON verrà più forzato continuamente da updateUI
      // Usa setTimeout per dare tempo al DOM di aggiornarsi
      setTimeout(() => {
        const gameInput = document.getElementById('game-input');
        if(gameInput) {
          // ✅ SMARTPHONE FIX: Attiva la tastiera virtuale automaticamente
          // Su mobile, il semplice focus() non basta - serve anche click()
          gameInput.focus();
          
          // Forza l'apertura della tastiera virtuale su smartphone
          // Il click() simula l'interazione utente necessaria per aprire la tastiera
          gameInput.click();
          
          // ✅ NVDA FIX: speak() viene chiamato DOPO il focus, così NVDA è già in focus mode
          // e l'annuncio non interferisce con l'ingresso nella modalità focus
          // CRITICO: Delay di 500ms per dare a NVDA tempo SUFFICIENTE di stabilizzarsi
          // Con 150ms era troppo veloce e NVDA veniva interrotto durante l'ingresso in Focus Mode
          setTimeout(() => {
            if(mode === 'solve') {
              speak("Risolvi. Completa gli asterischi con le lettere mancanti.");
            } else if(mode === 'vowel') {
              // ✅ Nel round speciale: annuncio semplice senza conteggio
              speak("Scrivi la vocale.");
            } else {
              const montepremi = currentStanza?.montepremi_round || 0;
              speak(`Hai girato ${montepremi} euro. Scrivi una consonante.`);
            }
          }, 500); // ✅ Aumentato da 150ms a 500ms - critico per NVDA!
        }
      }, 100); // Timeout breve per permettere al DOM di aggiornarsi
    }
    
    function tryCancelInput(){
      // Se è una consonante (letter mode), NON permettere l'annullamento
      if(inputMode === 'letter'){
        playAudio('snd-miss');
        speak("Non puoi annullare la consonante! Devi inserirla.");
        alert("Non puoi annullare!\n\nDevi inserire una consonante dopo aver girato la ruota.");
        return;
      }
      
      // Altrimenti chiudi normalmente (vocale, risolvi)
      closeInput();
    }
    
    function closeInput(){ 
      const inp = document.getElementById('game-input');
      
      // ✅ NVDA FIX: NON clonare e sostituire l'elemento (rompe NVDA)
      // Invece, pulisci solo il valore e i listener
      // L'elemento rimane lo stesso, NVDA mantiene il riferimento
      
      if(inputMode !== 'letter') {
        // Per vocale/risolvi, svuota il campo
        inp.value = '';
      }
      // Per consonanti, mantieni il valore (già gestito)
      
      // Rimuovi listener per evitare duplicazioni
      inp.onkeydown = null;
      inp.oninput = null;
      // ✅ FIX MEMORY LEAK: Rimuovi anche il listener addEventListener
      inp.removeEventListener('input', uppercaseInputHandler);
      
      document.getElementById('input-area').classList.add('hidden'); 
      
      // ✅ NUOVO: Chiudi anche l'overlay accessibile se aperto
      const accessibleOverlay = document.getElementById('accessible-letter-input');
      if(accessibleOverlay && !accessibleOverlay.classList.contains('hidden')){
        accessibleOverlay.classList.add('hidden');
        const accessibleInput = document.getElementById('accessible-game-input');
        if(accessibleInput){
          accessibleInput.value = '';
          accessibleInput.onkeydown = null;
        }
      }
      
      inputMode=null;
      
      // In vista testo, ritorna focus su GIRA
      if(isAccessibleMode){
        setTimeout(()=> document.getElementById('btn-acc-spin')?.focus(), 100);
      }
    }

    // ✅ NUOVO: Overlay speciale per input consonante in Vista Testo
    function openAccessibleLetterInput(montepremi){
      const overlay = document.getElementById('accessible-letter-input');
      const input = document.getElementById('accessible-game-input');
      const infoText = document.getElementById('accessible-input-info');
      
      // Aggiorna info con i soldi girati
      infoText.textContent = `Hai girato ${montepremi} €`;
      
      // Pulisci il campo
      input.value = '';
      
      // Mostra overlay
      overlay.classList.remove('hidden');
      
      // Listener per Enter
      input.onkeydown = (e) => {
        if(e.key === 'Enter') {
          e.preventDefault();
          submitAccessibleLetterInput();
        }
      };
      
      // ✅ FOCUS AUTOMATICO: Il campo è subito pronto per scrivere
      setTimeout(() => {
        input.focus();
        input.click(); // Per aprire tastiera su mobile
        
        // Annuncio vocale DOPO il focus
        setTimeout(() => {
          speak(`Hai girato ${montepremi} euro. Scrivi una consonante.`);
        }, 500);
      }, 100);
    }

    function closeAccessibleLetterInput(){
      const overlay = document.getElementById('accessible-letter-input');
      const input = document.getElementById('accessible-game-input');
      
      // Nascondi overlay
      overlay.classList.add('hidden');
      
      // Pulisci
      input.value = '';
      input.onkeydown = null;
      
      // Ritorna focus su GIRA
      setTimeout(()=> document.getElementById('btn-acc-spin')?.focus(), 100);
    }

    async function submitAccessibleLetterInput(){
      const input = document.getElementById('accessible-game-input');
      const letter = input.value.trim().toUpperCase();
      
      if(!letter || letter.length !== 1){
        speak("Inserisci una sola lettera!");
        playAudio('snd-miss');
        return;
      }
      
      // Verifica che sia una consonante
      const isVowel = "AEIOU".includes(letter);
      if(isVowel){
        speak("Devi inserire una consonante, non una vocale!");
        playAudio('snd-miss');
        input.value = '';
        setTimeout(() => input.focus(), 100);
        return;
      }
      
      // Usa la logica di submitInput per le consonanti
      // Impostiamo temporaneamente inputMode per far funzionare submitInput
      const oldInputMode = inputMode;
      inputMode = 'letter';
      
      // Copia la lettera nel campo normale (per compatibilità con submitInput)
      document.getElementById('game-input').value = letter;
      
      // Chiama submitInput - se ha successo, closeInput chiuderà tutto
      await submitInput();
      
      // Ripristina
      inputMode = oldInputMode;
    }

    function showAccessibleRevealedLetters(){
      // Chiama la funzione esistente per leggere le lettere
      readRevealedLetters();
    }

    async function submitInput(){
      if(isProcessingInput) return;
      
      // ✅ FIX: Verifica che sia ancora il tuo turno prima di processare
      const s = currentStanza;
      const isMe = (s?.id_giocatore_corrente === myId);
      if(!isMe){
        playAudio('snd-miss');
        alert("Non è più il tuo turno!");
        speak("Errore: non è più il tuo turno");
        closeInput();
        return;
      }
      
      isProcessingInput=true;
      const txt=document.getElementById('game-input').value.trim().toUpperCase();
      if(!txt){ isProcessingInput=false; return; }
      const mode=inputMode;
      
      // ✅ FIX: Valida l'input PRIMA di chiudere il campo!
      // Se c'è un errore, lascia il campo aperto per riscrivere
      
      // Validazione per vocali/consonanti
      if(mode === 'vowel' || mode === 'letter') {
        const char = txt.charAt(0);
        const isVowel = "AEIOU".includes(char);
        
        // Controllo vocale al posto di consonante
        if(mode === 'letter' && isVowel) {
          playAudio('snd-miss');
          alert("Devi inserire una CONSONANTE, non una vocale!");
          speak("Errore: hai inserito una vocale invece di una consonante. Riprova.");
          document.getElementById('game-input').value = '';
          document.getElementById('game-input').focus();
          isProcessingInput = false;
          return; // NON chiude il campo, NON passa il turno
        }
        
        // Controllo consonante al posto di vocale
        if(mode === 'vowel' && !isVowel) {
          playAudio('snd-miss');
          alert("Devi inserire una VOCALE, non una consonante!");
          speak("Errore: hai inserito una consonante invece di una vocale. Riprova.");
          document.getElementById('game-input').value = '';
          document.getElementById('game-input').focus();
          isProcessingInput = false;
          return; // NON chiude il campo, NON passa il turno
        }
      }
      
      // ✅ Validazione OK - ora possiamo chiudere il campo
      closeInput();
      const myName=document.getElementById('inp-name').value;
      // Usiamo 's' già dichiarato all'inizio della funzione
      
      
      if(isSpecialRound && specialVowelsPhase && mode==='vowel'){
        const char=txt.charAt(0);
        // ✅ Il controllo che sia una vocale è già fatto all'inizio di submitInput
        
        // Controlla se già chiamata
        if(lettersCalledThisRound.includes(char)){
          playAudio('snd-miss');
          alert(`La vocale ${char} è già stata chiamata! Scegli un'altra vocale.`);
          speak(`Errore: la vocale ${char} è già stata chiamata. Scegline un'altra.`);
          // Riapri il campo per riscrivere
          openInput('vowel');
          isProcessingInput=false;
          return;
        }
        
        // ✅ NUOVO SISTEMA: La vocale viene gestita direttamente qui
        // Aggiorna il database con la vocale scelta
        let foundIndices=[]; let gIdx=0;
        const sol=currentPuzzleText.toUpperCase();
        for(let i=0;i<sol.length;i++){
          if(sol[i].match(/[A-ZÀ-Ù]/)){
            if(cleanStr(sol[i])===cleanStr(char)) foundIndices.push(gIdx);
            gIdx++;
          }
        }
        
        if(foundIndices.length > 0){
          const newRev=[...new Set([...(s.lettere_rivelate||[]), ...foundIndices])];
          await _supabase.from('stanze').update({
            lettere_rivelate:newRev,
            ultimo_messaggio:`${myName} chiama vocale: ${char} - Trovate ${foundIndices.length}`,
            azione_timestamp:new Date().toISOString()
          }).eq('id', roomId);
          
          // ✅ Suona per ogni occorrenza (400ms tra i suoni)
          for(let i = 0; i < foundIndices.length; i++) {
            playRandomCorrectSound();
            await new Promise(resolve => setTimeout(resolve, 400));
          }
        } else {
          await _supabase.from('stanze').update({
            ultimo_messaggio:`${myName} chiama vocale: ${char} (assente)`,
            azione_timestamp:new Date().toISOString()
          }).eq('id', roomId);
          playIncorrectSound();
        }
        
        // Aggiorna il contatore - waitForPlayerVowel lo rileverà
        if(!lettersCalledThisRound.includes(char)) {
          lettersCalledThisRound.push(char);
        }
        
        isProcessingInput=false;
        
        // ✅ Riapri automaticamente il campo per la prossima vocale se la fase vocali è ancora attiva
        setTimeout(() => {
          if(isSpecialRound && specialVowelsPhase){
            openInput('vowel');
          }
        }, 500);
        
        return;
      }

      if(mode==='solve'){
        // ✅ FIX RACE CONDITION: Verifica stato fresco prima di risolvere
        const { data: freshState, error: fetchError } = await _supabase
          .from('stanze')
          .select('*, giocatori(*)')
          .eq('id', roomId)
          .single();
        
        if(fetchError || !freshState) {
          playAudio('snd-miss');
          alert("Errore di connessione. Riprova.");
          isProcessingInput = false;
          return;
        }
        
        // ✅ VALIDAZIONE CRITICA: Verifica che sei ANCORA il giocatore corrente
        if(freshState.id_giocatore_corrente !== myId) {
          playAudio('snd-miss');
          alert("Non è più il tuo turno!");
          speak("Errore: il turno è cambiato. Non puoi risolvere.");
          closeInput();
          isProcessingInput = false;
          return;
        }
        
        if(cleanStr(txt)===cleanStr(currentPuzzleText)){
          playAudio('snd-win'); 
          const me=s.giocatori.find(p=>p.id===myId);
          
          addActionToHistory(`${myName} HA RISOLTO! Soluzione: ${txt}`);
          
          
          if(isSpecialRound){
            await _supabase.from('giocatori').update({punteggio_totale:(me.punteggio_totale||0)+(me.punteggio_round||0)+1000,punteggio_round:0}).eq('id', myId);
            
            
            if(specialPhraseIndex < 3){
              await nextSpecialPhrase(myName);
            } else {
              
              await _supabase.from('stanze').update({stato:'finito',ultima_azione:'vittoria',ultimo_messaggio:`${myName} HA COMPLETATO IL ROUND SPECIALE!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
            }
          } else {
            
            await _supabase.from('giocatori').update({punteggio_totale:(me.punteggio_totale||0)+(me.punteggio_round||0)+1000,punteggio_round:0}).eq('id', myId);
            await _supabase.from('stanze').update({stato:'finito',ultima_azione:'vittoria',ultimo_messaggio:`${myName} HA RISOLTO!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
          }
        } else {
          playAudio('snd-miss'); 
          addActionToHistory(`${myName}: Soluzione SBAGLIATA - ${txt}`);
          passTurn();
        }
      } else {
        const char=txt.charAt(0);
        const isVowel="AEIOU".includes(char);
        // ✅ I controlli vocale/consonante sono ora all'inizio di submitInput
        // Non serve ripeterli qui

        if(mode==='vowel'){
          const cost=getVowelCost();
          const me=s.giocatori.find(p=>p.id===myId);
          const myRoundMoney = me ? (me.punteggio_round||0) : 0;
          
          // ✅ FIX RACE CONDITION: Verifica stato fresco prima di comprare vocale
          const { data: freshState, error: fetchError } = await _supabase
            .from('stanze')
            .select('*, giocatori(*)')
            .eq('id', roomId)
            .single();
          
          if(fetchError || !freshState) {
            playAudio('snd-miss');
            alert("Errore di connessione. Riprova.");
            isProcessingInput = false;
            return;
          }
          
          // ✅ VALIDAZIONE CRITICA: Verifica che sei ANCORA il giocatore corrente
          if(freshState.id_giocatore_corrente !== myId) {
            playAudio('snd-miss');
            alert("Non è più il tuo turno!");
            speak("Errore: il turno è cambiato. Non puoi comprare la vocale.");
            closeInput();
            isProcessingInput = false;
            return;
          }
          
          vowelsBoughtThisTurn++;
          await _supabase.from('giocatori').update({punteggio_round:myRoundMoney-cost}).eq('id', myId);
          addActionToHistory(`${myName}: Vocale ${char} comprata per €${cost}`);
        }
        
        
        
        if(isSpecialRound && !specialVowelsPhase && mode==='letter'){
          // ✅ Controlla se siamo già passati alla fase 102 (10 consonanti raggiunte)
          if(s.fase_speciale === 102){
            alert("Limite 10 consonanti raggiunto! Tutti possono risolvere o l'host si arrende.");
            isProcessingInput=false;
            return;
          }
        }

        let foundIndices=[]; let gIdx=0;
        const sol=currentPuzzleText.toUpperCase();
        
        
        if(lettersCalledThisRound.includes(char)) {
          playAudio('snd-miss');
          speak(`${char} già chiamata in questo round!`);
          addActionToHistory(`${myName}: ${char} già chiamata!`);
          await _supabase.from('stanze').update({
            ultima_azione:'errore',
            ultimo_messaggio:`${myName}: ${char} già chiamata!`,
            azione_timestamp:new Date().toISOString()
          }).eq('id', roomId);
          passTurn();
          isProcessingInput=false;
          return;
        }
        
        
        lettersCalledThisRound.push(char);
        
        for(let i=0;i<sol.length;i++){
          if(sol[i].match(/[A-ZÀ-Ù]/)){
            const solChar = sol[i];
            const cleanSolChar = cleanStr(solChar);
            const cleanInputChar = cleanStr(char);
            if(cleanSolChar === cleanInputChar) {
              foundIndices.push(gIdx);
            }
            gIdx++;
          }
        }
        if(foundIndices.length>0){
          
          const newFoundIndices = foundIndices.filter(idx => !(s.lettere_rivelate||[]).includes(idx));
          
          
          if(newFoundIndices.length === 0){
            playAudio('snd-miss'); 
            speak(`${char} già rivelata!`);
            addActionToHistory(`${myName}: ${char} già rivelata!`);
            await _supabase.from('stanze').update({
              ultima_azione:'errore',
              ultimo_messaggio:`${myName}: ${char} già rivelata!`,
              azione_timestamp:new Date().toISOString()
            }).eq('id', roomId);
            passTurn();
            isProcessingInput=false;
            return;
          }
          
          // ✅ FIX: NON riprodurre il suono qui - verrà riprodotto da updateUI
          // quando riceveremo l'aggiornamento dal server. Altrimenti si sovrappone!
          // playMultipleHits(newFoundIndices.length); // <- RIMOSSO
          
          const newRev=[...new Set([...(s.lettere_rivelate||[]), ...foundIndices])];
          if(mode==='letter'){
            
            vowelsBoughtThisTurn = 0;
            
            const me=s.giocatori.find(p=>p.id===myId);
            
            // ✅ FIX RACE CONDITION: Ricarica lo stato fresco dal DB prima di aggiornare
            const { data: freshState, error: fetchError } = await _supabase
              .from('stanze')
              .select('*, giocatori(*), frasi(*)')
              .eq('id', roomId)
              .single();
            
            if(fetchError || !freshState) {
              playAudio('snd-miss');
              alert("Errore di connessione. Riprova.");
              isProcessingInput = false;
              return;
            }
            
            // ✅ VALIDAZIONE CRITICA: Verifica che sei ANCORA il giocatore corrente
            if(freshState.id_giocatore_corrente !== myId) {
              playAudio('snd-miss');
              alert("Non è più il tuo turno!");
              speak("Errore: il turno è cambiato. Non puoi più inserire lettere.");
              closeInput();
              isProcessingInput = false;
              return;
            }
            
            const gain = (s.fase_speciale===3) ? (s.montepremi_round||0) : ((s.montepremi_round||0) * newFoundIndices.length);
            
            // ✅ FIX CRITICO: Aggiorna cache locale PRIMA dell'update DB
            // Questo previene che updateUI() riapra il campo prima che il DB si aggiorni
            if(currentStanza) {
              currentStanza.montepremi_round = 0;
              currentStanza.fase_speciale = 0;
              // ✅ IMMEDIATO: Chiama updateUI subito per riabilitare il pulsante GIRA
              // DEVE usare currentStanza aggiornato, non aspettare il fetch DB
              await updateUI(currentStanza);
            }
            
            const resultMsg = `Trovate ${newFoundIndices.length} ${char}! Guadagni ${gain} euro`;
            // ✅ Nel round speciale NON annunciare subito - lo farà waitForPlayerConsonant dopo i beep
            if(!isSpecialRound || specialVowelsPhase) {
              speak(resultMsg);
            }
            addActionToHistory(`${myName}: ${char} - Trovate ${newFoundIndices.length}, guadagno €${gain}`);
            
            await _supabase.from('giocatori').update({punteggio_round:(me.punteggio_round||0)+gain}).eq('id', myId);
            
            
            if(isSpecialRound && !specialVowelsPhase){
              specialConsonantsUsed++;
              
              // ✅ LOGICA CONSONANTE AUTOMATICA: Se 3 giocatori e 9 consonanti, il sistema rivela la 10ª
              // Estrai il numero reale dal messaggio appena creato
              const countMsg = `${myName}: Trovate ${newFoundIndices.length} ${char} (${specialConsonantsUsed}/10 consonanti)`;
              const countMatch = countMsg.match(/\((\d+)\/10\)/);
              const actualCount = countMatch ? parseInt(countMatch[1]) : specialConsonantsUsed;
              
              if(actualCount === 9 && s.giocatori.length === 3){
                // Aggiorna database con le lettere correnti
                await _supabase.from('stanze').update({
                  lettere_rivelate:newRev,
                  montepremi_round:0,
                  ultima_azione:'chiama_lettera',
                  ultimo_messaggio:countMsg,
                  azione_timestamp:new Date().toISOString()
                }).eq('id', roomId);
                
                // Aspetta un attimo, poi il sistema rivela la 10ª consonante
                setTimeout(async () => {
                  await revealAutomaticConsonant();
                }, 1500);
                
                isProcessingInput=false;
                return; // Non passare il turno, lo farà revealAutomaticConsonant
              }
              
              if(actualCount >= 10){
                await _supabase.from('stanze').update({
                  lettere_rivelate:newRev,
                  montepremi_round:0,
                  fase_speciale:102, 
                  ultima_azione:'consonante_10',
                  ultimo_messaggio:`${myName}: ${char} - 10 CONSONANTI USATE! Tutti possono risolvere o l'host si arrende`,
                  azione_timestamp:new Date().toISOString()
                }).eq('id', roomId);
              } else {
                await _supabase.from('stanze').update({
                  lettere_rivelate:newRev,
                  montepremi_round:0,
                  ultima_azione:'chiama_lettera',
                  ultimo_messaggio:`${myName}: Trovate ${newFoundIndices.length} ${char} (${specialConsonantsUsed}/10 consonanti)`,
                  azione_timestamp:new Date().toISOString()
                }).eq('id', roomId);
              }
            } else {
              
              await _supabase.from('stanze').update({lettere_rivelate:newRev,montepremi_round:0,fase_speciale:0,ultima_azione:'chiama_lettera',ultimo_messaggio:`${myName}: Trovate ${newFoundIndices.length} ${char}`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
            }
          } else {
            
            const vowelResultMsg = newFoundIndices.length > 0
              ? `Trovate ${newFoundIndices.length} ${char}` 
              : `${char} non presente`;
            speak(vowelResultMsg);
            
            await _supabase.from('stanze').update({lettere_rivelate:newRev,ultima_azione:'chiama_lettera',ultimo_messaggio:`${myName}: Trovate ${newFoundIndices.length} ${char}`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
          }
        } else {
          playAudio('snd-miss'); 
          
          // ✅ Nel round speciale consonanti NON si passa il turno per lettera mancante
          // Il turno è gestito dal loop di startConsonantCollection
          if(isSpecialRound && !specialVowelsPhase) {
            // ✅ CRITICO: Incrementa il contatore anche se la lettera non è trovata!
            specialConsonantsUsed++;
            
            // ✅ NON annunciare subito - lo farà waitForPlayerConsonant dopo i beep
            addActionToHistory(`${myName}: ${char} NON PRESENTE`);
            await _supabase.from('stanze').update({
              ultima_azione:'errore',
              ultimo_messaggio:`${myName}: ${char} assente (${specialConsonantsUsed}/10 consonanti)`,
              azione_timestamp:new Date().toISOString()
            }).eq('id', roomId);
            // NON chiamare passTurn() - il loop gestisce i turni
          } else {
            // Round normale: passa il turno
            speak(`${char} non trovata! Passi il turno`);
            addActionToHistory(`${myName}: ${char} NON PRESENTE`);
            await _supabase.from('stanze').update({ultima_azione:'errore',ultimo_messaggio:`${myName}: ${char} assente`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
            await passTurn();
          }
        }
      }
      
      setTimeout(async () => {
        if(roomId) await fetchFullState();
        isProcessingInput=false; // ✅ Reset DOPO il fetch, così updateUI vede i dati freschi
        
        // ✅ SMARTPHONE FIX: Dopo aver trovato una consonante, aspetta 1 secondo e poi 
        // forza un altro fetch per assicurarsi che il pulsante GIRA sia riabilitato
        // Questo risolve race condition dove isProcessingInput blocca canSpin
        setTimeout(async () => {
          if(roomId) await fetchFullState();
        }, 1000);
      }, 100); // ✅ Ridotto a 100ms per reattività ottimale
    }

    function checkTurnTimer(){
      if(!currentStanza || currentStanza.in_pausa || currentStanza.stato!=='gioco') return;
      
      // Non controllare il timer se l'utente sta facendo qualcosa
      if(isSpinning || isProcessingInput) return;
      
      // ✅ FIX: Non passare automaticamente il turno se l'utente è in modalità input
      // (sta scrivendo una consonante, vocale o soluzione)
      if(inputMode) return;
      
      // ✅ FIX CHATGPT: Usa SOLO azione_timestamp dal DB (fonte di verità unica)
      const timestampToUse = currentStanza.azione_timestamp;
      
      const elapsed=Math.floor((new Date().getTime() - new Date(timestampToUse).getTime())/1000);
      if(isNaN(elapsed) || elapsed > 10000 || elapsed < -100) return;
      const left=Math.max(0, TURN_LIMIT_SEC - elapsed);
      document.getElementById('timer-box').textContent=left;
      
      // ✅ Quando il timer scade, passa il turno (anche se sei tu a giocare)
      if(left===0 && isHost && !isHandlingTimeout) {
        passTurn();
      }
    }

    async function fetchChat(showAll = false){
      const {data:msgs}=await _supabase.from('chat_messaggi').select('*').eq('stanza_id', roomId).order('created_at',{ascending:true}).limit(50);
      if(!msgs || msgs.length === 0) {
        const c=document.getElementById('chat-messages');
        c.innerHTML="<p style='color:#777;text-align:center;'>Nessun messaggio</p>";
        return;
      }
      
      const c=document.getElementById('chat-messages'); 
      c.innerHTML="";
      
      if(showAll) {
        
        msgs.forEach(m=>{
          const d=document.createElement('div');
          d.style="border-bottom:1px solid #333; margin-bottom:5px; padding:8px;";
          d.tabIndex = 0;
          
          // Check if it's a sound effect
          if(m.messaggio.startsWith('[SOUND:')){
            const soundMatch = m.messaggio.match(/\[SOUND:([^\]]+)\](.+)/);
            if(soundMatch){
              const soundName = escapeHtml(soundMatch[2]);
              d.innerHTML=`<strong style="color:var(--col-accent);">${escapeHtml(m.giocatore_nome)}</strong> <span style="color:#aaa;">ha fatto:</span> <strong style="color:var(--col-neon); font-size:1.2em;">${soundName}</strong>`;
            }
          } else {
            d.innerHTML=`<strong style="color:var(--col-accent);">${escapeHtml(m.giocatore_nome)}:</strong> ${escapeHtml(m.messaggio)}`;
          }
          c.appendChild(d);
        });
        c.scrollTop=c.scrollHeight;
      } else {
        
        const lastMsg = msgs[msgs.length - 1];
        const d=document.createElement('div');
        d.style="border-bottom:1px solid #333; margin-bottom:5px; padding:8px; font-size:1.1em;";
        d.tabIndex = 0;
        
        // Check if it's a sound effect
        if(lastMsg.messaggio.startsWith('[SOUND:')){
          const soundMatch = lastMsg.messaggio.match(/\[SOUND:([^\]]+)\](.+)/);
          if(soundMatch){
            const soundName = escapeHtml(soundMatch[2]);
            d.innerHTML=`<strong style="color:var(--col-accent);">${escapeHtml(lastMsg.giocatore_nome)}</strong> <span style="color:#aaa;">ha fatto:</span> <strong style="color:var(--col-neon); font-size:1.2em;">${soundName}</strong>`;
          }
        } else {
          d.innerHTML=`<strong style="color:var(--col-accent);">${escapeHtml(lastMsg.giocatore_nome)}:</strong> ${escapeHtml(lastMsg.messaggio)}`;
        }
        c.appendChild(d);
        
        
        if(msgs.length > 1) {
          const hint=document.createElement('p');
          hint.style="color:#888; font-size:0.9em; margin-top:10px; text-align:center;";
          hint.innerHTML=" Usa Shift+Tab dal campo input per vedere tutti i messaggi";
          c.appendChild(hint);
        }
      }
    }
    
    function openChat(){ 
       document.getElementById('chat-overlay').classList.remove('hidden'); 
       fetchChat(false); 
       
       
       setTimeout(() => {
         speak("Chat aperta. Premi Shift Tab per vedere la cronologia completa.");
         
         const chatInput = document.getElementById('chat-input');
         chatInput.focus();
         
         
         chatInput.onkeydown = null;
         
         
         chatInput.addEventListener('keydown', (e) => {
           if(e.key === 'Tab' && e.shiftKey) {
             e.preventDefault();
             fetchChat(true); 
             speak("Visualizzazione cronologia completa. Usa le frecce per navigare tra i messaggi.");
             
             setTimeout(() => {
               const firstMsg = document.getElementById('chat-messages').querySelector('div[tabindex="0"]');
               if(firstMsg) firstMsg.focus();
             }, 100);
           } else if(e.key === 'Enter') {
             e.preventDefault();
             sendChatMessage();
           }
         });
       }, 150);
    }
    
    async function sendChatMessage(){
      const t=document.getElementById('chat-input').value.trim();
      if(!t) return;
      await _supabase.from('chat_messaggi').insert({stanza_id:roomId, giocatore_nome:document.getElementById('inp-name').value, messaggio:t});
      document.getElementById('chat-input').value="";
      fetchChat(false); 
      document.getElementById('chat-input').focus();
    }

    async function startNewRound(){
      if(!isHost) return;
      let n=currentStanza.round_giocati + 1;
      if(n>10){ await _supabase.from('stanze').update({stato:'terminata'}).eq('id', roomId); return; }
      
      
      lettersCalledThisRound = [];
      
      
      const isSpecial = (n === 4 || n === 7 || n === 10);
      
      if(isSpecial){
        
        // ✅ FIX: Il database usa 'tema' non 'hint'! Prendi tutti i temi disponibili
        const {data:themes}=await _supabase.from('frasi').select('tema').eq('categoria','SITUAZIONI QUOTIDIANE');
        
        if(!themes || themes.length === 0){
          speak("Errore: non ci sono frasi nella categoria SITUAZIONI QUOTIDIANE");
          alert("ERRORE: Non ci sono frasi con categoria 'SITUAZIONI QUOTIDIANE' nel database!");
          return;
        }
        
        // Filtra solo temi non null e prendi temi unici
        const uniqueThemes = [...new Set(themes.map(t => t.tema).filter(Boolean))];
        
        if(uniqueThemes.length === 0){
          speak("Errore: le frasi SITUAZIONI QUOTIDIANE non hanno il campo tema compilato");
          alert("ERRORE: Le frasi con categoria 'SITUAZIONI QUOTIDIANE' devono avere il campo 'tema' compilato!");
          return;
        }
        
        // Scegli un tema random
        const selectedTheme = uniqueThemes[Math.floor(Math.random() * uniqueThemes.length)];
        
        // Prendi tutte le frasi di quel tema (dovrebbero essere 4)
        const {data:fr}=await _supabase.from('frasi').select('id,tema,soluzione,categoria').eq('categoria','SITUAZIONI QUOTIDIANE').eq('tema', selectedTheme);
        
        if(!fr || fr.length < 4){
          speak(`Errore: tema "${selectedTheme}" ha solo ${fr?.length || 0} frasi, ne servono 4`);
          alert(`ERRORE: Il tema "${selectedTheme}" ha solo ${fr?.length || 0} frasi. Servono esattamente 4 frasi per tema!`);
          return;
        }
        
        specialPhraseIds = fr.map(f => f.id);
        isSpecialRound = true;
        specialPhraseIndex = 0;
        specialConsonantsUsed = 0;
        specialVowelsPhase = true;
        specialVowelsGiven = 0;
        lettersCalledThisRound = []; // Reset lettere chiamate
        
        
        const firstPhraseId = specialPhraseIds[0];
        await _supabase.from('giocatori').update({punteggio_round:0}).eq('stanza_id', roomId);
        await _supabase.from('stanze').update({
          frase_corrente_id: firstPhraseId,
          stato:'gioco',
          round_giocati:n,
          lettere_rivelate:[],
          montepremi_round:0,
          fase_speciale:100, 
          ultima_azione:'round_speciale_start',
          ultimo_messaggio:`ROUND SPECIALE ${n} - Tema: ${selectedTheme}! Fase vocali inizia...`,
          azione_timestamp:new Date().toISOString()
        }).eq('id', roomId);
        
        // ✅ Dopo 2 secondi, inizia la raccolta delle vocali
        if(isHost) {
          setTimeout(() => startVowelCollection(), 2000);
        }
        
      } else {
        
        isSpecialRound = false;
        const {data:fr}=await _supabase.from('frasi').select('id,categoria').neq('categoria','SITUAZIONI QUOTIDIANE').limit(500);
        if(!fr || fr.length === 0){
          speak("Errore: nessuna frase disponibile");
          return;
        }
        
        const validPhrases = fr.filter(f => f.categoria !== 'SITUAZIONI QUOTIDIANE');
        if(validPhrases.length === 0){
          speak("Errore: tutte le frasi sono SITUAZIONI QUOTIDIANE");
          return;
        }
        const rid=validPhrases[Math.floor(Math.random()*validPhrases.length)].id;
        await _supabase.from('giocatori').update({punteggio_round:0}).eq('stanza_id', roomId);
        await _supabase.from('stanze').update({frase_corrente_id:rid,stato:'gioco',round_giocati:n,lettere_rivelate:[],montepremi_round:0,fase_speciale:0,ultima_azione:'nuovo',ultimo_messaggio:`Inizio Round ${n}`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
      }
    }
    
    function getSpecialVowelInstructions(){
      const numPlayers = currentStanza.giocatori.length;
      if(numPlayers === 1) return "Sistema regala 3 vocali";
      if(numPlayers === 2) return "1 vocale per giocatore + 1 dal sistema";
      if(numPlayers === 3) return "1 vocale per giocatore";
      return "Fase vocali";
    }
    
    async function startVowelCollection() {
      // ✅ Gestisce la raccolta delle vocali in sequenza
      const s = currentStanza;
      if(!s) return;
      
      const numPlayers = s.giocatori.length;
      
      // ✅ LOGICA VOCALI:
      // 1 giocatore: giocatore sceglie 1, sistema dà 2
      // 2 giocatori: ogni giocatore sceglie 1, sistema dà 1
      // 3 giocatori: ogni giocatore sceglie 1, sistema non dà nulla
      
      const vowelsPerPlayer = 1;
      let systemVowels = 0;
      if(numPlayers === 1) systemVowels = 2;
      else if(numPlayers === 2) systemVowels = 1;
      else systemVowels = 0; // 3 o più giocatori
      
      // Chiedi le vocali ai giocatori in sequenza
      for(let i = 0; i < numPlayers; i++) {
        const player = s.giocatori[i];
        
        // ✅ Annuncia il cambio turno se siamo in 2 o 3 giocatori
        if(numPlayers > 1) {
          speak(`Turno di ${player.nome}`);
          await new Promise(resolve => setTimeout(resolve, 800));
        }
        
        // Imposta il turno su questo giocatore
        await _supabase.from('stanze').update({
          id_giocatore_corrente: player.id,
          ultimo_messaggio: `${player.nome}: scegli 1 vocale`,
          azione_timestamp: new Date().toISOString()
        }).eq('id', roomId);
        
        // Aspetta che il giocatore scelga la vocale
        await waitForPlayerVowel(player.id);
        
        // ✅ Pausa di 2 secondi per vedere bene la vocale rivelata
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
      
      // Ora le vocali del sistema
      if(systemVowels > 0) {
        await giveSystemVowels(systemVowels, s);
      }
      
      // Completa la fase vocali e passa alle consonanti
      specialVowelsPhase = false;
      specialConsonantsUsed = 0;
      
      await _supabase.from('stanze').update({
        fase_speciale: 101,
        ultimo_messaggio: `Vocali complete! Fase consonanti: 10 consonanti totali`,
        azione_timestamp: new Date().toISOString()
      }).eq('id', roomId);
      
      speak("Fase vocali completata. Inizia la fase consonanti.");
      
      // ✅ Dopo 2 secondi, inizia la raccolta delle consonanti
      setTimeout(() => startConsonantCollection(), 2000);
    }
    
    async function waitForPlayerVowel(playerId) {
      // ✅ Aspetta che il giocatore scelga una vocale (con timeout di 2 minuti)
      return new Promise((resolve) => {
        const checkInterval = setInterval(() => {
          const s = currentStanza;
          
          // Controlla se la vocale è stata inserita
          const currentVowels = lettersCalledThisRound.filter(c => 'AEIOU'.includes(c)).length;
          
          if(currentVowels > specialVowelsGiven) {
            specialVowelsGiven = currentVowels;
            clearInterval(checkInterval);
            clearTimeout(timeoutId);
            resolve();
          }
        }, 500);
        
        // Timeout dopo 2 minuti - risolvi comunque per evitare blocco
        const timeoutId = setTimeout(() => {
          clearInterval(checkInterval);
          resolve(); // Risolvi comunque per continuare
        }, 120000);
      });
    }
    
    async function startConsonantCollection() {
      // ✅ Gestisce la raccolta delle 10 consonanti
      const s = currentStanza;
      if(!s) return;
      
      const numPlayers = s.giocatori.length;
      let consonantsPerPlayer;
      let systemConsonants;
      
      if(numPlayers === 1) {
        consonantsPerPlayer = 10;
        systemConsonants = 0;
      } else if(numPlayers === 2) {
        consonantsPerPlayer = 5;
        systemConsonants = 0;
      } else { // 3 giocatori
        consonantsPerPlayer = 3;
        systemConsonants = 1;
      }
      
      // Raccogli consonanti dai giocatori
      let totalConsonants = 0;
      
      while(totalConsonants < consonantsPerPlayer * numPlayers) {
        for(let i = 0; i < numPlayers && totalConsonants < consonantsPerPlayer * numPlayers; i++) {
          const player = s.giocatori[i];
          
          // ✅ Protezione: Verifica che il giocatore esista ancora
          if(!player) {
            continue;
          }
          
          // ✅ Annuncia il turno PRIMA della prima consonante (totalConsonants === 0)
          if(totalConsonants === 0) {
            speak(`Turno di ${player.nome}`);
            await new Promise(resolve => setTimeout(resolve, 800));
          }
          
          // ✅ Calcola quale sarà il prossimo giocatore per l'annuncio
          const nextIndex = (i + 1) % numPlayers;
          const nextPlayer = s.giocatori[nextIndex];
          // ✅ FIX: Considera che con 3 giocatori la 10ª consonante è automatica
          const totalConsonantsNeeded = (numPlayers === 3) ? 9 : (consonantsPerPlayer * numPlayers);
          const willBeLastConsonant = (totalConsonants + 1 >= totalConsonantsNeeded);
          
          // Imposta il turno
          await _supabase.from('stanze').update({
            id_giocatore_corrente: player.id,
            montepremi_round: 0, // Reset per permettere di girare
            ultimo_messaggio: `${player.nome}: gira la ruota e scegli consonante (${specialConsonantsUsed}/10)`,
            azione_timestamp: new Date().toISOString()
          }).eq('id', roomId);
          
          // ✅ Pausa per permettere ai client di ricevere l'update
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Aspetta consonante e passa info sul prossimo giocatore
          await waitForPlayerConsonant(player.id, nextPlayer, willBeLastConsonant);
          totalConsonants++;
          
          // ✅ Pausa per far finire i beep di lettera presente/assente
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // ✅ Beep sintetico breve DOPO aver scelto la consonante (per conferma/transizione)
          if(totalConsonants < consonantsPerPlayer * numPlayers) {
            playSound(600, 80, 'sine'); // Beep breve di conferma
          }
          
          // ✅ Pausa di 1 secondo aggiuntivo per vedere bene la consonante
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
      
      // Consonante del sistema se necessario
      if(systemConsonants > 0) {
        await revealAutomaticConsonant();
      }
      
      // Ora tutti possono risolvere
      await _supabase.from('stanze').update({
        fase_speciale: 102,
        ultimo_messaggio: `10 consonanti completate! Tutti possono RISOLVERE. Host può arrendersi.`,
        azione_timestamp: new Date().toISOString()
      }).eq('id', roomId);
      
      speak("Dieci consonanti completate! Tutti possono provare a risolvere.");
    }
    
    async function waitForPlayerConsonant(playerId, nextPlayer, isLastConsonant) {
      // ✅ Aspetta che il giocatore scelga una consonante (controllando il database)
      return new Promise((resolve) => {
        // ✅ Leggi il numero iniziale dal DB
        const initialMsg = currentStanza?.ultimo_messaggio || '';
        const initialMatch = initialMsg.match(/\((\d+)\/10\)/);
        const initialCount = initialMatch ? parseInt(initialMatch[1]) : 0;
        
        const checkInterval = setInterval(async () => {
          // ✅ Ricarica stato fresco dal DB
          const { data: freshState } = await _supabase
            .from('stanze')
            .select('ultimo_messaggio, fase_speciale')
            .eq('id', roomId)
            .single();
          
          if(!freshState) return;
          
          // ✅ Controlla se il numero di consonanti è aumentato
          const currentMsg = freshState.ultimo_messaggio || '';
          const currentMatch = currentMsg.match(/\((\d+)\/10\)/);
          const currentCount = currentMatch ? parseInt(currentMatch[1]) : 0;
          
          // ✅ Oppure controlla se siamo passati alla fase 102 (tutte le consonanti usate)
          if(currentCount > initialCount || freshState.fase_speciale === 102) {
            clearInterval(checkInterval);
            clearTimeout(timeoutId);
            
            // ✅ ANNUNCIO: "X di 10, turno di Y" dopo 500ms dai beep
            setTimeout(() => {
              if(freshState.fase_speciale === 102 || currentCount >= 10) {
                // Decima consonante - annuncio finale
                speak(`10 di 10. Non si possono chiamare più consonanti. Tutti possono risolvere!`);
              } else if(nextPlayer) {
                // Prima consonante: "Consonante 1 di 10"
                // Successive: "2 di 10", "3 di 10", ecc.
                const prefix = (currentCount === 1) ? 'Consonante ' : '';
                speak(`${prefix}${currentCount} di 10, turno di ${nextPlayer.nome}`);
              } else {
                const prefix = (currentCount === 1) ? 'Consonante ' : '';
                speak(`${prefix}${currentCount} di 10`);
              }
            }, 500);
            
            resolve();
          }
        }, 500);
        
        // Timeout dopo 2 minuti - risolvi comunque per evitare blocco
        const timeoutId = setTimeout(() => {
          clearInterval(checkInterval);
          resolve(); // Risolvi comunque per continuare
        }, 120000);
      });
    }
    
    async function revealAutomaticConsonant(){
      // ✅ Sistema rivela automaticamente la 10ª consonante (la più frequente rimasta)
      const s = currentStanza;
      if(!s || !currentPuzzleText) return;
      
      // Conta frequenza di ogni consonante NON ancora completamente rivelata
      const consonantCounts = {}; // Quante volte appare nella frase
      const revealedCounts = {};  // Quante sono già rivelate
      
      let gIdx = 0;
      currentPuzzleText.toUpperCase().split('').forEach(c => {
        if(c.match(/[A-Z]/)){
          if(!"AEIOU".includes(c)){
            // È una consonante
            consonantCounts[c] = (consonantCounts[c] || 0) + 1;
            
            if(s.lettere_rivelate.includes(gIdx)){
              revealedCounts[c] = (revealedCounts[c] || 0) + 1;
            }
          }
          gIdx++;
        }
      });
      
      // Trova la consonante con più occorrenze NON ancora rivelate
      let mostFrequent = null;
      let maxUnrevealed = 0;
      
      for(let cons in consonantCounts){
        const totalCount = consonantCounts[cons];
        const alreadyRevealed = revealedCounts[cons] || 0;
        const unrevealed = totalCount - alreadyRevealed;
        
        if(unrevealed > 0 && unrevealed > maxUnrevealed){
          mostFrequent = cons;
          maxUnrevealed = unrevealed;
        }
      }
      
      if(!mostFrequent){
        // Non ci sono più consonanti da rivelare (non dovrebbe succedere)
        speak("Errore: nessuna consonante da rivelare");
        await passTurn();
        return;
      }
      
      // Trova tutti gli indici NON rivelati di questa consonante nella frase
      const foundIndices = [];
      gIdx = 0;
      currentPuzzleText.toUpperCase().split('').forEach(c => {
        if(c.match(/[A-Z]/)){
          if(c === mostFrequent && !s.lettere_rivelate.includes(gIdx)){
            foundIndices.push(gIdx);
          }
          gIdx++;
        }
      });
      
      // Aggiungi alle lettere rivelate
      const newRev = [...new Set([...(s.lettere_rivelate || []), ...foundIndices])];
      
      // Incrementa contatore
      specialConsonantsUsed++;
      
      // Aggiorna database
      await _supabase.from('stanze').update({
        lettere_rivelate: newRev,
        montepremi_round: 0,
        fase_speciale: 102, // Tutte le consonanti usate
        ultima_azione: 'sistema_consonante',
        ultimo_messaggio: `Il sistema rivela: ${mostFrequent} - Trovate ${foundIndices.length}! (10/10 consonanti)`,
        azione_timestamp: new Date().toISOString()
      }).eq('id', roomId);
      
      // Suona i beep in base a quante lettere trovate
      playMultipleHits(foundIndices.length);
      speak(`Il sistema rivela: ${NATO[mostFrequent] || mostFrequent}. Trovate ${foundIndices.length} lettere.`);
      addActionToHistory(`SISTEMA: ${mostFrequent} - Trovate ${foundIndices.length}`);
      
      // ✅ Passa il turno dopo 2 secondi per dare tempo di vedere
      setTimeout(() => {
        passTurn();
      }, 2000);
    }

    
    
    async function giveSystemVowels(count, stanza){
      const vowelsOrder = ['E','A','I','O','U']; 
      
      
      const calledVowels = lettersCalledThisRound.filter(c => 'AEIOU'.includes(c));
      
      
      for(let v of vowelsOrder){
        if(count === 0) break;
        
        
        if(!calledVowels.includes(v)){
          
          if(!lettersCalledThisRound.includes(v)) {
            lettersCalledThisRound.push(v);
          }
          
          
          let foundIndices=[]; let gIdx=0;
          const sol=currentPuzzleText.toUpperCase();
          for(let i=0;i<sol.length;i++){
            if(sol[i].match(/[A-ZÀ-Ù]/)){
              if(sol[i]===v) foundIndices.push(gIdx);
              gIdx++;
            }
          }
          
          if(foundIndices.length > 0){
            const newRev=[...new Set([...(stanza.lettere_rivelate||[]), ...foundIndices])];
            await _supabase.from('stanze').update({lettere_rivelate:newRev,ultimo_messaggio:`Sistema regala vocale: ${v} - Trovate ${foundIndices.length}`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
            stanza.lettere_rivelate = newRev;
            
            // ✅ Usa il beep audio reale (snd-hit) tante volte quante sono le occorrenze
            playMultipleHits(foundIndices.length);
            
            speak(`Sistema regala vocale ${v}. Trovate ${foundIndices.length}.`);
          } else {
            
            await _supabase.from('stanze').update({ultimo_messaggio:`Sistema regala vocale: ${v} (non presente)`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
            playAudio('snd-miss'); // ✅ Beep audio per lettera non trovata
            speak(`Sistema regala vocale ${v}. Non presente.`);
          }
          
          count--;
          
          // ✅ Pausa di 1 secondo tra le vocali del sistema
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }
    
    async function nextSpecialPhrase(solverName){
      specialPhraseIndex++;
      specialConsonantsUsed = 0;
      specialVowelsPhase = true;
      specialVowelsGiven = 0;
      lettersCalledThisRound = []; // ✅ Reset lettere chiamate per la nuova frase
      
      const nextPhraseId = specialPhraseIds[specialPhraseIndex];
      await _supabase.from('stanze').update({
        frase_corrente_id: nextPhraseId,
        lettere_rivelate:[],
        montepremi_round:0,
        fase_speciale:100, // Fase vocali
        ultimo_messaggio:`${solverName} risolve! Frase ${specialPhraseIndex + 1}/4 - ${getSpecialVowelInstructions()}`,
        azione_timestamp:new Date().toISOString()
      }).eq('id', roomId);
      
      // ✅ Riavvia la raccolta vocali dopo 2 secondi
      speak(`Frase risolta! Frase ${specialPhraseIndex + 1} su 4. Raccolta vocali...`);
      setTimeout(() => {
        startVowelCollection();
      }, 2000);
    }

    async function leaveGame(){
      // ✅ CORREZIONE CHATGPT: Ferma ping periodico
      stopPeriodicPing();
      
      // Cleanup channels and timers
      if(gameChannel) {
        await gameChannel.unsubscribe();
        gameChannel = null;
      }
      if(playersChannel) { // ✅ CORREZIONE CHATGPT
        await playersChannel.unsubscribe();
        playersChannel = null;
      }
      if(chatChannel) {
        await chatChannel.unsubscribe();
        chatChannel = null;
      }
      if(turnTimerInterval) {
        clearInterval(turnTimerInterval);
        turnTimerInterval = null;
      }
      if(nextRoundInterval) {
        clearInterval(nextRoundInterval);
        nextRoundInterval = null;
      }
      
      if(roomId && myId){
        if(isHost){
          if(confirm("Sei l'host! Vuoi chiudere la stanza per tutti?")){
            await closeRoom();
            return;
          } else {
            
            await _supabase.from('giocatori').delete().eq('id', myId);
          }
        } else {
          
          await _supabase.from('giocatori').delete().eq('id', myId);
        }
      }
      
      
      
      document.getElementById('game-panel').classList.add('hidden');
      document.getElementById('setup-panel').classList.remove('hidden');
      
      // ✅ FIX: Non riempire automaticamente i campi quando esci
      // Gli utenti con screen reader preferiscono campi vuoti
      // I valori sono comunque salvati in localStorage se vogliono rientrare
      
      // Reset display
      const displayName = document.getElementById('inp-name-display');
      const displayCode = document.getElementById('inp-code-display');
      if(displayName) displayName.textContent = '(vuoto)';
      if(displayCode) displayCode.textContent = '(vuoto)';
      
      
      roomId = null;
      myId = null;
      myIndex = null;
      isHost = false;
      currentStanza = null;
      
      speak("Sei uscito dalla stanza.");
    }
    async function closeRoom(){ 
      await _supabase.from('stanze').delete().eq('id', roomId); 
      localStorage.removeItem('lastRoomCode');
      localStorage.removeItem('lastPlayerName');
      location.reload(); 
    }
    
    async function surrenderPhrase(){
      if(!isHost) return;
      
      
      if(isSpecialRound && specialPhraseIndex < 3){
        if(confirm("Arrenditi e passa alla frase successiva?")){
          await nextSpecialPhrase("HOST");
        }
        return;
      }
      
      
      if(isSpecialRound && specialPhraseIndex === 3){
        if(confirm("Arrenditi? Finirà il round speciale.")){
          await _supabase.from('stanze').update({stato:'finito',ultima_azione:'arresa',ultimo_messaggio:'HOST SI È ARRESO - ROUND SPECIALE CONCLUSO',azione_timestamp:new Date().toISOString()}).eq('id', roomId);
        }
        return;
      }
      
      
      if(confirm("Arrenditi?")){
        await _supabase.from('stanze').update({stato:'finito',ultima_azione:'arresa',ultimo_messaggio:'HOST SI È ARRESO',azione_timestamp:new Date().toISOString()}).eq('id', roomId);
      }
    }
    
    async function resetGame(){
      if(!confirm("Reset partita? Tutti i punteggi saranno azzerati.")) return;
      
      
      // Reset punteggi
      await _supabase.from('giocatori').update({
        punteggio_totale: 0, 
        punteggio_round: 0
      }).eq('stanza_id', roomId);
      
      // Reset stanza
      await _supabase.from('stanze').update({
        round_giocati: 0, 
        lettere_rivelate: [],
        montepremi_round: 0,
        fase_speciale: 0
      }).eq('id', roomId);
      
      
      // Riorganizza giocatori e turni
      await reorganizePlayers();
      
      
      // Avvia nuovo round
      await startNewRound();
      
      speak("Partita resettata. Nuovo round iniziato.");
    }
    
    
    let audioEnabled = true;
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(frequency, duration = 150, type = 'sine') {
      if (!audioEnabled) return;
      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration / 1000);
      } catch(e) {
      }
    }
    
    function playRandomCorrectSound() {
      if (!audioEnabled) return;
      const frequencies = [523.25, 587.33, 659.25, 783.99]; 
      const randomFreq = frequencies[Math.floor(Math.random() * frequencies.length)];
      playSound(randomFreq, 60, 'sine');
      setTimeout(() => playSound(randomFreq * 1.5, 80, 'sine'), 70);
    }
    
    function playIncorrectSound() {
      if (!audioEnabled) return;
      playSound(200, 80, 'sawtooth');
      setTimeout(() => playSound(150, 120, 'sawtooth'), 90);
    }
    
    function playWheelSpinSound() {
      if (!audioEnabled) return;
      let freq = 400;
      const spinInterval = setInterval(() => {
        playSound(freq, 50, 'square');
        freq += 50;
        if (freq > 800) freq = 400;
      }, 100);
      setTimeout(() => clearInterval(spinInterval), 2000);
    }
    
    function playSuccessSound() {
      if (!audioEnabled) return;
      playSound(523.25, 100);
      setTimeout(() => playSound(659.25, 100), 120);
      setTimeout(() => playSound(783.99, 150), 240);
    }
    
    function toggleAudio() {
      audioEnabled = !audioEnabled;
      const btn = document.getElementById('btn-toggle-audio');
      if (btn) {
        btn.textContent = audioEnabled ? 'Audio ON' : 'Audio OFF';
      }
      // Aggiorna anche il pulsante nella vista accessibile
      const accBtn = document.getElementById('btn-acc-audio');
      if (accBtn) {
        accBtn.textContent = audioEnabled ? 'AUDIO ON' : 'AUDIO OFF';
      }
      if (audioEnabled) {
        playSound(440, 100);
      }
    }
    
    // Sistema ping periodico per tracciare giocatori online
    function startPeriodicPing(){
      if(pingInterval) clearInterval(pingInterval);
      
      pingInterval = setInterval(async () => {
        if(!myId || !roomId) return;
        
        try {
          await _supabase
            .from('giocatori')
            .update({ultimo_ping: new Date().toISOString()})
            .eq('id', myId);
          
        } catch(e) {
        }
      }, 10000); // Ogni 10 secondi
    }
    
    function stopPeriodicPing(){
      if(pingInterval){
        clearInterval(pingInterval);
        pingInterval = null;
      }
    }
  </script>
</body>
</html>