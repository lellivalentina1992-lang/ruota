<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>La Ruota (V7 - Shortcut Bot)</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
  // --- INIZIALIZZAZIONE SUPABASE ---
  const _supabase = supabase.createClient(
    'https://azcwkpdjbysnivknnino.supabase.co',
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF6Y3drcGRqYnlzbml2a25uaW5vIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2MzAwNDksImV4cCI6MjA3OTIwNjA0OX0.R8wkMJEmsP8cTVUUOcWtD4Rrg_ZhuOE-PYBJ56eGqMU'
  );

  // --- LOGIN ANONIMO AUTOMATICO ---
  (async () => {
    const { data: { session } } = await _supabase.auth.getSession();
    if (!session) {
      console.log('[AUTH] Nessuna sessione, faccio login anonimo...');
      await _supabase.auth.signInAnonymously();
      console.log('[AUTH] Login anonimo completato');
    } else {
      console.log('[AUTH] Sessione già attiva:', session.user.id);
    }
  })();

  // --- PROTEZIONE AIRBAG EVOLUTA ---
  window.onerror = function(msg, url, line) {
    if (!msg || typeof msg !== 'string') return false;
    if(msg.includes('ResizeObserver')) return false;

    if (msg.toLowerCase().includes('null') || msg.toLowerCase().includes('undefined') || msg.toLowerCase().includes('tolowercase')) {
      if(document.getElementById('airbag-error-box')) return;
      const box = document.createElement('div');
      box.id = 'airbag-error-box';
      box.style = "position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:rgba(40,0,0,0.95); border:4px solid red; color:white; padding:30px; z-index:99999; font-family:sans-serif; text-align:center; box-shadow:0 0 50px red; border-radius:15px; min-width:300px;";
      box.innerHTML = `
        <h2 style='margin-top:0; color:#ff5555'>⚠️ ERRORE RILEVATO</h2>
        <div style="display:flex; flex-direction:column; gap:10px;">
          <button id="btn-ignore-err" style="padding:15px; background:#444; color:#fff; border:1px solid #fff; font-weight:bold; cursor:pointer; font-size:1.1em;">✖️ IGNORA E CONTINUA</button>
          <button onclick="window.location.reload()" style="padding:10px; background:transparent; color:#aaa; border:1px solid #555; cursor:pointer;">Aggiorna Pagina (F5)</button>
        </div>
      `;
      document.body.appendChild(box);
      document.getElementById('btn-ignore-err').onclick = function(){ box.remove(); };
      return true; 
    }
  };
</script>

  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-body:#050505; --bg-panel:#1a1a1a;
      --col-text:#fff; --col-accent:#ffd700; --col-neon:#00ffff; --col-green:#00ff00;
      --font-main:'Roboto Condensed',sans-serif;
    }
    body{background:var(--bg-body);color:var(--col-text);font-family:var(--font-main);margin:0;padding:0;text-align:center;overflow-x:hidden;padding-bottom:150px;} 
    body.high-contrast{--bg-body:#000;--bg-panel:#000;--col-text:#fff;--col-accent:#ff0;--col-neon:#0f0;}
    .sr-only{position:absolute;width:1px;height:1px;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);}
    *:focus{outline:none;box-shadow:0 0 0 4px var(--col-neon);border-radius:4px;z-index:10000;}
    .container{max-width:900px;margin:0 auto;padding:10px;display:flex;flex-direction:column;align-items:center;}
    
    .hidden{display:none !important; visibility: hidden !important; pointer-events: none !important;}
    
    .info-bar{width:100%;display:flex;justify-content:space-between;align-items:center;background:linear-gradient(90deg,#222,#333,#222);padding:10px 15px;border-radius:0 0 15px 15px;border-bottom:2px solid #444;box-sizing:border-box;}
    .timer-display{font-size:2em;color:#ff4444;text-shadow:0 0 10px #ff0000;font-weight:900;min-width:60px;}
    .stats-display{text-align:right;font-size:1.1em;line-height:1.2;color:#ddd;}
    .money-box{margin-top:5px;display:flex;gap:15px;justify-content:center;font-size:1.3em;color:var(--col-accent);text-shadow:0 0 5px rgba(255,215,0,.5);}
    .section-header{width:95%;text-align:left;margin:15px 0 5px 0;color:#888;border-bottom:1px solid #444;padding-bottom:5px;font-size:1em;text-transform:uppercase;letter-spacing:1px;display:none;}
    body.accessible-mode .section-header{display:block;}
    .acc-nav { display: none; width: 98%; max-width: 800px; margin: 10px auto 5px auto; gap: 8px; }
    body.accessible-mode .acc-nav { display: grid; grid-template-columns: 1fr; }
    .acc-nav button { font-size: 0.95em; padding: 12px 10px; min-height: 52px; }
    @media (min-width: 769px) { body.accessible-mode .acc-nav { grid-template-columns: repeat(2, 1fr); } }

    #game-panel{width:100%;max-width:800px;margin-top:10px;display:flex;flex-direction:column;gap:5px;}
    .category-box{order:0;margin:5px 0;}
    #live-category{color:var(--col-neon);font-size:1.8em;margin:0;text-transform:uppercase;letter-spacing:2px;text-shadow:0 0 10px var(--col-neon);}
    #round-hint{color:#fff;font-size:1.2em;font-weight:normal;margin:5px 0;opacity:.8;}

    .top-controls-wrapper{order:1;width:100%;margin-bottom:5px;}
    .controls-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;width:98%;margin:0 auto;}
    .bottom-controls-wrapper{order:3;width:98%;margin:10px auto;}

    button.action-btn{background:linear-gradient(180deg,#333,#111);color:#fff;border:1px solid #555;border-radius:8px;padding:15px 5px;font-size:1.1em;font-weight:bold;text-transform:uppercase;cursor:pointer;box-shadow:0 4px 0 #000;transition:all .1s;font-family:var(--font-main);display:flex;align-items:center;justify-content:center;min-height:60px;}
    button.action-btn:active{transform:translateY(4px);box-shadow:0 0 0 #000;}
    button.action-btn:disabled{opacity:.5;cursor:not-allowed;filter:grayscale(1);transform:none;box-shadow:none;color:#777;border-color:#333;}

    .btn-spin{background:linear-gradient(180deg,#ffd700,#b8860b);color:#000;border-color:#ffd700;text-shadow:0 1px 0 rgba(255,255,255,.4);font-size:1.3em;}
    .btn-vowel{background:linear-gradient(180deg,#00ffff,#008b8b);color:#000;border-color:#00ffff;}
    .btn-solve{background:linear-gradient(180deg,#ff4444,#8b0000);border-color:#ff4444;width:100%;font-size:1.5em;padding:20px;letter-spacing:2px;}
    .btn-pass{background:#444;color:#aaa;}
    .btn-chat{background:#222;border:1px solid #444;color:#ccc;}

    .board-wrapper{order:2;width:100%;}
    #board-container{display:flex;flex-direction:column;align-items:center;gap:8px;padding:15px;margin:0;min-height:100px;background:rgba(0,50,0,.3);border:2px solid #004400;border-radius:15px;}
    .board-row{display:flex;gap:4px;flex-wrap:wrap;justify-content:center;}
    .tile{width:35px;height:55px;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:1.8em;color:#000;background:#fff;border-radius:4px;box-shadow:2px 2px 5px #000;}
    .tile.empty{background:#003300;border:1px solid #005500;box-shadow:inset 0 0 5px #000;}
    .tile.revealed{background:#fff;animation:popIn .3s cubic-bezier(.175,.885,.32,1.275);}
    .tile.cursor-word{outline:3px solid var(--col-neon);box-shadow:0 0 15px var(--col-neon);}
    .tile.cursor-char{border:4px solid var(--col-accent);transform:scale(1.1);z-index:20;}

    @keyframes popIn{from{transform:scale(0);}to{transform:scale(1);}}

    #accessible-board-container{display:none;width:98%;margin:0 auto;text-align:left;}
    #acc-board-summary{background:#111;color:#aaa;padding:10px;margin-bottom:10px;border:1px solid #333;border-radius:8px;font-size:1em;}
    #acc-word-list{display:flex;flex-direction:column;gap:5px;}
    .acc-word-btn{display:flex;justify-content:space-between;width:100%;background:#222;border:1px solid #555;color:#fff;padding:15px;margin-bottom:8px;border-radius:8px;font-size:1.3em;font-family:monospace;letter-spacing:1px;cursor:pointer;}
    body.accessible-mode #board-container{display:none;}
    body.accessible-mode #accessible-board-container{display:block;}

    #wheel-visual-wrap{width:100%;display:flex;flex-direction:column;align-items:center;gap:8px;margin:8px 0;}
    #wheel-visual{
      width:220px;height:220px;border-radius:50%;
      border:4px solid #111;box-shadow:0 0 25px rgba(255,215,0,.15), inset 0 0 10px rgba(0,0,0,.8);
      background:conic-gradient(#ffd700 0deg 30deg,#00ffff 30deg 60deg,#ff4444 60deg 90deg,#00ff00 90deg 120deg,#ffd700 120deg 150deg,#00ffff 150deg 180deg,#ff4444 180deg 210deg,#00ff00 210deg 240deg,#ffd700 240deg 270deg,#00ffff 270deg 300deg,#ff4444 300deg 330deg,#00ff00 330deg 360deg);
      transition:transform 3s cubic-bezier(.12,.75,.2,1);
    }
    #wheel-pointer{width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:18px solid var(--col-accent);filter:drop-shadow(0 0 6px rgba(255,215,0,.6));margin-bottom:-6px;}

    #audio-panel{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;align-items:center;background:#222;border-top:2px solid #333;padding:15px;width:100%;position: relative; margin-top: 40px;}
    #audio-panel button{min-height:auto;padding:10px 12px;border-radius:10px;font-size:1.1em;}
    #audio-panel .mutebtn{border-color:#777;background:#222;color:#ddd;}
    #audio-panel .label{color:#777;font-size:.85em;margin-right:6px;}

    #input-area, #privacy-dialog, #chat-overlay, #player-check-overlay, #round-over-panel, #end-panel, #pause-panel, #help-panel, #players-panel, #action-history-panel, #mystery-choice-overlay, #word-inspector-overlay {
      position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important;
      width: 100vw !important; height: 100vh !important; background: rgba(0,0,0,0.96) !important; z-index: 9999 !important;
      display: flex; flex-direction: column; justify-content: center; align-items: center; overflow-y: hidden; backdrop-filter: blur(5px);
    }
    .modal-content{background:#222;border:2px solid var(--col-neon);padding:20px;width:90%;max-width:500px;max-height: 90vh; overflow-y: auto; border-radius:15px;text-align:center;box-shadow:0 0 30px rgba(0,255,255,.2);}
    .inspector-tile{width:50px;height:70px;display:flex;align-items:center;justify-content:center;font-size:2em;font-weight:bold;background:#fff;color:#000;border-radius:8px;box-shadow:0 4px 8px rgba(0,0,0,.5);}
    .inspector-tile.empty{background:#333;color:#777;}
    .inspector-char-btn{display:flex;flex-direction:column;align-items:center;gap:5px;padding:15px;background:#222;border:2px solid #555;border-radius:8px;cursor:pointer;transition:all .2s;}
    .inspector-char-btn:hover,.inspector-char-btn:focus{background:#333;border-color:var(--col-neon);transform:scale(1.05);}
    input[type=text]{font-size:2em;padding:10px;text-align:center;width:90%;background:#000;color:#fff;border:2px solid #555;border-radius:8px;margin-bottom:20px;font-family:var(--font-main);text-transform:uppercase;}
    .history-item{display:block;width:100%;text-align:left;background:#111;color:#ddd;border:1px solid #333;border-radius:10px;padding:10px;margin:8px 0;font-size:1.05em;}
    .history-item strong{color:var(--col-accent);}

    @media (min-width:769px){
      .tile{width:50px;height:75px;font-size:2.5em;}
      .controls-grid{grid-template-columns:repeat(4,1fr);}
      button.action-btn{font-size:1.2em;}
    }
  </style>
</head>
<body>
  <div id="sr-announcer" class="sr-only" aria-live="assertive"></div>
  <div id="sr-chat" class="sr-only" aria-live="polite"></div>
  <div id="flash-overlay" aria-hidden="true" style="position:fixed;top:20%;left:50%;transform:translate(-50%,-50%);font-size:2em;font-weight:bold;color:#fff;background:#000;padding:20px;border:3px solid #fff;opacity:0;pointer-events:none;transition:opacity .3s;z-index:5000;"><p id="flash-message"></p></div>

  <div style="display:flex; justify-content:space-between; width:95%; max-width:900px; margin:10px auto;">
    <button onclick="toggleContrast()" style="background:transparent; border:1px solid #555; color:#888; padding:5px 10px; border-radius:5px; font-size:0.8em;">Contrasto</button>
    <button onclick="toggleAccessibleMode()" id="btn-acc-mode" style="background:transparent; border:1px solid #555; color:#fff; font-weight:bold; padding:5px 10px; border-radius:5px; font-size:0.8em;" aria-pressed="false">VISTA TESTO</button>
    <button onclick="openHelp()" style="background:transparent; border:1px solid #555; color:#888; padding:5px 10px; border-radius:5px; font-size:0.8em;" aria-label="Aiuto tasti rapidi (H)">Aiuto (H)</button>
    <button onclick="openActionHistory(true)" style="background:transparent; border:1px solid #555; color:#888; padding:5px 10px; border-radius:5px; font-size:0.8em;">Storico (A)</button>
  </div>

  <audio id="snd-spin" src="ruota.wav"></audio>
  <audio id="snd-hit" src="lettera presente.wav"></audio>
  <audio id="snd-miss" src="lettera assente.wav"></audio>
  <audio id="snd-turn" src="tocca_a_te.mp3"></audio>
  <audio id="snd-bankrupt" src="bancarotta.mp3"></audio>
  <audio id="snd-win" src="vittoria.mp3"></audio>
  <audio id="snd-clap" src="applausi.mp3"></audio>
  <audio id="snd-laugh" src="risata.mp3"></audio>
  <audio id="snd-boo" src="buuu.mp3"></audio>
  <audio id="snd-ooh" src="peccato.mp3"></audio>

  <div id="setup-panel" class="container">
    <h1 style="color:var(--col-accent); font-size:3em; margin-bottom:10px; text-shadow:0 0 20px rgba(255,215,0,0.3);">LA RUOTA</h1>
    <input id="inp-name" type="text" placeholder="NOME GIOCATORE"><br>
    <input id="inp-code" type="text" placeholder="CODICE STANZA (OPZ)"><br>
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; width:100%;">
      <button id="btn-create-room" class="action-btn btn-spin">CREA NUOVA</button>
      <button id="btn-join-room" class="action-btn btn-vowel">ENTRA</button>
    </div>
    <div id="public-rooms-container" style="width:100%; margin-top:30px;">
      <button id="btn-refresh-rooms" class="action-btn" style="padding:10px;">AGGIORNA LISTA STANZE</button>
      <div id="rooms-list" style="width:100%; padding:10px; color:#aaa;"></div>
    </div>
  </div>

  <div id="pause-panel" class="hidden" role="alert">
    <div class="modal-content">
      <h1 style="color:red; font-size:3em;">PAUSA</h1>
      <p>GIOCO SOSPESO DALL'HOST</p>
      <button id="btn-resume-host" onclick="preResumeCheck()" class="action-btn btn-spin hidden" style="margin-top:20px;">RIPRENDI (HOST)</button>
    </div>
  </div>

  <div id="game-panel" class="container hidden">
    <div class="info-bar">
      <div id="timer-box" role="timer" aria-label="Tempo rimanente" class="timer-display">240</div>
      <div class="stats-display">
        <span id="round-indicator" style="color:#aaa;">R 1/10</span><br>
        <span id="turn-indicator" style="color:var(--col-green); font-weight:bold;">...</span>
      </div>
    </div>
    <div class="money-box">
      <span>GIRO: <span id="score-round" style="color:#fff;">0</span>€</span>
      <span>TOT: <span id="score-total" style="color:#fff;">0</span>€</span>
    </div>

    <div class="category-box">
      <h2 id="live-category" aria-live="polite">...</h2>
      <h3 id="round-hint" aria-live="polite"></h3>
      <div id="jolly-indicator" class="hidden" style="color:#ff00ff; font-weight:bold; margin-top:5px; font-size:1.1em; text-shadow:0 0 5px #ff00ff;"></div>
      <div id="double-indicator" class="hidden" style="color:orange; font-weight:bold; margin-top:5px; font-size:1.1em; text-shadow:0 0 5px red; border:1px solid red; padding:2px;">RADDOPPIA ATTIVO! GIRA ANCORA!</div>
      <div id="special-round-indicator" class="hidden" style="color:cyan; font-weight:bold; margin-top:5px; font-size:1.1em; text-shadow:0 0 5px cyan; border:1px solid cyan; padding:5px; border-radius:5px;"></div>
    
    <div class="acc-nav" role="navigation" aria-label="Salti rapidi">
      <button class="action-btn" onclick="jumpToSection('hdr-actions')">VAI AI COMANDI</button>
      <button class="action-btn" onclick="jumpToSection('hdr-board')">VAI AL TABELLONE</button>
      <button class="action-btn" onclick="jumpToSection('hdr-finish')">VAI A RISOLVI / INFO</button>
    </div>
</div>

    <h3 id="hdr-actions" class="section-header" tabindex="-1">AZIONI DI GIOCO</h3>
    <div class="top-controls-wrapper">
      <div class="controls-grid">
        <button id="btn-spin" class="action-btn btn-spin" onclick="doSpin()">GIRA</button>
        <button id="btn-vowel" class="action-btn btn-vowel" onclick="openInput('vowel')">VOCALE</button>
        <button id="btn-pass" class="action-btn btn-pass" onclick="passTurn()">PASSA</button>
        <button id="btn-inspect-word" class="action-btn" style="border-color:#555;background:#222;" onclick="openWordInspector()">ISPEZIONA PAROLA</button>
        <button id="btn-letters" class="action-btn" onclick="readRevealedLetters()" style="border-color:#aaa; background:#111; font-size:0.9em;">LETTERE USCITE</button>
      </div>
    </div>

    <h3 id="hdr-wheel" class="section-header" tabindex="-1">RUOTA</h3>
    <div id="wheel-visual-wrap" aria-label="Ruota visuale">
      <div id="wheel-pointer" aria-hidden="true"></div>
      <div id="wheel-visual" aria-hidden="true"></div>
    </div>
    <div id="wheel-status-text" tabindex="-1" style="font-size:1.2em;font-weight:bold;color:var(--col-green);margin:5px;"></div>

    <h2 class="section-header" id="board-section" tabindex="-1">Tabellone</h2>
    <div class="board-wrapper">
      <div id="board-container" role="grid" aria-label="Tabellone di gioco"></div>
    </div>
    <div id="accessible-board-container" aria-label="Tabellone testuale">
      <div id="acc-board-summary"></div>
      <div id="acc-word-list"></div>
    </div>

    <h3 id="hdr-finish" class="section-header" tabindex="-1">CONCLUDI E INFO</h3>
    <div class="bottom-controls-wrapper">
      <button id="btn-solve" class="action-btn btn-solve" onclick="openInput('solve')">RISOLVI FRASE</button>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px; margin-top:10px;">
        <button id="btn-chat" class="action-btn btn-chat" onclick="openChat()" style="font-size:0.8em; padding:10px;">CHAT (K)</button>
        <button id="btn-management" class="action-btn" onclick="openPlayersPanel()" style="font-size:0.8em; padding:10px; background:#222;">CLASSIFICA (S)</button>
      </div>
      <button id="btn-manual-cons" class="action-btn full-width hidden" style="background:var(--col-green); color:#000; margin-top:10px;" onclick="openInput('letter')">DI UNA CONSONANTE</button>
    </div>

    <button onclick="leaveGame()" style="background:transparent; border:none; color:#555; margin-top:30px; cursor:pointer;">ESCI</button>

    <div id="audio-panel">
      <span class="label">AUDIO:</span>
      <button class="action-btn" onclick="playAudio('snd-clap')" aria-label="Applauso">APPLAUSO</button>
      <button class="action-btn" onclick="playAudio('snd-laugh')" aria-label="Risata">RISATA</button>
      <button class="action-btn" onclick="playAudio('snd-boo')" aria-label="Buuu">BUUU</button>
      <button class="action-btn" onclick="playAudio('snd-ooh')" aria-label="Ohhh">OHHH</button>
      <button id="btn-mute" class="action-btn mutebtn" onclick="toggleMute()">AUDIO ON</button>
    </div>
  </div>

  <div id="input-area" class="hidden">
    <div class="modal-content">
      <h2 id="input-title" style="color:var(--col-accent);">INSERISCI</h2>
      <input id="game-input" type="text" autocomplete="off">
      <div class="controls-grid" style="grid-template-columns:1fr 1fr;">
        <button onclick="submitInput()" class="action-btn btn-spin">OK</button>
        <button onclick="closeInput()" class="action-btn btn-pass">ANNULLA</button>
      </div>
    </div>
  </div>

  <div id="chat-overlay" class="hidden" role="dialog" aria-modal="true" aria-label="Finestra Chat">
    <div class="modal-content" style="height:80%; max-width:600px; display:flex; flex-direction:column;">
      <h2 style="color:var(--col-neon);">CHAT</h2>
      <div id="chat-messages" tabindex="0" role="log" aria-live="polite" style="flex:1; overflow-y:auto; text-align:left; border:1px solid #444; padding:10px; margin-bottom:10px; background:#000; color:#ddd;"></div>
      <input id="chat-input" type="text" placeholder="Messaggio..." style="font-size:1.2em; width:95%; margin-bottom:10px;">
      <div style="display:flex; gap:10px; width:100%;">
        <button onclick="sendChatMessage()" class="action-btn btn-vowel" style="flex:1;">INVIA</button>
        <button onclick="document.getElementById('chat-overlay').classList.add('hidden')" class="action-btn btn-pass" style="flex:1;">CHIUDI</button>
      </div>
    </div>
  </div>

  <div id="help-panel" class="hidden" role="dialog">
    <div class="modal-content" style="max-width:700px; text-align:left;">
      <h2 style="color:var(--col-neon);">TASTI RAPIDI</h2>
      <ul style="line-height:1.8; color:#ddd;">
        <li><strong>G</strong> o <strong>Ctrl+G</strong>: Gira la ruota</li>
        <li><strong>V</strong> o <strong>Ctrl+V</strong>: Compra vocale</li>
        <li><strong>R</strong> o <strong>Ctrl+R</strong>: Risolvi</li>
        <li><strong>P</strong> o <strong>Ctrl+P</strong>: Passa</li>
        <li><strong>T</strong> o <strong>Ctrl+T</strong>: Di chi è il turno</li>
        <li><strong>K</strong> o <strong>Ctrl+K</strong>: Chat</li>
        <li><strong>S</strong> o <strong>Ctrl+S</strong>: Controlli e Classifica</li>
        <li><strong>L</strong> o <strong>Ctrl+L</strong>: Lettere uscite</li>
        <li><strong>A</strong> o <strong>Ctrl+A</strong>: Storico azioni</li>
        <li><strong>B</strong> o <strong>Ctrl+B</strong>: Aggiungi Bot veloce (Solo Host)</li>
        <li><strong>H</strong> o <strong>Ctrl+H</strong>: Aiuto</li>
        <li><strong>ESC</strong>: Chiudi finestre</li>
      </ul>
      <button onclick="closeHelp()" class="action-btn full-width">CHIUDI (ESC)</button>
    </div>
  </div>

  <div id="players-panel" class="hidden" role="dialog">
    <div class="modal-content" style="max-width:700px; text-align:left;">
      <h2 style="color:var(--col-neon);">GIOCATORI E CLASSIFICA</h2>
      <div id="players-list" style="margin:20px 0;"></div>
      <button onclick="closePlayers()" class="action-btn full-width">CHIUDI (ESC)</button>
    </div>
  </div>

  <div id="action-history-panel" class="hidden" role="dialog" aria-label="Storico azioni">
    <div class="modal-content" style="max-width:700px; text-align:left;">
      <h2 style="color:var(--col-neon);">STORICO</h2>
      <div id="action-history-list" style="max-height:420px; overflow-y:auto;"></div>
      <button onclick="closeActionHistory()" class="action-btn full-width" style="margin-top:10px;">CHIUDI</button>
    </div>
  </div>

  <div id="mystery-choice-overlay" class="hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <h2 id="mystery-title" style="color:var(--col-neon);">MISTERO</h2>
      <p id="mystery-desc" style="color:#ddd; font-size:1.1em; line-height:1.4;">
        Vuoi aprire il Mistero oppure prendere <strong>500€</strong> in palio?
      </p>
      <div style="display:grid; grid-template-columns:1fr; gap:10px; margin-top:15px;">
        <button id="btn-mystery-open" class="action-btn btn-spin" onclick="chooseMystery(true)">APRI IL MISTERO</button>
        <button id="btn-mystery-500" class="action-btn btn-vowel" onclick="chooseMystery(false)">PRENDI 500€ IN PALIO</button>
      </div>
      <button onclick="chooseMystery(false)" style="margin-top:10px; background:none; border:none; color:#aaa;">ANNULLA (ESC)</button>
    </div>
  </div>

  <div id="word-inspector-overlay" class="hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <h2 id="inspector-title" style="color:var(--col-neon);">ISPEZIONA PAROLA</h2>
      <div id="inspector-letters-container" style="margin:20px 0;"></div>
      <button onclick="closeWordInspector()" class="action-btn full-width">CHIUDI (ESC)</button>
    </div>
  </div>

  <div id="player-check-overlay" class="hidden" role="dialog" aria-modal="true" aria-label="Appello presenze">
    <div class="modal-content">
      <h2 style="color:orange;">APPELLO PRESENZE</h2>
      <p style="color:#ddd; line-height:1.4;">Controlla chi risulta in stanza.</p>
      <div id="player-check-list" style="text-align:left; margin:20px 0; max-height:300px; overflow-y:auto;"></div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; width:100%;">
        <button id="btn-confirm-resume" onclick="confirmResumeGame()" class="action-btn btn-spin">RIPRENDI ORA</button>
        <button onclick="closePlayerCheckOverlay()" class="action-btn btn-pass">ASPETTA</button>
      </div>
    </div>
  </div>

  <div id="round-over-panel" class="hidden">
    <div class="modal-content">
      <h2 style="color:var(--col-green);">FINE ROUND</h2>
      <p id="round-winner-msg" style="font-size:1.2em; color:#fff;"></p>
      <p id="solution-msg" style="color:var(--col-accent); font-size:1.5em; font-weight:bold; margin:20px 0;"></p>
      <p>Prossimo round: <span id="next-round-timer">15</span>s</p>
      <button onclick="startNewRound()" id="btn-host-next" class="action-btn btn-spin full-width hidden">AVVIA ORA (HOST)</button>
    </div>
  </div>

  <div id="end-panel" class="hidden">
    <div class="modal-content">
      <h2 style="color:var(--col-accent);">CLASSIFICA FINALE</h2>
      <ul id="ranking-list" style="list-style:none; padding:0; text-align:left;"></ul>
      <button id="btn-new-game" onclick="resetGame()" class="action-btn btn-spin full-width hidden" style="margin:10px 0;">NUOVA PARTITA (HOST)</button>
      <button onclick="leaveGame()" class="action-btn btn-pass full-width">ESCI</button>
    </div>
  </div>

  <div id="privacy-dialog" class="hidden">
    <div class="modal-content">
      <h2>TIPO STANZA</h2>
      <div style="display:flex; gap:10px;">
        <button onclick="createRoomFinal(true)" class="action-btn btn-vowel" style="flex:1;">PUBBLICA</button>
        <button onclick="createRoomFinal(false)" class="action-btn btn-pass" style="flex:1;">PRIVATA</button>
      </div>
      <button onclick="document.getElementById('privacy-dialog').classList.add('hidden')" style="margin-top:10px; background:none; border:none; color:#aaa;">ANNULLA</button>
    </div>
  </div>

  <script>
    // _supabase già inizializzato all'inizio del documento (riga 11)

    const NATO = {
      'A':'Ancona','B':'Bologna','C':'Como','D':'Domodossola','E':'Empoli','F':'Firenze','G':'Genova','H':'Hotel','I':'Imola',
      'J':'Jolly','K':'Kappa','L':'Livorno','M':'Milano','N':'Napoli','O':'Otranto','P':'Palermo','Q':'Quadro','R':'Roma',
      'S':'Savona','T':'Torino','U':'Udine','V':'Venezia','W':'Washington','X':'Xilofono','Y':'Yogurt','Z':'Zara',
      'À':'A accentata','È':'E aperta','É':'E chiusa','Ì':'I accentata','Ò':'O accentata','Ù':'U accentata',
      "'":"Apostrofo","?":"Punto di domanda","!":"Punto esclamativo",".":"Punto",",":"Virgola"
    };

    const WHEEL_VALUES=[100,200,300,400,500,600,700,800,900,1000,2000,'MISTERO','PASSA','BANCAROTTA','JOLLY'];
    const MISTERO_VALUES=['RADDOPPIA','BANCAROTTA','PASSA','PASSA_AVVERSARIO','+1000','JOLLY'];
    const TURN_LIMIT_SEC=240;
    const MAX_PLAYERS=3;

    let myId, myIndex, roomId, isHost=false;
    let currentFrase=null, currentStanza=null, currentPuzzleText="", currentHintText="", fullSolutionText="";
    let lastTimestamp="", isSpinning=false, inputMode=null, parsedBoard=[];
    let isFetching=false, isProcessingInput=false, isHandlingTimeout=false;
    let vowelsBoughtThisTurn=0, wasMyTurn=false;
    let actionHistory=[];
    let isAccessibleMode=false;
    let speechTimeouts=[];
    let nextRoundInterval=null;
    let isMuted=false;
    let wheelRotation=0;
    let navWordIdx = 0, navCharIdx = 0;
    let lastInputMode = null;
    let spellingTimer = null;
    let nextRoundSec = 15;
    
    let specialPhase = 0; 
    let lastAutoPassTime = 0;
    let isBotThinking = false;
    let previousPlayersList = []; // Traccia giocatori per rilevare entrate/uscite
    
    // VARIABILI ROUND SPECIALI (4, 7, 10)
    let isSpecialRound = false;
    let specialPhraseIndex = 0; // 0-3 (quale delle 4 frasi)
    let specialPhraseIds = []; // Array con gli ID delle 4 frasi
    let specialConsonantsUsed = 0; // Quante consonanti chiamate (max 12)
    let specialVowelsPhase = true; // true = fase vocali, false = fase consonanti
    let specialVowelsGiven = 0; // Quante vocali date/chiamate
    let lettersCalledThisRound = []; // Tutte le lettere chiamate nel round (per i bot)
    
    // PROTEZIONE: Impedisce l'accesso diretto dalla console
    // Override console.log per nascondere dati sensibili
    (function(){
      const originalLog = console.log;
      console.log = function(...args){
        const filtered = args.map(arg => {
          if(typeof arg === 'string' && arg.length > 10 && arg === currentPuzzleText) {
            return '[SOLUZIONE NASCOSTA]';
          }
          return arg;
        });
        originalLog.apply(console, filtered);
      };
      
      // Impedisce l'accesso diretto alle variabili dal debugger
      Object.defineProperty(window, 'currentPuzzleText', {
        get: function(){ return '***'; },
        set: function(v){ currentPuzzleText = v; }
      });
      Object.defineProperty(window, 'fullSolutionText', {
        get: function(){ return '***'; },
        set: function(v){ fullSolutionText = v; }
      });
    })(); 

    // FREQUENZA LETTERE (Per AI dei Bot) - Gruppi con frequenza simile
    // Il bot sceglie random all'interno di ogni gruppo per sembrare più umano
    const FREQ_CONS_GROUPS = [
      ['R','T','N'],        // GRUPPO 1: Altissima frequenza
      ['S','L','C'],        // GRUPPO 2: Alta frequenza  
      ['D','P','M'],        // GRUPPO 3: Media frequenza
      ['G','B','F','V']     // GRUPPO 4: Bassa frequenza
    ];
    const FREQ_VOW_GROUPS = [
      ['A','E'],            // Vocali più comuni
      ['I','O'],            // Vocali medie
      ['U']                 // Vocale meno comune
    ];

    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('btn-create-room')?.addEventListener('click', () => askPrivacy());
      document.getElementById('btn-join-room')?.addEventListener('click', () => joinGame(false));
      document.getElementById('btn-refresh-rooms')?.addEventListener('click', () => fetchPublicRooms());

      document.getElementById('game-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            submitInput();
        }
      });
      document.getElementById('chat-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            sendChatMessage();
        }
      });
      
      // GESTIONE LINK CONDIVISI: Leggi l'hash URL
      const hash = window.location.hash;
      if(hash && hash.startsWith('#stanza=')){
        const roomCode = hash.replace('#stanza=', '').toUpperCase();
        if(roomCode){
          // Pre-compila il codice stanza
          document.getElementById('inp-code').value = roomCode;
          speak(`Link rilevato: stanza ${roomCode}. Inserisci il tuo nome e premi Entra.`);
        }
      }
    });

    function clearSpeechQueue(){ speechTimeouts.forEach(t=>clearTimeout(t)); speechTimeouts=[]; }
    function speak(t){
      if(!t) return;
      const e=document.getElementById('sr-announcer'); e.textContent='';
      clearSpeechQueue();
      const timeout=setTimeout(()=>{ e.textContent=t; },50);
      speechTimeouts.push(timeout);
    }
    function speakChat(t){
      if(!t) return;
      const e=document.getElementById('sr-chat'); e.textContent='';
      setTimeout(()=>{ e.textContent=t; },50);
    }
    function playAudio(id){
      if(isMuted) return;
      const a=document.getElementById(id);
      if(a){ a.pause(); a.currentTime=0; a.play().catch(()=>{}); }
    }
    function playMultipleHits(count) {
        let i = 0;
        const interval = setInterval(() => {
            playAudio('snd-hit');
            i++;
            if (i >= count) clearInterval(interval);
        }, 300);
    }
    function toggleMute(){
      isMuted=!isMuted;
      document.getElementById('btn-mute').textContent = isMuted ? 'AUDIO OFF' : 'AUDIO ON';
      speak(isMuted ? "Audio disattivato" : "Audio attivato");
    }
    function cleanStr(s){ return (s && typeof s === 'string') ? s.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/[^a-z0-9]/g,"") : ""; }
    
    // Helper per scegliere lettere in modo umano (randomizza all'interno dei gruppi)
    function getNextConsonantHuman(alreadyRevealed){
      for(let group of FREQ_CONS_GROUPS){
        const shuffled = [...group].sort(() => Math.random() - 0.5);
        for(let c of shuffled){
          if(!alreadyRevealed.includes(c)) return c;
        }
      }
      return null;
    }
    
    function getNextVowelHuman(alreadyRevealed){
      for(let group of FREQ_VOW_GROUPS){
        const shuffled = [...group].sort(() => Math.random() - 0.5);
        for(let v of shuffled){
          if(!alreadyRevealed.includes(v)) return v;
        }
      }
      return null;
    }
    
    function setBtnState(id,d){ const b=document.getElementById(id); if(!b) return; if(d){ b.disabled=true; b.setAttribute('aria-disabled','true'); } else { b.disabled=false; b.setAttribute('aria-disabled','false'); } }
    function isBtnDisabled(id){ const b=document.getElementById(id); return b && b.getAttribute('aria-disabled')==='true'; }
    function showFlashMessage(msg,type){
      const ov=document.getElementById('flash-overlay'),txt=document.getElementById('flash-message');
      txt.textContent=msg; txt.style.color=type==='bad'?'#f00':(type==='good'?'#0f0':'#ffd700');
      ov.style.borderColor=txt.style.color; ov.style.opacity=1; setTimeout(()=>{ ov.style.opacity=0; },4000);
    }

    function jumpToSection(id){
      const el = document.getElementById(id);
      if(!el) return;
      el.scrollIntoView({behavior:'smooth', block:'start'});
      setTimeout(()=>{ try{ el.focus({preventScroll:true}); } catch(e){ try{ el.focus(); }catch(_){ } } }, 250);
    }

    function toggleContrast(){ document.body.classList.toggle('high-contrast'); speak("Contrasto cambiato"); }
    function openHelp(){ document.getElementById('help-panel').classList.remove('hidden'); speak("Aiuto aperto"); }
    function closeHelp(){ document.getElementById('help-panel').classList.add('hidden'); }
    function addActionToHistory(txt){
      actionHistory.unshift({text:txt, time:new Date().toLocaleTimeString()});
      if(actionHistory.length>50) actionHistory.pop();
    }
    function openActionHistory(focusFirst=false){
      document.getElementById('action-history-panel').classList.remove('hidden');
      const c=document.getElementById('action-history-list'); c.innerHTML='';
      if(!actionHistory.length){
        c.innerHTML='<p style="color:#aaa;">Nessuna azione.</p>';
      } else {
        actionHistory.forEach((a, idx)=>{
          const b=document.createElement('button');
          b.className='history-item';
          b.type='button';
          b.dataset.idx=idx;
          b.innerHTML = `<strong>${a.time}</strong> — ${a.text}`;
          b.onclick = ()=> speak(`${a.time}. ${a.text}`);
          c.appendChild(b);
        });
      }
      speak("Storico aperto. Usa freccia su e giù per navigare.");
      if(focusFirst){
        setTimeout(()=>{ const first=c.querySelector('.history-item'); if(first) first.focus(); },60);
      }
    }
    function closeActionHistory(){ document.getElementById('action-history-panel').classList.add('hidden'); }

    let mysteryChoiceResolver = null;
    let isMysteryModalOpen = false;

    function openMysteryModal(){
      if(isMysteryModalOpen) return;
      isMysteryModalOpen = true;
      const ov = document.getElementById('mystery-choice-overlay');
      if(ov) ov.classList.remove('hidden');
      speak("Mistero! Scegli: Apri il mistero, oppure prendi 500 in palio.");
      setTimeout(()=>{ const b=document.getElementById('btn-mystery-open'); if(b) b.focus(); }, 120);
    }
    function closeMysteryModal(){
      isMysteryModalOpen = false;
      const ov = document.getElementById('mystery-choice-overlay');
      if(ov) ov.classList.add('hidden');
    }
    function chooseMystery(openIt){
      const res = mysteryChoiceResolver;
      mysteryChoiceResolver = null;
      closeMysteryModal();
      if(typeof res === 'function') res(!!openIt);
    }
    function askMysteryChoice(){
      return new Promise(resolve=>{
        mysteryChoiceResolver = resolve;
        openMysteryModal();
      });
    }
    const NATO_ALPHABET = {
      'A':'Ancona', 'B':'Bologna', 'C':'Como', 'D':'Domodossola', 'E':'Empoli',
      'F':'Firenze', 'G':'Genova', 'H':'Hotel', 'I':'Imola', 'J':'Jersey',
      'K':'Kappa', 'L':'Livorno', 'M':'Milano', 'N':'Napoli', 'O':'Otranto',
      'P':'Padova', 'Q':'Quarto', 'R':'Roma', 'S':'Savona', 'T':'Torino',
      'U':'Udine', 'V':'Venezia', 'W':'Washington', 'X':'Xilofono', 'Y':'York', 'Z':'Zara'
    };

    async function readRevealedLetters(){
      if(!currentStanza) return;
      let letters=new Set();
      parsedBoard.forEach(w=>w.chars.forEach(c=>{ if(c.isLetter && c.isRevealed) letters.add(c.char); }));
      const list=Array.from(letters).sort();
      
      if(!list.length) {
        speak("Nessuna lettera uscita.");
        return;
      }
      
      // SPELLING con pause 500ms tra lettere
      clearSpeechQueue();
      speak("Lettere uscite:");
      
      for(let i=0; i<list.length; i++){
        await new Promise(r => setTimeout(r, 500));
        const letter = list[i];
        const word = NATO_ALPHABET[letter] || letter;
        speak(`${letter} ${word}`);
      }
    }
    
    function moveWordNav(d) {
      clearSpeechQueue();
      if(spellingTimer) clearTimeout(spellingTimer);
      if(!parsedBoard.length) return;
      let n = navWordIdx + d;
      if(n < 0) n = 0;
      else if(n >= parsedBoard.length) n = parsedBoard.length - 1;
      
      if(n !== navWordIdx) {
        navWordIdx = n;
        navCharIdx = -1;
        highlightNav();
        let w = parsedBoard[n];
        if(!w) return; 
        let letterCount = w.chars.length;
        let spelling = "";
        w.chars.forEach(c => {
          if(c.isLetter && !c.isRevealed) spelling += " asterisco";
          else spelling += " " + (c.char ? c.char.toLowerCase() : "");
        });
        speak(`Parola ${n + 1}, ${letterCount} lettere.${spelling}`);
      }
    }

    function moveNav(d) {
      clearSpeechQueue();
      if(spellingTimer) clearTimeout(spellingTimer);
      if(!parsedBoard.length) return;
      let currentW = parsedBoard[navWordIdx];
      if(!currentW) return; 
      let newCharIdx = navCharIdx + d;
      if(newCharIdx < -1) { speak("Inizio parola"); return; }
      if(newCharIdx >= currentW.chars.length) { speak("Fine parola"); return; }
      if(newCharIdx === -1) { navCharIdx = -1; highlightNav(); speak("Inizio parola"); return; }
      navCharIdx = newCharIdx;
      highlightNav();
      readSingleChar();
    }

    function highlightNav() {
      document.querySelectorAll('.cursor-char').forEach(e => e.classList.remove('cursor-char'));
      document.querySelectorAll('.cursor-word').forEach(e => e.classList.remove('cursor-word'));
      document.getElementById(`row-${navWordIdx}`)?.classList.add('cursor-word');
      if(navCharIdx >= 0) {
        document.getElementById(`tile-${navWordIdx}-${navCharIdx}`)?.classList.add('cursor-char');
      }
    }

    function readSingleChar() {
      if(!parsedBoard[navWordIdx]) return;
      const c = parsedBoard[navWordIdx].chars[navCharIdx];
      if(!c) return;
      
      // Conta quante lettere totali nella parola
      const totalLetters = parsedBoard[navWordIdx].chars.length;
      const position = navCharIdx + 1; // +1 perché parte da 0
      
      const charText = c.isLetter && !c.isRevealed ? "Asterisco" : (NATO[c.char] || c.char);
      speak(`${charText}, ${position} di ${totalLetters}`);
    }

    function openWordInspector() {
      if(!parsedBoard.length) return speak("Nessuna parola.");
      const w = parsedBoard[navWordIdx];
      if(!w) return;
      const cont = document.getElementById('inspector-letters-container');
      cont.innerHTML = "";
      w.chars.forEach((c, idx) => {
        const btn = document.createElement('div');
        btn.className = 'inspector-char-btn';
        btn.setAttribute('role', 'button');
        btn.setAttribute('tabindex', '0');
        let visualChar = (c.isLetter && !c.isRevealed) ? "_" : c.char;
        let spelling = "";
        if(!c.isLetter) spelling = (NATO[c.char] || c.char);
        else if(!c.isRevealed) spelling = `Nascosta`;
        else spelling = `${c.char}, ${NATO[c.char] || ''}`;
        
        btn.innerHTML = `<span>Lettera ${idx + 1}</span> <strong>${visualChar}</strong>`;
        btn.onclick = () => speak(spelling);
        btn.onkeydown = (e) => {
          if(e.key === 'Enter' || e.key === ' ') speak(spelling);
        };
        cont.appendChild(btn);
      });
      document.getElementById('word-inspector-overlay').classList.remove('hidden');
      setTimeout(() => { const first = cont.querySelector('.inspector-char-btn'); if(first) first.focus(); }, 100);
      speak(`Dettaglio parola ${navWordIdx + 1}. Usa tab per scorrere le lettere.`);
    }

    function closeWordInspector() {
      document.getElementById('word-inspector-overlay').classList.add('hidden');
      document.getElementById('btn-inspect-word').focus();
    }

    function reopenLastInput() {
      if(lastInputMode && !inputMode) {
        const typeMsg = lastInputMode === 'vowel' ? "vocale" : lastInputMode === 'letter' ? "consonante" : "soluzione";
        openInput(lastInputMode);
        speak(`Campo ${typeMsg} riaperto.`);
      }
    }

    async function togglePause() {
      if(!isHost) return;
      const newState = !currentStanza.in_pausa;
      await _supabase.from('stanze').update({in_pausa: newState, ultimo_messaggio: newState ? "GIOCO IN PAUSA" : "GIOCO RIPRESO", azione_timestamp: new Date().toISOString()}).eq('id', roomId);
      fetchFullState();
    }

    async function preResumeCheck() {
      if(!isHost) return;
      
      // Prima rimuovi automaticamente i giocatori disconnessi
      await checkAndRemoveDisconnectedPlayers();
      
      const { data: pl } = await _supabase.from('giocatori').select('*').eq('stanza_id', roomId).order('indice');
      const listDiv = document.getElementById('player-check-list');
      listDiv.innerHTML = "";
      pl.forEach(p => {
        const row = document.createElement('div');
        row.style = "display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid #555;padding:10px;";
        
        // Calcola da quanto tempo non fa ping
        const lastPing = p.ultimo_ping ? new Date(p.ultimo_ping) : null;
        const now = new Date();
        const secondsSinceLastPing = lastPing ? Math.floor((now - lastPing) / 1000) : 9999;
        const statusColor = secondsSinceLastPing > 15 ? '#ff4444' : '#00ff00';
        const statusText = secondsSinceLastPing > 15 ? '⚠️ OFFLINE' : '✅ ONLINE';
        
        row.innerHTML = `<span style="font-size:1.2em;color:#fff;">${p.nome} <span style="color:${statusColor};font-size:0.85em;">${statusText}</span></span>`;
        const delBtn = document.createElement('button');
        delBtn.textContent = "ELIMINA";
        delBtn.className = "action-btn";
        delBtn.style = "padding:8px 15px;font-size:.9em;background:red;border:none;min-height:auto;";
        delBtn.onclick = async () => {
          if(confirm("Eliminare " + p.nome + "?")) {
            await _supabase.from('giocatori').delete().eq('id', p.id);
            row.remove();
            speak(`${p.nome} eliminato`);
          }
        };
        row.appendChild(delBtn);
        listDiv.appendChild(row);
      });
      document.getElementById('player-check-overlay').classList.remove('hidden');
      speak("Controllo presenze. I giocatori offline sono stati rimossi automaticamente. Verifica e conferma.");
      setTimeout(() => document.getElementById('btn-confirm-resume').focus(), 150);
    }
    
    async function checkAndRemoveDisconnectedPlayers() {
      if(!isHost || !roomId) return;
      
      const { data: players } = await _supabase.from('giocatori').select('*').eq('stanza_id', roomId);
      if(!players || players.length === 0) return;
      
      const now = new Date();
      const TIMEOUT_SECONDS = 15; // Considera disconnesso dopo 15 secondi
      
      for(const player of players) {
        const lastPing = player.ultimo_ping ? new Date(player.ultimo_ping) : null;
        const secondsSinceLastPing = lastPing ? Math.floor((now - lastPing) / 1000) : 9999;
        
        // Se il giocatore non fa ping da più di TIMEOUT_SECONDS, rimuovilo
        if(secondsSinceLastPing > TIMEOUT_SECONDS) {
          console.log(`[DISCONNECT] Rimuovo ${player.nome} - ultimo ping ${secondsSinceLastPing}s fa`);
          await _supabase.from('giocatori').delete().eq('id', player.id);
          showFlashMessage(`⚠️ ${player.nome} disconnesso e rimosso`, 'bad');
          speak(`${player.nome} si è disconnesso`);
        }
      }
    }

    async function confirmResumeGame() {
      document.getElementById('player-check-overlay').classList.add('hidden');
      await togglePause();
    }

    function closePlayerCheckOverlay(){
      document.getElementById('player-check-overlay').classList.add('hidden');
      speak("Rimaniamo in pausa.");
    }

    function announceTurn(){
      if(!currentStanza) return;
      const currentPlayer = currentStanza.giocatori.find(p=>p.indice===currentStanza.id_giocatore_corrente);
      const isMe = (currentStanza.id_giocatore_corrente === myIndex);
      const turnMsg = isMe ? "È il tuo turno!" : `Turno di ${currentPlayer?.nome || 'sconosciuto'}`;
      
      // Calcola statistiche tabellone
      let totalWords = parsedBoard.length;
      let totalLetters = 0;
      let revealedLetters = 0;
      
      parsedBoard.forEach(w => {
        w.chars.forEach(c => {
          if(c.isLetter){
            totalLetters++;
            if(c.isRevealed) revealedLetters++;
          }
        });
      });
      
      const boardMsg = `Tabellone: ${totalWords} parole, ${totalLetters} lettere totali, ${revealedLetters} scoperte.`;
      
      speak(`${turnMsg} ${boardMsg}`);
    }

    async function openPlayersPanel(){
      const panel = document.getElementById('players-panel');
      panel.classList.remove('hidden');
      
      const list = document.getElementById('players-list');
      list.innerHTML = '<p style="color:#888; text-align:center; padding:20px;">Caricamento...</p>';
      
      // RICARICA dati freschi dal database
      if(roomId){
        const {data: freshStanza} = await _supabase.from('stanze').select('*, giocatori(*)').eq('id', roomId).maybeSingle();
        if(freshStanza && freshStanza.giocatori && freshStanza.giocatori.length > 0){
          list.innerHTML = '<h3 style="color:var(--col-accent); margin-bottom:15px;">CLASSIFICA</h3>';
          
          // Classifica ordinata per punteggio
          const sorted = [...freshStanza.giocatori].sort((a,b) => (b.punteggio_totale||0) - (a.punteggio_totale||0));
          sorted.forEach((p, i) => {
            const div = document.createElement('div');
            div.style = 'background:#111; border:1px solid #333; padding:15px; margin:15px 0; border-radius:8px; display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:10px;';
            
            const info = document.createElement('span');
            info.style = 'color:#ddd; font-size:1.1em; flex:1; min-width:200px;';
            info.innerHTML = `<strong style="color:var(--col-accent);">${i+1}.</strong> ${p.nome} - <strong>${p.punteggio_totale||0}€</strong> (Giro: ${p.punteggio_round||0}€)`;
            div.appendChild(info);
            
            // PULSANTI HOST (solo per host e non per se stesso)
            if(isHost && p.id !== myId){
              const btnContainer = document.createElement('div');
              btnContainer.style = 'display:flex; gap:5px; flex-wrap:wrap;';
              
              // Pulsante PASSA HOST
              const btnHost = document.createElement('button');
              btnHost.textContent = 'PASSA HOST';
              btnHost.className = 'action-btn';
              btnHost.style = 'padding:8px 12px; font-size:0.9em; background:#1a5490; border-color:#4a90e2; min-height:auto;';
              btnHost.onclick = () => transferHost(p.id, p.nome);
              btnContainer.appendChild(btnHost);
              
              // Pulsante ELIMINA
              const btnDel = document.createElement('button');
              btnDel.textContent = 'ELIMINA';
              btnDel.className = 'action-btn';
              btnDel.style = 'padding:8px 12px; font-size:0.9em; background:#8b0000; border-color:#ff0000; min-height:auto;';
              btnDel.onclick = () => removePlayer(p.id, p.nome);
              btnContainer.appendChild(btnDel);
              
              div.appendChild(btnContainer);
            }
            
            list.appendChild(div);
          });
          
          speak("Pannello giocatori aperto");
          
          // CONTROLLI HOST (se sei host)
          if(isHost){
            const hostControls = document.createElement('div');
            hostControls.style = 'margin-top:25px; padding-top:20px; border-top:2px solid #444;';
            hostControls.innerHTML = '<h3 style="color:#888; margin-bottom:15px; text-transform:uppercase;">CONTROLLI HOST</h3>';
            
            const controlsGrid = document.createElement('div');
            controlsGrid.style = 'display:grid; grid-template-columns:1fr 1fr; gap:10px;';
            
            // Pulsante CONDIVIDI LINK
            const btnShare = document.createElement('button');
            btnShare.textContent = 'CONDIVIDI LINK';
            btnShare.className = 'action-btn';
            btnShare.style = 'padding:12px; font-size:1em; background:#1a5490; border-color:#4a90e2; min-height:auto;';
            btnShare.onclick = shareRoom;
            controlsGrid.appendChild(btnShare);
            
            // Pulsante AGGIUNGI BOT
            const btnBot = document.createElement('button');
            btnBot.textContent = 'AGGIUNGI BOT (B)';
            btnBot.className = 'action-btn';
            btnBot.style = 'padding:12px; font-size:1em; background:#1a1a5a; border-color:cyan; color:cyan; min-height:auto;';
            btnBot.onclick = () => { addBot(); closePlayers(); };
            controlsGrid.appendChild(btnBot);
            
            // Pulsante PAUSA
            const btnPause = document.createElement('button');
            btnPause.textContent = 'PAUSA';
            btnPause.className = 'action-btn';
            btnPause.style = 'padding:12px; font-size:1em; background:#5a3a1a; border-color:orange; min-height:auto;';
            btnPause.onclick = () => { togglePause(); closePlayers(); };
            controlsGrid.appendChild(btnPause);
            
            // Pulsante RESET
            const btnReset = document.createElement('button');
            btnReset.textContent = 'RESET PARTITA';
            btnReset.className = 'action-btn';
            btnReset.style = 'padding:12px; font-size:1em; background:#1a1a5a; border-color:blue; min-height:auto;';
            btnReset.onclick = () => { resetGame(); closePlayers(); };
            controlsGrid.appendChild(btnReset);
            
            // Pulsante CHIUDI STANZA
            const btnClose = document.createElement('button');
            btnClose.textContent = 'CHIUDI STANZA';
            btnClose.className = 'action-btn';
            btnClose.style = 'padding:12px; font-size:1em; background:#5a1a1a; border-color:red; min-height:auto;';
            btnClose.onclick = closeRoom;
            controlsGrid.appendChild(btnClose);
            
            hostControls.appendChild(controlsGrid);
            list.appendChild(hostControls);
          }
          
          // FOCUS automatico sul primo pulsante (elimina o chiudi)
          setTimeout(() => {
            const firstBtn = list.querySelector('button') || panel.querySelector('button');
            if(firstBtn) firstBtn.focus();
          }, 100);
          
        } else {
          list.innerHTML = '<p style="color:#888; text-align:center; padding:20px;">Nessun giocatore presente.</p>';
          speak("Nessun giocatore");
        }
      } else {
        list.innerHTML = '<p style="color:#888; text-align:center; padding:20px;">Nessuna partita attiva.</p>';
        speak("Nessuna partita attiva");
      }
    }

    function closePlayers(){
      document.getElementById('players-panel').classList.add('hidden');
    }

    async function removePlayer(playerId, playerName){
      if(!isHost) return;
      if(!confirm(`Eliminare ${playerName}?`)) return;
      
      // Elimina il giocatore
      await _supabase.from('giocatori').delete().eq('id', playerId);
      
      // Resetta gli indici per evitare problemi di turno
      const {data: remainingPlayers} = await _supabase.from('giocatori').select('*').eq('stanza_id', roomId).order('indice');
      if(remainingPlayers && remainingPlayers.length > 0){
        for(let i=0; i<remainingPlayers.length; i++){
          await _supabase.from('giocatori').update({indice: i}).eq('id', remainingPlayers[i].id);
        }
        // Resetta anche il turno al primo giocatore
        await _supabase.from('stanze').update({id_giocatore_corrente: 0}).eq('id', roomId);
      }
      
      speak(`${playerName} eliminato. Turni resettati.`);
      closePlayers();
      
      // FORZA il refresh immediato dello stato
      await fetchFullState();
    }

    async function transferHost(newHostId, newHostName){
      if(!isHost) return;
      if(!confirm(`Passare il controllo della stanza a ${newHostName}?`)) return;
      
      // Rimuovi host dal vecchio host (te)
      await _supabase.from('giocatori').update({is_host: false}).eq('id', myId);
      
      // Dai host al nuovo giocatore
      await _supabase.from('giocatori').update({is_host: true}).eq('id', newHostId);
      
      // Aggiorna la variabile locale
      isHost = false;
      
      speak(`${newHostName} è ora l'host della stanza.`);
      closePlayers();
      
      // FORZA il refresh immediato dello stato
      await fetchFullState();
    }

    async function shareRoom(){
      if(!currentStanza) return;
      
      const roomCode = currentStanza.codice;
      const shareUrl = `${window.location.origin}${window.location.pathname}#stanza=${roomCode}`;
      
      // Controlla se ha l'API di condivisione nativa (smartphone)
      if(navigator.share){
        // SMARTPHONE: usa solo condivisione nativa
        try {
          await navigator.share({
            title: 'La Ruota - Unisciti alla partita!',
            text: `Entra nella stanza "${roomCode}"`,
            url: shareUrl
          });
          speak("Link condiviso");
        } catch(e){
          // Utente ha annullato, va bene
          if(e.name !== 'AbortError') {
            speak("Condivisione annullata");
          }
        }
      } else {
        // PC: copia negli appunti
        try {
          await navigator.clipboard.writeText(shareUrl);
          speak("Link copiato negli appunti!");
          alert(`Link della stanza copiato!\n\n${shareUrl}\n\nCondividilo con altri giocatori.`);
        } catch(e){
          // Fallback: mostra il link in un prompt
          speak("Copia questo link");
          prompt("Copia questo link per condividere la stanza:", shareUrl);
        }
      }
    }

    function readAllScores(){
      if(!currentStanza) return;
      let txt="Classifica: ";
      currentStanza.giocatori.forEach(p=> txt += `${p.nome} ${p.punteggio_totale}, `);
      speak(txt);
    }

    function parseAndRenderBoard(text, rev) {
      rev = Array.isArray(rev) ? rev : [];
      navWordIdx = 0; navCharIdx = -1;
      const c = document.getElementById('board-container');
      c.innerHTML = '';
      parsedBoard = [];
      let gI = 0;
      let totalLetters = 0;
      let revealedLetters = 0;
      if(!text) return; 

      text.toUpperCase().split(' ').forEach(wS => {
        let wO = { str: wS, chars: [] };
        const r = document.createElement('div');
        r.className = 'board-row';
        r.id = `row-${parsedBoard.length}`;
        r.setAttribute('role', 'row');
        r.setAttribute('aria-label', `Parola ${parsedBoard.length + 1}`);
        
        for(let j = 0; j < wS.length; j++) {
          const ch = wS[j];
          const isL = ch.match(/[A-ZÀ-Ù]/);
          const isR = !isL || rev.includes(gI);
          wO.chars.push({ char: ch, isRevealed: isR, isLetter: !!isL });
          const d = document.createElement('div');
          d.className = 'tile' + (isL && !isR ? ' empty' : '') + (isL ? '' : ' punct');
          if(isL && isR) d.classList.add('revealed');
          if(isL && !isR) d.textContent = '';
          else d.textContent = ch;
          
          if(isL && !isR) d.setAttribute('aria-label', 'Lettera nascosta');
          else if(isL && isR) {
            const natoWord = NATO[ch] || ch;
            d.setAttribute('aria-label', `${ch}, ${natoWord}`);
          } else d.setAttribute('aria-label', NATO[ch] || ch);
          
          d.id = `tile-${parsedBoard.length}-${j}`;
          d.setAttribute('tabindex', '-1');
          r.appendChild(d);
          if(isL) { gI++; totalLetters++; if(isR) revealedLetters++; }
        }
        c.appendChild(r);
        parsedBoard.push(wO);
      });
      const numWords = parsedBoard.length;
      const summary = `Tabellone: ${numWords} parole, ${totalLetters} lettere totali, ${revealedLetters} scoperte.`;
      c.setAttribute('aria-label', summary);
      highlightNav();
      if(isAccessibleMode) updateAccessibleBoard();
    }

    window.addEventListener('keydown', (e)=>{
      const panel=document.getElementById('action-history-panel');
      const open = panel && !panel.classList.contains('hidden');
      if(!open) return;
      if(!e.key) return; 

      const list=document.getElementById('action-history-list');
      const items=[...list.querySelectorAll('.history-item')];
      if(!items.length) return;
      const key=e.key.toLowerCase();
      if(!['arrowdown','arrowup','home','end'].includes(key)) return;
      e.preventDefault();
      const active=document.activeElement;
      let idx=items.indexOf(active);
      if(idx<0) idx=0;
      if(key==='arrowdown') idx=Math.min(items.length-1, idx+1);
      if(key==='arrowup') idx=Math.max(0, idx-1);
      if(key==='home') idx=0;
      if(key==='end') idx=items.length-1;
      items[idx].focus();
    });

    window.addEventListener('keydown', e=>{
      if(!e.key) return;
      if((e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'r') || e.key.toLowerCase() === 'f5') return;
      if(inputMode) return;
      
      const k=e.key.toLowerCase();
      if(k === 'escape'){
         e.preventDefault();
         ['player-check-overlay','chat-overlay','help-panel','players-panel','action-history-panel','input-area','word-inspector-overlay','mystery-choice-overlay'].forEach(id => {
            const el = document.getElementById(id);
            if(el) el.classList.add('hidden');
         });
         closeInput();
         speak("Finestre chiuse.");
         return;
      }

      if(document.activeElement && document.activeElement.tagName==='INPUT') return;

      if(isMysteryModalOpen){
        const btn1 = document.getElementById('btn-mystery-open');
        const btn2 = document.getElementById('btn-mystery-500');
        if(['arrowleft','arrowright','arrowup','arrowdown'].includes(k)){
          e.preventDefault();
          if(document.activeElement === btn1 && btn2) btn2.focus();
          else if(btn1) btn1.focus();
          return;
        }
        if(k==='enter'){ e.preventDefault(); if(document.activeElement) document.activeElement.click(); return; }
        if(e.ctrlKey || /^[a-z]$/.test(k)) { e.preventDefault(); return; }
      }

      if(k==='arrowup'){ e.preventDefault(); moveWordNav(-1); return; }
      if(k==='arrowdown'){ e.preventDefault(); moveWordNav(1); return; }
      if(k==='arrowleft'){ e.preventDefault(); moveNav(-1); return; }
      if(k==='arrowright'){ e.preventDefault(); moveNav(1); return; }
      if(k===' '){ e.preventDefault(); reopenLastInput(); return; }
      if(k==='i'){ e.preventDefault(); openWordInspector(); return; }
      
      if(k==='1'){ playAudio('snd-clap'); return; }
      if(k==='2'){ playAudio('snd-laugh'); return; }
      if(k==='3'){ playAudio('snd-boo'); return; }
      if(k==='4'){ playAudio('snd-ooh'); return; }
      
      // TASTI RAPIDI (con supporto Ctrl)
      if(k==='h' || (e.ctrlKey && k==='h')){ e.preventDefault(); const p=document.getElementById('help-panel'); if(p.classList.contains('hidden')) openHelp(); else closeHelp(); }
      if(k==='g' || (e.ctrlKey && k==='g')){ e.preventDefault(); doSpin(); }
      if(k==='v' || (e.ctrlKey && k==='v')){ e.preventDefault(); openInput('vowel'); }
      if(k==='p' || (e.ctrlKey && k==='p')){ e.preventDefault(); passTurn(); }
      if(k==='r' || (e.ctrlKey && k==='r')){ e.preventDefault(); openInput('solve'); }
      if(k==='t' || (e.ctrlKey && k==='t')){ e.preventDefault(); announceTurn(); }
      if(k==='k' || (e.ctrlKey && k==='k')){ e.preventDefault(); openChat(); }
      if(k==='s' || (e.ctrlKey && k==='s')){ 
        e.preventDefault(); 
        console.log("S premuto! Chiamando openPlayersPanel...");
        openPlayersPanel(); 
      }
      if(k==='l' || (e.ctrlKey && k==='l')){ e.preventDefault(); readRevealedLetters(); }
      if(k==='a' || (e.ctrlKey && k==='a')){ e.preventDefault(); openActionHistory(true); }
      if(k==='b' || (e.ctrlKey && k==='b')){ e.preventDefault(); addBot(); } 
    });

    function toggleAccessibleMode(){
      isAccessibleMode=!isAccessibleMode;
      document.body.classList.toggle('accessible-mode', isAccessibleMode);
      const btn=document.getElementById('btn-acc-mode');
      btn.setAttribute('aria-pressed', isAccessibleMode);
      btn.style.background=isAccessibleMode ? "#fff" : "transparent";
      btn.style.color=isAccessibleMode ? "#000" : "#fff";
      if(isAccessibleMode){
        updateAccessibleBoard();
        document.getElementById('board-container').setAttribute('aria-hidden','true');
        speak("Vista Testo attivata.");
      } else {
        document.getElementById('board-container').setAttribute('aria-hidden','false');
        speak("Vista Grafica attivata.");
      }
    }
    function updateAccessibleBoard(){
      if(!currentFrase || !parsedBoard.length) return;
      const container=document.getElementById('acc-word-list');
      container.innerHTML="";
      let totalRevealed=0,totalLetters=0;
      parsedBoard.forEach(w=>w.chars.forEach(c=>{ if(c.isLetter){ totalLetters++; if(c.isRevealed) totalRevealed++; } }));
      document.getElementById('acc-board-summary').textContent = `Frase di ${parsedBoard.length} parole. Lettere scoperte: ${totalRevealed} su ${totalLetters}.`;

      parsedBoard.forEach((w, idx)=>{
        const btn=document.createElement('button');
        btn.className="acc-word-btn";
        let visualText="", srText=`Parola ${idx+1}: `;
        w.chars.forEach(c=>{
          if(c.isLetter){
            if(c.isRevealed){ visualText+=c.char+" "; srText+=c.char+" "; }
            else { visualText+="_ "; srText+="Nascosta "; }
          } else { visualText+=c.char+" "; srText+=(NATO[c.char] || c.char) + " "; }
        });
        btn.innerHTML=`<span>${idx+1}.</span> <strong>${visualText}</strong>`;
        btn.onclick=()=>speak(srText);
        container.appendChild(btn);
      });
    }

    function askPrivacy(){
      const nm=document.getElementById('inp-name').value.trim();
      if(!nm) return speak("Inserisci nome.");
      document.getElementById('privacy-dialog').classList.remove('hidden');
      setTimeout(()=>{ const b=document.getElementById('privacy-dialog').querySelector('button'); if(b) b.focus(); },100);
    }
    async function createRoomFinal(isPublic){
      document.getElementById('privacy-dialog').classList.add('hidden');
      let cd=document.getElementById('inp-code').value.trim().toUpperCase();
      if(!cd) cd="STANZA-"+Math.floor(Math.random()*9999);
      joinGame(true, cd, isPublic);
    }
    async function fetchPublicRooms(){
      const l=document.getElementById('rooms-list'); l.innerHTML="Cerco...";
      const {data:s}=await _supabase.from('stanze').select('codice,stato').eq('is_public',true).neq('stato','terminata').limit(10);
      if(!s||!s.length){ l.innerHTML="Nessuna stanza."; return; }
      l.innerHTML="";
      s.forEach(r=>{
        const b=document.createElement('button'); b.className='action-btn'; b.style="width:100%;margin:5px 0;padding:10px;font-size:0.8em;";
        b.textContent=`${r.codice} (${r.stato})`;
        b.onclick=()=>{ document.getElementById('inp-code').value=r.codice; joinGame(false); };
        l.appendChild(b);
      });
    }

    async function joinGame(cr, forcedCode=null, isPublic=false){
      const nm=document.getElementById('inp-name').value.trim().toUpperCase();
      const cd=forcedCode || document.getElementById('inp-code').value.trim().toUpperCase();
      if(!nm) return speak("Nome mancante");

      try{
        let st;
        if(cr){
          const {data:fr}=await _supabase.from('frasi').select('id').neq('categoria','SITUAZIONI QUOTIDIANE').limit(100);
          const rid=fr[Math.floor(Math.random()*fr.length)].id;
          const {data}=await _supabase.from('stanze').insert({
            codice:cd, 
            frase_corrente_id:rid, 
            is_public:isPublic, 
            round_giocati:1, 
            fase_speciale:0,
            stato:'gioco',
            in_pausa:false,
            montepremi_round:0,
            lettere_rivelate:[],
            ultima_azione:'creazione', 
            azione_timestamp:new Date().toISOString()
          }).select().maybeSingle();
          st=data;
        } else {
          const {data}=await _supabase.from('stanze').select('*').eq('codice',cd).maybeSingle();
          if(!data) return speak("Stanza inesistente");
          st=data;
        }
        roomId=st.id;

        const {data:exist}=await _supabase.from('giocatori').select('*').eq('stanza_id',roomId).eq('nome',nm).maybeSingle();
        if(exist){ myId=exist.id; myIndex=exist.indice; isHost=exist.is_host; }
        else{
          const {data:mx}=await _supabase.from('giocatori').select('indice').eq('stanza_id',roomId).order('indice',{ascending:false}).limit(1).maybeSingle();
          myIndex=(mx)?mx.indice+1:0; isHost=(myIndex===0);
          const {data:pl, error:plError}=await _supabase.from('giocatori').insert({
            stanza_id:roomId,
            nome:nm,
            indice:myIndex,
            is_host:isHost,
            ultimo_ping: new Date().toISOString()
          }).select().maybeSingle();
          
          if(plError || !pl) {
            console.error('Errore inserimento giocatore:', plError);
            speak('Errore database: ' + (plError?.message || 'Controlla che il campo ultimo_ping esista nella tabella giocatori'));
            return;
          }
          myId=pl.id;
        }

        document.getElementById('setup-panel').classList.add('hidden');
        document.getElementById('game-panel').classList.remove('hidden');
        document.getElementById('btn-host-next').classList.toggle('hidden', !isHost);
        document.getElementById('btn-resume-host').classList.toggle('hidden', !isHost);
        
        // Aggiorna testo pulsante CLASSIFICA in base a isHost
        const btnManagement = document.getElementById('btn-management');
        if(btnManagement) {
          btnManagement.textContent = isHost ? 'CONTROLLI E CLASSIFICA (S)' : 'CLASSIFICA (S)';
        }

        _supabase.channel('game').on('postgres_changes',{event:'UPDATE',schema:'public',table:'stanze',filter:`id=eq.${roomId}`},fetchFullState).subscribe();
        _supabase.channel('chat').on('postgres_changes',{event:'INSERT',schema:'public',table:'chat_messaggi',filter:`stanza_id=eq.${roomId}`},payload=>{
          // Annuncia SOLO il nuovo messaggio in tempo reale (non tutto lo storico)
          if(payload.new.giocatore_nome !== nm) {
            speakChat(`${payload.new.giocatore_nome} scrive: ${payload.new.messaggio}`);
          }
          // Aggiorna visivamente SOLO se la chat è aperta
          const chatOverlay = document.getElementById('chat-overlay');
          if(chatOverlay && !chatOverlay.classList.contains('hidden')) {
            fetchChat(false); // Aggiorna mostrando solo l'ultimo messaggio
          }
        }).subscribe();

        fetchFullState();
        setInterval(checkTurnTimer, 1000);
        
        // SISTEMA HEARTBEAT DISABILITATO
        /* setInterval(async () => {
          if(myId && roomId) {
            console.log('[HEARTBEAT] Aggiorno ping per myId:', myId);
            const result = await _supabase.from('giocatori').update({
              ultimo_ping: new Date().toISOString()
            }).eq('id', myId);
            console.log('[HEARTBEAT] Risultato update:', result);
          } else {
            console.log('[HEARTBEAT] SKIP - myId:', myId, 'roomId:', roomId);
          }
        }, 3000); */
        
        // CONTROLLO DISCONNESSIONI DISABILITATO
        /* if(isHost) {
          setInterval(async () => {
            await checkAndRemoveDisconnectedPlayers();
          }, 10000);
        } */
      } catch(e){
        console.error(e);
        speak("Errore connessione.");
      }
    }

    async function fetchFullState(){
      if(isFetching) return; isFetching=true;
      const {data:s}=await _supabase.from('stanze').select('*,frasi(*),giocatori(*)').eq('id',roomId).maybeSingle();
      isFetching=false;
      if(s) updateUI(s);
    }

    function getVowelCost(){
      const len=(currentPuzzleText||"").length;
      if(!len) return 1000;
      if(len<=50) return 500;
      if(len<=80) return 1000;
      return 2000;
    }

    function hasActiveJolly(me, stanza){
      return !!(me && typeof me.scadenza_jolly === 'number' && me.scadenza_jolly >= stanza.round_giocati);
    }
    async function consumeJolly(){ await _supabase.from('giocatori').update({scadenza_jolly:0}).eq('id', myId); }

    async function tryUseJollyToAvoid(kindLabel){
      // Ricarica stato fresco per avere i dati aggiornati del giocatore
      const {data:freshStanza} = await _supabase.from('stanze').select('*, giocatori(*)').eq('id', roomId).maybeSingle();
      if(!freshStanza) return false;
      
      const me = freshStanza.giocatori.find(p=>p.id===myId);
      if(!hasActiveJolly(me, freshStanza)) return false;
      
      const ok = confirm(`Hai un JOLLY attivo. Vuoi usarlo per evitare: ${kindLabel}?`);
      if(!ok) return false;
      
      await consumeJolly();
      await _supabase.from('stanze').update({montepremi_round:0,fase_speciale:0,ultima_azione:'jolly',ultimo_messaggio:`JOLLY usato: evitato ${kindLabel}`,azione_timestamp: new Date().toISOString()}).eq('id', roomId);
      return true;
    }

    // --- LOGICA BOT UMANO (AVVERSARIO REALE) ---
    async function addBot(){
      if(!isHost || !roomId) return;
      
      // RICARICA lo stato aggiornato dal database
      const {data: freshStanza} = await _supabase.from('stanze').select('*, giocatori(*)').eq('id', roomId).maybeSingle();
      if(!freshStanza) return;
      
      // CONTROLLO LIMITE GIOCATORI (sul dato fresco!)
      if(freshStanza.giocatori.length >= MAX_PLAYERS) {
        speak("Stanza piena! Massimo " + MAX_PLAYERS + " giocatori.");
        return;
      }
      
      const botNames = ["BOT Giulia", "BOT Matteo"];
      const usedNames = freshStanza.giocatori.map(p => p.nome);
      const name = botNames.find(n => !usedNames.includes(n)) || "BOT " + Math.floor(Math.random()*100);
      const lastInd = freshStanza.giocatori[freshStanza.giocatori.length-1].indice;
      
      await _supabase.from('giocatori').insert({
        stanza_id:roomId, 
        nome:name, 
        indice:lastInd+1, 
        is_host:false,
        ultimo_ping: new Date().toISOString()
      });
      speak("Bot aggiunto: " + name);
      
      // FORZA il refresh immediato dello stato
      await fetchFullState();
    }

    async function playBotTurn(botPlayer){
       if(isBotThinking) return;
       isBotThinking = true;
       console.log("Bot playing:", botPlayer.nome);
       
       // Aggiorna il ping del bot per segnalare che è attivo
       await _supabase.from('giocatori').update({
         ultimo_ping: new Date().toISOString()
       }).eq('id', botPlayer.id);

       // TEMPI DI RIFLESSIONE VARIABILI (più umano: 2-4 secondi)
       const thinkTime = 2000 + Math.random() * 2000;
       await new Promise(r => setTimeout(r, thinkTime));

       const s = currentStanza;
       const totalLetters = currentPuzzleText.replace(/[^A-ZÀ-Ù]/g, '').length;
       const revealedIndices = s.lettere_rivelate || [];
       const ratio = revealedIndices.length / totalLetters;

       // 1. IL BOT PROVA A RISOLVERE? (Comportamento umano: quando è quasi sicuro, 90-95% scoperto)
       if(ratio >= 0.90 && Math.random() > 0.3) {
          // Piccola probabilità di errore (10%) - anche gli umani sbagliano quando digitano veloce!
          if(Math.random() < 0.10) {
             await _supabase.from('stanze').update({ultima_azione: 'errore', ultimo_messaggio: `${botPlayer.nome} tenta ma sbaglia la soluzione!`, azione_timestamp: new Date().toISOString()}).eq('id', roomId);
             passTurnBot();
             isBotThinking = false;
             return;
          }
          // RISOLVE!
          await _supabase.from('giocatori').update({punteggio_totale:(botPlayer.punteggio_totale||0)+(botPlayer.punteggio_round||0)+1000, punteggio_round:0}).eq('id', botPlayer.id);
          await _supabase.from('stanze').update({stato:'finito',ultima_azione:'vittoria',ultimo_messaggio:`${botPlayer.nome} HA RISOLTO LA FRASE!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
          isBotThinking = false;
          return;
       }

       // ERRORE UMANO OCCASIONALE (7%): richiama una lettera già chiamata (distrazione/non se la ricorda)
       if(Math.random() < 0.07 && lettersCalledThisRound.length > 3) {
          const errorChar = lettersCalledThisRound[Math.floor(Math.random()*lettersCalledThisRound.length)];
          await _supabase.from('stanze').update({ultima_azione: 'errore', ultimo_messaggio: `${botPlayer.nome} richiama la "${errorChar}" già provata!`, azione_timestamp: new Date().toISOString()}).eq('id', roomId);
          passTurnBot();
          isBotThinking = false;
          return;
       }

       // 2. LOGICA DI GIOCO
       let chosenChar = null;
       let isVowel = false;
       const costVowel = getVowelCost();
       const botMoney = botPlayer.punteggio_round || 0;

       // Strategia vocali: compra se ha i soldi E il tabellone è poco chiaro (<65%)
       // Non serve "margine di sicurezza" - se ha i soldi e serve, la compra!
       if(botMoney >= costVowel && ratio < 0.65 && Math.random() < 0.35) {
           // Usa i gruppi randomizzati per le vocali
           // IMPORTANTE: Non richiamare lettere già chiamate!
           chosenChar = getNextVowelHuman(lettersCalledThisRound);
           if(chosenChar) isVowel = true;
       }

       if(s.montepremi_round === 0 && !isVowel) {
           // GIRA LA RUOTA
           let val = WHEEL_VALUES[Math.floor(Math.random()*WHEEL_VALUES.length)];
           
           // COMPORTAMENTO MISTERO UMANO CORRETTO:
           // Pochi soldi = prende i sicuri (ne ha bisogno!)
           // Tanti soldi = rischia (può permetterselo!)
           if(val === 'MISTERO') {
              let takeSafe = 0.5; // Default 50/50
              if(botMoney < 500) {
                 takeSafe = 0.80; // Pochi soldi → 80% prende i 500 sicuri
              } else if(botMoney > 1500) {
                 takeSafe = 0.30; // Tanti soldi → 70% apre il mistero (rischia!)
              }
              
              if(Math.random() < takeSafe) {
                 val = 500; // Prende i 500 sicuri
              } else {
                 // Apre il mistero! (per ora simulato come 500, ma andrebbe gestito il vero mistero)
                 val = 500; // Semplificato
              }
           }

           if(['BANCAROTTA','PASSA','PASSA_TURNO','PASSA_AVVERSARIO'].includes(val)) {
               await _supabase.from('giocatori').update({punteggio_round:0}).eq('id', botPlayer.id);
               await _supabase.from('stanze').update({ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} gira: ${val}. Cambio turno!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
               passTurnBot();
               isBotThinking = false;
               return;
           }

           let prize = (typeof val === 'number') ? val : 0;
           
           // PAUSA TATTICA: dopo un ottimo colpo (>1000), pausa extra per "gioire"
           if(prize >= 1000) {
               await new Promise(r => setTimeout(r, 800));
           }
           
           await _supabase.from('stanze').update({montepremi_round:prize,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} gira: ${val}€`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
           isBotThinking = false; 
           return; 
       } else {
           // CHIAMA LETTERA (Consonante o Vocale comprata)
           if(!chosenChar) {
               // Usa i gruppi randomizzati per le consonanti
               // IMPORTANTE: Non richiamare lettere già chiamate (presenti o assenti!)
               chosenChar = getNextConsonantHuman(lettersCalledThisRound);
           }

           if(!chosenChar) chosenChar = "Z"; // Fallback rarissimo

           // Verifica reale senza barare (il bot non sa la soluzione in anticipo)
           let foundIndices = []; let gIdx = 0;
           const sol = currentPuzzleText.toUpperCase();
           const cleanChar = cleanStr(chosenChar);
           for(let i=0; i<sol.length; i++) {
               if(sol[i].match(/[A-ZÀ-Ù]/)) {
                   if(cleanStr(sol[i]) === cleanChar) foundIndices.push(gIdx);
                   gIdx++;
               }
           }
           const newFound = foundIndices.filter(idx => !s.lettere_rivelate.includes(idx));

           if(newFound.length > 0) {
               const newRev = [...s.lettere_rivelate, ...newFound];
               let gain = 0;
               if(isVowel) {
                   await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)-costVowel}).eq('id', botPlayer.id);
               } else {
                   gain = (s.fase_speciale === 3) ? (s.montepremi_round||0) : ((s.montepremi_round||0) * newFound.length);
                   await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)+gain}).eq('id', botPlayer.id);
               }
               await _supabase.from('stanze').update({lettere_rivelate:newRev,montepremi_round:0,ultima_azione:'chiama_lettera',ultimo_messaggio:`${botPlayer.nome}: Trovate ${newFound.length} "${chosenChar}"!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
           } else {
               if(isVowel) await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)-costVowel}).eq('id', botPlayer.id);
               await _supabase.from('stanze').update({ultima_azione:'errore',ultimo_messaggio:`${botPlayer.nome}: La "${chosenChar}" è assente.`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
               isBotThinking = false; // IMPORTANTE: Reset PRIMA del passTurnBot
               passTurnBot();
               return; // IMPORTANTE: Esce subito per evitare che continui a giocare
           }
       }
       isBotThinking = false;
    }

    function isLetterAlreadyRevealedOnBoard(char, stanza) {
        let found = false; let gIdx = 0;
        const sol = currentPuzzleText.toUpperCase();
        for(let i=0; i<sol.length; i++){
            if(sol[i].match(/[A-ZÀ-Ù]/)){
                if(cleanStr(sol[i]) === cleanStr(char) && stanza.lettere_rivelate.includes(gIdx)) found = true;
                gIdx++;
            }
        }
        return found;
    }

    function passTurnBot(){
      const s=currentStanza;
      if(!s || !s.giocatori || s.giocatori.length === 0) return;
      
      let currIdx=s.giocatori.findIndex(p=>p.indice===s.id_giocatore_corrente);
      
      // Se il giocatore corrente non esiste più, parte dal primo
      if(currIdx === -1) currIdx = 0;
      
      let nextIdx = (currIdx + 1) % s.giocatori.length;
      let nextInd = s.giocatori[nextIdx].indice;
      
      _supabase.from('stanze').update({id_giocatore_corrente:nextInd,montepremi_round:0,fase_speciale:0,ultima_azione:'timeout',ultimo_messaggio:'Cambio turno',azione_timestamp:new Date().toISOString()}).eq('id', roomId);
    }

    function updateUI(s){
      if (!s || !s.giocatori) return;
      currentStanza=s;
      s.giocatori.sort((a,b)=>a.indice-b.indice);
      
      // NOTIFICHE ENTRATA/USCITA GIOCATORI
      if(previousPlayersList.length > 0) {
        // Controlla nuovi giocatori (entrati)
        const currentIds = s.giocatori.map(p => p.id);
        const previousIds = previousPlayersList.map(p => p.id);
        
        // Trova chi è entrato
        s.giocatori.forEach(player => {
          if(!previousIds.includes(player.id)) {
            showFlashMessage(`🟢 ${player.nome} è entrato nella partita!`, 'good');
            speak(`Nuovo giocatore: ${player.nome} è entrato nella stanza`, true); // true = priorità alta
            console.log(`[ANNUNCIO] ${player.nome} è entrato`); // Debug
          }
        });
        
        // Trova chi è uscito
        previousPlayersList.forEach(player => {
          if(!currentIds.includes(player.id)) {
            showFlashMessage(`🔴 ${player.nome} ha lasciato la partita`, 'bad');
            speak(`${player.nome} è uscito dalla stanza`, true);
            console.log(`[ANNUNCIO] ${player.nome} è uscito`); // Debug
          }
        });
        
        // Controlla se rimangono abbastanza giocatori
        if(s.giocatori.length < 1) {
          showFlashMessage('⚠️ Nessun giocatore rimasto! La partita terminerà.', 'bad');
          if(isHost) {
            setTimeout(() => {
              if(confirm('Non ci sono abbastanza giocatori. Terminare la partita?')) {
                closeRoom();
              }
            }, 1000);
          }
        }
      }
      
      // Aggiorna lista precedente (copia profonda degli ID e nomi)
      previousPlayersList = s.giocatori.map(p => ({id: p.id, nome: p.nome}));

      document.getElementById('pause-panel').classList.toggle('hidden', !s.in_pausa);
      document.getElementById('game-panel').classList.toggle('hidden', s.in_pausa);
      if(s.in_pausa) return;

      if(s.stato==='terminata'){
        document.getElementById('game-panel').classList.add('hidden');
        document.getElementById('end-panel').classList.remove('hidden');
        const l=document.getElementById('ranking-list'); l.innerHTML="";
        [...s.giocatori].sort((a,b)=>b.punteggio_totale-a.punteggio_totale).forEach((p,i)=> l.innerHTML+=`<li>${i+1}. ${p.nome}: €${p.punteggio_totale}</li>`);
        return;
      }

      if(s.stato==='finito'){
        document.getElementById('round-over-panel').classList.remove('hidden');
        document.getElementById('round-winner-msg').textContent=s.ultimo_messaggio;
        document.getElementById('solution-msg').textContent=fullSolutionText;
        if(!nextRoundInterval){
          let sec=15;
          document.getElementById('next-round-timer').textContent=sec;
          nextRoundInterval=setInterval(()=>{
            sec--;
            document.getElementById('next-round-timer').textContent=sec;
            if(sec<=0){
              clearInterval(nextRoundInterval); nextRoundInterval=null;
              if(isHost) startNewRound();
            }
          },1000);
        }
        if(s.azione_timestamp !== lastTimestamp){
          lastTimestamp=s.azione_timestamp;
          playAudio('snd-win');
          speak(`Fine round. ${s.ultimo_messaggio}`);
        }
        return;
      } else {
        if(nextRoundInterval){ clearInterval(nextRoundInterval); nextRoundInterval=null; }
        document.getElementById('round-over-panel').classList.add('hidden');
      }

      if(!currentFrase || currentFrase.id !== s.frasi.id){
        currentFrase=s.frasi;
        fullSolutionText=currentFrase.soluzione;
        
        // Per SITUAZIONI QUOTIDIANE, l'hint è un campo separato
        if(currentFrase.hint){
          currentHintText = currentFrase.hint;
          currentPuzzleText = fullSolutionText;
        }
        // Per le altre frasi, l'hint è nella soluzione con " - "
        else if(fullSolutionText.includes(" - ")){
          const p=fullSolutionText.split(" - ");
          currentHintText=p[0].trim();
          currentPuzzleText=p[1].trim();
        } else {
          currentHintText="";
          currentPuzzleText=fullSolutionText;
        }
        
        document.getElementById('live-category').textContent=currentFrase.categoria;
        document.getElementById('round-hint').textContent=currentHintText;
        vowelsBoughtThisTurn=0;
        parseAndRenderBoard(currentPuzzleText, s.lettere_rivelate);
        speak(`Nuovo Round. Categoria: ${currentFrase.categoria}. ${currentHintText}`);
      }

      document.getElementById('round-indicator').textContent = `R ${s.round_giocati}/10`;
      
      const currentPlayer = s.giocatori.find(p=>p.indice===s.id_giocatore_corrente);
      const isMe=(s.id_giocatore_corrente===myIndex);
      
      if(isHost && currentPlayer && currentPlayer.nome.startsWith("BOT")){
          playBotTurn(currentPlayer);
      }

      if(!wasMyTurn && isMe){ vowelsBoughtThisTurn=0; speak("Tocca a te."); playAudio('snd-turn'); }
      wasMyTurn=isMe;
      
      const who=currentPlayer?.nome;
      document.getElementById('turn-indicator').textContent=isMe ? "TOCCA A TE" : `Turno di ${who||'...'}`;
      document.getElementById('turn-indicator').style.color=isMe ? "var(--col-green)" : "#fff";

      const isRaddoppiaActive=(s.fase_speciale===2);
      const isMysteryFlat=(s.fase_speciale===3);
      document.getElementById('double-indicator').classList.toggle('hidden', !isRaddoppiaActive);

      const me=s.giocatori.find(p=>p.id===myId);
      const myRoundMoney=me ? (me.punteggio_round||0) : 0;
      const vCost=getVowelCost();
      const jInd=document.getElementById('jolly-indicator');
      if(hasActiveJolly(me, s)){
        jInd.textContent=`JOLLY ATTIVO (FINO A ROUND ${me.scadenza_jolly})`;
        jInd.classList.remove('hidden');
      } else jInd.classList.add('hidden');
      
      // INDICATORE ROUND SPECIALE
      const specialInd=document.getElementById('special-round-indicator');
      if(isSpecialRound){
        if(specialVowelsPhase){
          specialInd.textContent=`ROUND SPECIALE - FASE VOCALI (${specialVowelsGiven}/3) - Frase ${specialPhraseIndex + 1}/4`;
        } else {
          specialInd.textContent=`ROUND SPECIALE - CONSONANTI (${specialConsonantsUsed}/12) - Frase ${specialPhraseIndex + 1}/4`;
        }
        specialInd.classList.remove('hidden');
      } else {
        specialInd.classList.add('hidden');
      }

      let canSpin=isMe && !isSpinning && !inputMode && s.montepremi_round===0;
      let canSolve=isMe && !isSpinning && !inputMode;
      let canPass=isMe && !isSpinning;
      let canVowel=isMe && !isSpinning && !inputMode;
      
      if(isRaddoppiaActive && isMe) canSpin=true;
      
      // ROUND SPECIALI: Override logica pulsanti
      if(isSpecialRound){
        if(specialVowelsPhase){
          // FASE VOCALI: Solo chiamata vocale attiva
          canSpin = false;
          canVowel = isMe && !isSpinning && !inputMode;
          canSolve = false; // Non si può risolvere durante fase vocali
          canPass = false;
        } else {
          // FASE CONSONANTI: Gira + chiama consonante
          canSpin = isMe && !isSpinning && !inputMode && s.montepremi_round===0 && specialConsonantsUsed < 12;
          canVowel = false; // Non si comprano vocali nei round speciali
          canSolve = isMe && !isSpinning && !inputMode;
          canPass = false; // Nei round speciali non si passa, solo arrendersi
          
          // Dopo 12 consonanti: TUTTI possono risolvere
          if(specialConsonantsUsed >= 12 || s.fase_speciale === 102){
            canSpin = false;
            canSolve = !isSpinning && !inputMode; // TUTTI possono risolvere
          }
        }
      } else {
        // ROUND NORMALE
        if(myRoundMoney < vCost) canVowel=false;
        if(vowelsBoughtThisTurn>=1) canVowel=false;
        if(isRaddoppiaActive) canVowel=false;
      }

      setBtnState('btn-spin', !canSpin);
      setBtnState('btn-solve', !canSolve);
      setBtnState('btn-pass', !canPass);
      const btnV=document.getElementById('btn-vowel');
      setBtnState('btn-vowel', !canVowel);
      btnV.textContent=`VOCALE (€${vCost})`;

      let canManual=isMe && !isSpinning && !inputMode && s.montepremi_round>0;
      document.getElementById('btn-manual-cons').classList.add('hidden'); 
      const btnSurrender = document.getElementById('btn-surrender');
      if(btnSurrender) {
        // Mostra ARRENDITI se:
        // 1. Fase speciale 3 (mystery flat) dopo timeout, OPPURE
        // 2. Round speciale dopo 12 consonanti (fase_speciale === 102)
        const showSurrender = isHost && (
          (s.fase_speciale === 3 && s.azione_timestamp && (new Date().getTime() - new Date(s.azione_timestamp).getTime()) > TURN_LIMIT_SEC * 1000) ||
          (s.fase_speciale === 102) // 12 consonanti usate nei round speciali
        );
        btnSurrender.classList.toggle('hidden', !showSurrender);
      }
      if(canManual && !inputMode) openInput('letter');

      parseAndRenderBoard(currentPuzzleText, s.lettere_rivelate);
      if(isAccessibleMode) updateAccessibleBoard();
      if(me){
        document.getElementById('score-round').textContent=me.punteggio_round||0;
        document.getElementById('score-total').textContent=me.punteggio_totale||0;
      }
      let statusTxt="";
      if(s.montepremi_round>0) statusTxt = isMysteryFlat ? `IN PALIO: €${s.montepremi_round} (Piatto)` : `IN PALIO: €${s.montepremi_round}`;
      else if(isRaddoppiaActive) statusTxt="RADDOPPIA ATTIVO! GIRA!";
      document.getElementById('wheel-status-text').textContent=statusTxt;

      if(s.azione_timestamp !== lastTimestamp){
        lastTimestamp=s.azione_timestamp;
        addActionToHistory(s.ultimo_messaggio || s.ultima_azione || "Azione");
        if(s.ultima_azione==='errore') playAudio('snd-miss');
        else if(s.ultima_azione==='gira_ruota' && (s.ultimo_messaggio||"").includes("BANCAROTTA")) playAudio('snd-bankrupt');
        else if(s.ultima_azione==='chiama_lettera') {
            const match = (s.ultimo_messaggio || "").match(/Trovate (\d+)/);
            const count = match ? parseInt(match[1]) : 1;
            playMultipleHits(count);
        }
        showFlashMessage(s.ultimo_messaggio, 'info');
        speak(s.ultimo_messaggio);
      }
      
      // Aggiorna testo pulsante CLASSIFICA in base a isHost
      const btnManagement = document.getElementById('btn-management');
      if(btnManagement) {
        btnManagement.textContent = isHost ? 'CONTROLLI E CLASSIFICA (S)' : 'CLASSIFICA (S)';
      }
    }

    function animateWheelSpin(){
      const wheel=document.getElementById('wheel-visual');
      wheelRotation += 720 + Math.floor(Math.random()*720);
      wheel.style.transform=`rotate(${wheelRotation}deg)`;
    }

    async function doSpin(){
      console.log('========== INIZIO DOSPIN ==========');
      console.log('[DEBUG] doSpin chiamato');
      console.log('[DEBUG] isBtnDisabled:', isBtnDisabled('btn-spin'));
      console.log('[DEBUG] myId:', myId);
      console.log('[DEBUG] roomId:', roomId);
      console.log('[DEBUG] currentStanza:', currentStanza);
      
      if(isBtnDisabled('btn-spin')) {
        console.log('[DEBUG] USCITA: btn-spin è disabilitato');
        return;
      }
      
      isSpinning=true;
      // RIMOSSO: vowelsBoughtThisTurn=0; - si resetta solo con consonante corretta!
      speak("Giro la ruota...");
      playAudio('snd-spin');
      animateWheelSpin();
      await new Promise(r=>setTimeout(r,3000));
      let val=WHEEL_VALUES[Math.floor(Math.random()*WHEEL_VALUES.length)];
      console.log('[DEBUG] Valore girato:', val);
      
      const myName=document.getElementById('inp-name').value;
      console.log('[DEBUG] myName:', myName);
      
      const me=currentStanza.giocatori.find(p=>p.id===myId);
      console.log('[DEBUG] me (giocatore):', me);
      
      const activeMultiplier=(currentStanza.fase_speciale===2) ? 2 : 1;
      let nextFaseSpeciale=0;
      let mysterySafeFlat=false;

      if(val==='MISTERO'){
        const openIt = await askMysteryChoice(); 
        if(!openIt){
          val = 500;
          mysterySafeFlat = true;
          speak("Scelti 500 sicuri.");
        } else {
          val = MISTERO_VALUES[Math.floor(Math.random()*MISTERO_VALUES.length)];
          speak("Mistero svelato... " + val);
        }
      }

      if(val==='BANCAROTTA'){
        isSpinning=false;
        
        // Controlla se può usare il jolly (sia round normale che speciale)
        const saved=await tryUseJollyToAvoid("BANCAROTTA");
        if(saved) return;
        
        // ROUND SPECIALI: Rigiro obbligatorio dopo BANCAROTTA
        if(isSpecialRound && !specialVowelsPhase){
          await _supabase.from('giocatori').update({punteggio_round:0}).eq('id', myId);
          await _supabase.from('stanze').update({
            ultimo_messaggio:`${myName} becca BANCAROTTA! Punteggio azzerato. RIGIRA OBBLIGATORIO!`,
            azione_timestamp:new Date().toISOString()
          }).eq('id', roomId);
          speak("BANCAROTTA! Devi rigirare!");
          // Non passa turno, il giocatore DEVE rigirare
          return;
        }
        
        // Round normale
        await _supabase.from('giocatori').update({punteggio_round:0, punteggio_totale:0}).eq('id', myId);
        await _supabase.from('stanze').update({fase_speciale:0}).eq('id', roomId);
        passTurn();
        return;
      }

      if(val==='PASSA' || val==='PASSA_TURNO' || val==='PASSA_AVVERSARIO'){
        isSpinning=false;
        const label=(val==='PASSA_AVVERSARIO') ? "PASSA ALL'AVVERSARIO" : "PASSA TURNO";
        const saved=await tryUseJollyToAvoid(label);
        if(saved) return;
        await _supabase.from('stanze').update({fase_speciale:0}).eq('id', roomId);
        passTurn();
        return;
      }

      let finalPrize=0;
      let msg=`${myName} gira: ${val}`;
      if(typeof val==='number'){
        if(mysterySafeFlat){
          finalPrize = val;
          msg = `${myName} prende ${val}€ (piatto)!`;
          nextFaseSpeciale = 3; 
        } else {
          finalPrize = val * activeMultiplier;
          if(activeMultiplier>1) msg = `${myName} gira ${val} x 2 = ${finalPrize}!`;
          nextFaseSpeciale = 0;
        }
      } else if(val==='+1000'){
        await _supabase.from('giocatori').update({punteggio_round:(me.punteggio_round||0)+1000}).eq('id', myId);
        finalPrize=0;
        msg=`${myName} becca +1000€! Gira ancora!`;
        nextFaseSpeciale=0;
      } else if(val==='RADDOPPIA'){
        finalPrize=0;
        msg=`${myName} trova RADDOPPIA! Gira ancora!`;
        nextFaseSpeciale=2;
      } else if(val==='JOLLY'){
        const startR=currentStanza.round_giocati;
        const endR=startR + 4; // Dura 5 round (compreso quello corrente)
        await _supabase.from('giocatori').update({scadenza_jolly:endR}).eq('id', myId);
        finalPrize=0;
        msg=`${myName} pesca il JOLLY! Attivo dal round ${startR} al round ${endR} (5 round)`;
        nextFaseSpeciale=0;
      }

      isSpinning=false;
      
      console.log('[DEBUG] ========== AGGIORNAMENTO DATABASE ==========');
      console.log('[DEBUG] finalPrize:', finalPrize);
      console.log('[DEBUG] nextFaseSpeciale:', nextFaseSpeciale);
      console.log('[DEBUG] msg:', msg);
      console.log('[DEBUG] roomId:', roomId);
      console.log('[DEBUG] Tentativo di aggiornare stanze...');
      
      const updateResult = await _supabase.from('stanze').update({
        montepremi_round:finalPrize,
        fase_speciale:nextFaseSpeciale,
        ultima_azione:'gira_ruota',
        ultimo_messaggio:msg,
        azione_timestamp:new Date().toISOString()
      }).eq('id', roomId);
      
      console.log('[DEBUG] Risultato update stanze:', updateResult);
      console.log('[DEBUG] Update error:', updateResult.error);
      console.log('[DEBUG] Update data:', updateResult.data);
      
      if(updateResult.error) {
        console.error('[DEBUG] ❌ ERRORE NELL\'UPDATE!', updateResult.error);
        alert('ERRORE: ' + updateResult.error.message);
      } else {
        console.log('[DEBUG] ✅ Update riuscito!');
      }
      
      // APERTURA AUTOMATICA: Se ho girato un numero, apri subito la chiamata consonante
      console.log('[DEBUG] Controllo apertura automatica: finalPrize=', finalPrize, 'mysterySafeFlat=', mysterySafeFlat);
      if(finalPrize > 0 && !mysterySafeFlat) {
        console.log('[DEBUG] ✅ Apertura automatica consonante...');
        
        // WORKAROUND: Aggiorna manualmente currentStanza invece di fare fetchFullState
        // (problema con RLS che non vede subito l'update)
        console.log('[DEBUG] Aggiorno manualmente currentStanza.montepremi_round da', currentStanza?.montepremi_round, 'a', finalPrize);
        if(currentStanza) {
          currentStanza.montepremi_round = finalPrize;
          currentStanza.fase_speciale = nextFaseSpeciale;
          currentStanza.ultima_azione = 'gira_ruota';
          currentStanza.ultimo_messaggio = msg;
        }
        
        console.log('[DEBUG] Stato aggiornato manualmente, currentStanza.montepremi_round:', currentStanza?.montepremi_round);
        openInput('letter');
      } else {
        console.log('[DEBUG] ⚠️ NON apro finestra consonante (finalPrize=0 o mysterySafeFlat)');
      }
      console.log('[DEBUG] ========== FINE DOSPIN ==========');
    }

    function passTurn(){
      if(isHandlingTimeout) return;
      if(Date.now() - lastAutoPassTime < 5000) return; 
      lastAutoPassTime = Date.now();
      isHandlingTimeout=true;
      vowelsBoughtThisTurn=0;
      const s=currentStanza;
      
      if(!s || !s.giocatori || s.giocatori.length === 0) {
        isHandlingTimeout=false;
        return;
      }
      
      let currIdx=s.giocatori.findIndex(p=>p.indice===s.id_giocatore_corrente);
      
      // Se il giocatore corrente non esiste più, parte dal primo
      if(currIdx === -1) currIdx = 0;
      
      let nextIdx = (currIdx + 1) % s.giocatori.length;
      let nextInd = s.giocatori[nextIdx].indice;
      
      _supabase.from('stanze').update({id_giocatore_corrente:nextInd,montepremi_round:0,fase_speciale:0,ultima_azione:'timeout',ultimo_messaggio:'Cambio turno',azione_timestamp:new Date().toISOString()}).eq('id', roomId).then(()=>{ isHandlingTimeout=false; });
    }

    function openInput(mode){
      inputMode=mode;
      lastInputMode=mode; 
      document.getElementById('input-area').classList.remove('hidden');
      const inp=document.getElementById('game-input');
      
      // IMPORTANTE: Ri-aggiungi l'event listener per Enter ogni volta che si apre
      inp.onkeydown = (e) => {
        if(e.key === 'Enter') {
          e.preventDefault();
          submitInput();
        }
      };
      
      if(mode==='solve') {
        // PRECOMPILA con lettere rivelate + asterischi
        let template = "";
        for(let i=0; i<currentPuzzleText.length; i++){
          const char = currentPuzzleText[i].toUpperCase();
          if(!char.match(/[A-ZÀ-Ù]/)){
            template += char; // Spazi, punteggiatura
          } else {
            // È una lettera: controlla se è rivelata
            let gIdx = 0;
            for(let j=0; j<=i; j++){
              if(currentPuzzleText[j].match(/[A-ZÀ-Ù]/)){
                if(j === i) break;
                gIdx++;
              }
            }
            // Verifica se questo indice è rivelato
            const isRevealed = currentStanza?.lettere_rivelate?.includes(gIdx);
            template += isRevealed ? char : '*';
          }
        }
        inp.value = template;
        
        // TYPING INTERATTIVO: Quando scrivo, sostituisco il primo asterisco
        inp.addEventListener('input', function handleInteractiveTyping(e) {
          const currentValue = e.target.value.toUpperCase();
          const templateValue = template.toUpperCase();
          
          // Se l'utente ha digitato più caratteri del template
          if(currentValue.length > templateValue.length) {
            e.target.value = currentValue.substring(0, templateValue.length);
            return;
          }
          
          // Trova la prima posizione dove differiscono
          let diffPos = -1;
          for(let i = 0; i < currentValue.length; i++) {
            if(currentValue[i] !== templateValue[i]) {
              diffPos = i;
              break;
            }
          }
          
          // Se l'utente ha digitato su un asterisco, sostituiscilo
          if(diffPos !== -1 && templateValue[diffPos] === '*') {
            const newChar = currentValue[diffPos];
            if(newChar.match(/[A-ZÀ-Ù]/)) {
              // Sostituisci l'asterisco con la lettera
              const newTemplate = template.substring(0, diffPos) + newChar + template.substring(diffPos + 1);
              template = newTemplate;
              e.target.value = newTemplate;
              
              // CURSORE RIMANE FERMO - l'utente continua a leggere da lì
              setTimeout(() => {
                e.target.setSelectionRange(diffPos + 1, diffPos + 1);
              }, 0);
            }
          }
        });
        
        speak("Risolvi. Completa gli asterischi con le lettere mancanti.");
      } else {
        inp.value='';
        if(mode==='vowel') speak("Scrivi una vocale.");
        else speak("Scrivi una consonante.");
      }
      
      setTimeout(()=>inp.focus(),100);
    }
    function closeInput(){ 
      const inp = document.getElementById('game-input');
      // Rimuovi tutti gli event listener clonando e sostituendo l'elemento
      const newInp = inp.cloneNode(true);
      inp.parentNode.replaceChild(newInp, inp);
      
      document.getElementById('input-area').classList.add('hidden'); 
      inputMode=null; 
    }

    async function submitInput(){
      if(isProcessingInput) return;
      isProcessingInput=true;
      const txt=document.getElementById('game-input').value.trim().toUpperCase();
      console.log('[DEBUG] submitInput chiamato, txt:', txt, 'mode:', inputMode);
      if(!txt){ isProcessingInput=false; return; }
      const mode=inputMode;
      closeInput();
      const myName=document.getElementById('inp-name').value;
      const s=currentStanza;
      
      // GESTIONE ROUND SPECIALI - FASE VOCALI
      if(isSpecialRound && specialVowelsPhase && mode==='vowel'){
        const char=txt.charAt(0);
        const isVowel="AEIOU".includes(char);
        if(!isVowel){ alert("Devi inserire una VOCALE"); isProcessingInput=false; return; }
        
        // Controlla se questa vocale è già stata chiamata
        if(lettersCalledThisRound.includes(char)){
          alert(`La vocale ${char} è già stata chiamata! Scegli un'altra vocale.`);
          isProcessingInput=false;
          return;
        }
        
        await handleSpecialVowel(char, myName, s);
        isProcessingInput=false;
        return;
      }

      if(mode==='solve'){
        if(cleanStr(txt)===cleanStr(currentPuzzleText)){
          const me=s.giocatori.find(p=>p.id===myId);
          
          // ROUND SPECIALI: +1000 per ogni frase risolta
          if(isSpecialRound){
            await _supabase.from('giocatori').update({punteggio_totale:(me.punteggio_totale||0)+(me.punteggio_round||0)+1000,punteggio_round:0}).eq('id', myId);
            
            // Passa alla frase successiva (se ce ne sono)
            if(specialPhraseIndex < 3){
              await nextSpecialPhrase(myName);
            } else {
              // Fine round speciale (tutte e 4 frasi completate)
              await _supabase.from('stanze').update({stato:'finito',ultima_azione:'vittoria',ultimo_messaggio:`${myName} HA COMPLETATO IL ROUND SPECIALE!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
            }
          } else {
            // Round normale
            await _supabase.from('giocatori').update({punteggio_totale:(me.punteggio_totale||0)+(me.punteggio_round||0)+1000,punteggio_round:0}).eq('id', myId);
            await _supabase.from('stanze').update({stato:'finito',ultima_azione:'vittoria',ultimo_messaggio:`${myName} HA RISOLTO!`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
          }
        } else {
          passTurn();
        }
      } else {
        const char=txt.charAt(0);
        const isVowel="AEIOU".includes(char);
        if(mode==='vowel' && !isVowel){ alert("Devi inserire una VOCALE"); isProcessingInput=false; return; }
        if(mode==='letter' && isVowel){ alert("Devi inserire una CONSONANTE"); isProcessingInput=false; return; }

        if(mode==='vowel'){
          vowelsBoughtThisTurn++;
          const cost=getVowelCost();
          const me=s.giocatori.find(p=>p.id===myId);
          await _supabase.from('giocatori').update({punteggio_round:(me.punteggio_round||0)-cost}).eq('id', myId);
        }
        // RIMOSSO: vowelsBoughtThisTurn=0 qui, lo resettiamo solo se la consonante è CORRETTA
        
        // ROUND SPECIALI - FASE CONSONANTI: Controlla limite 12
        if(isSpecialRound && !specialVowelsPhase && mode==='letter'){
          if(specialConsonantsUsed >= 12){
            alert("Limite 12 consonanti raggiunto! Tutti possono risolvere o l'host si arrende.");
            isProcessingInput=false;
            return;
          }
        }

        let foundIndices=[]; let gIdx=0;
        const sol=currentPuzzleText.toUpperCase();
        console.log('[DEBUG] ===== CHIAMATA CONSONANTE =====');
        console.log('[DEBUG] char chiamato:', char);
        console.log('[DEBUG] currentPuzzleText:', currentPuzzleText);
        console.log('[DEBUG] currentPuzzleText.toUpperCase():', sol);
        console.log('[DEBUG] currentPuzzleText.length:', currentPuzzleText.length);
        console.log('[DEBUG] Frase completa (fullSolutionText):', fullSolutionText);
        console.log('[DEBUG] Hint:', currentHintText);
        console.log('[DEBUG] montepremi_round:', s.montepremi_round);
        console.log('[DEBUG] mode:', mode);
        
        // TRACCIA la lettera chiamata (per i bot)
        if(!lettersCalledThisRound.includes(char)) {
          lettersCalledThisRound.push(char);
        }
        
        for(let i=0;i<sol.length;i++){
          if(sol[i].match(/[A-ZÀ-Ù]/)){
            const solChar = sol[i];
            const cleanSolChar = cleanStr(solChar);
            const cleanInputChar = cleanStr(char);
            if(cleanSolChar === cleanInputChar) {
              foundIndices.push(gIdx);
              console.log('[DEBUG] MATCH trovato! posizione:', i, 'indice:', gIdx, 'carattere:', solChar);
            }
            gIdx++;
          }
        }
        console.log('[DEBUG] Totale match trovati:', foundIndices.length);
        console.log('[DEBUG] foundIndices:', foundIndices);
        if(foundIndices.length>0){
          // NON resettiamo più vowelsBoughtThisTurn qui - si resetta a ogni turno
          const newRev=[...new Set([...(s.lettere_rivelate||[]), ...foundIndices])];
          if(mode==='letter'){
            const me=s.giocatori.find(p=>p.id===myId);
            const gain = (s.fase_speciale===3) ? (s.montepremi_round||0) : ((s.montepremi_round||0) * foundIndices.length);
            
            // ANNUNCIO IMMEDIATO per NVDA
            const resultMsg = `Trovate ${foundIndices.length} ${char}! Guadagni ${gain} euro`;
            speak(resultMsg);
            console.log('[DEBUG] 📢 ANNUNCIO:', resultMsg);
            
            await _supabase.from('giocatori').update({punteggio_round:(me.punteggio_round||0)+gain}).eq('id', myId);
            
            // ROUND SPECIALI: Incrementa contatore consonanti
            if(isSpecialRound && !specialVowelsPhase){
              specialConsonantsUsed++;
              
              // Se raggiunta la 12ª, tutti possono risolvere
              if(specialConsonantsUsed >= 12){
                await _supabase.from('stanze').update({
                  lettere_rivelate:newRev,
                  montepremi_round:0,
                  fase_speciale:102, // Marker: 12 consonanti usate, tutti possono risolvere
                  ultima_azione:'consonante_12',
                  ultimo_messaggio:`${myName}: ${char} - 12 CONSONANTI USATE! Tutti possono risolvere o l'host si arrende`,
                  azione_timestamp:new Date().toISOString()
                }).eq('id', roomId);
              } else {
                await _supabase.from('stanze').update({
                  lettere_rivelate:newRev,
                  montepremi_round:0,
                  ultima_azione:'chiama_lettera',
                  ultimo_messaggio:`${myName}: Trovate ${foundIndices.length} ${char} (${specialConsonantsUsed}/12 consonanti)`,
                  azione_timestamp:new Date().toISOString()
                }).eq('id', roomId);
              }
            } else {
              // Round normale
              await _supabase.from('stanze').update({lettere_rivelate:newRev,montepremi_round:0,fase_speciale:0,ultima_azione:'chiama_lettera',ultimo_messaggio:`${myName}: Trovate ${foundIndices.length} ${char}`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
            }
          } else {
            await _supabase.from('stanze').update({lettere_rivelate:newRev,ultima_azione:'chiama_lettera',ultimo_messaggio:`${myName}: Trovate ${foundIndices.length} ${char}`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
          }
        } else {
          // ANNUNCIO IMMEDIATO per NVDA - lettera non trovata
          speak(`${char} non trovata! Passi il turno`);
          console.log('[DEBUG] 📢 ANNUNCIO: Lettera non trovata');
          
          await _supabase.from('stanze').update({ultima_azione:'errore',ultimo_messaggio:`${myName}: ${char} assente`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
          passTurn();
        }
      }
      isProcessingInput=false;
    }

    function checkTurnTimer(){
      if(!currentStanza || currentStanza.in_pausa || currentStanza.stato!=='gioco') return;
      const elapsed=Math.floor((new Date().getTime() - new Date(currentStanza.azione_timestamp).getTime())/1000);
      if(isNaN(elapsed) || elapsed > 10000 || elapsed < -100) return;
      const left=Math.max(0, TURN_LIMIT_SEC - elapsed);
      document.getElementById('timer-box').textContent=left;
      if(left===0 && isHost && !isHandlingTimeout) passTurn();
    }

    async function fetchChat(showAll = false){
      const {data:msgs}=await _supabase.from('chat_messaggi').select('*').eq('stanza_id', roomId).order('created_at',{ascending:true}).limit(50);
      if(!msgs || msgs.length === 0) {
        const c=document.getElementById('chat-messages');
        c.innerHTML="<p style='color:#777;text-align:center;'>Nessun messaggio</p>";
        return;
      }
      
      const c=document.getElementById('chat-messages'); 
      c.innerHTML="";
      
      if(showAll) {
        // Mostra tutti i messaggi
        msgs.forEach(m=>{
          const d=document.createElement('div');
          d.style="border-bottom:1px solid #333; margin-bottom:5px; padding:8px;";
          d.tabIndex = 0;
          d.innerHTML=`<strong style="color:var(--col-accent);">${m.giocatore_nome}:</strong> ${m.messaggio}`;
          c.appendChild(d);
        });
        c.scrollTop=c.scrollHeight;
      } else {
        // Mostra solo l'ultimo messaggio
        const lastMsg = msgs[msgs.length - 1];
        const d=document.createElement('div');
        d.style="border-bottom:1px solid #333; margin-bottom:5px; padding:8px; font-size:1.1em;";
        d.tabIndex = 0;
        d.innerHTML=`<strong style="color:var(--col-accent);">${lastMsg.giocatore_nome}:</strong> ${lastMsg.messaggio}`;
        c.appendChild(d);
        
        // Aggiungi indicazione se ci sono altri messaggi
        if(msgs.length > 1) {
          const hint=document.createElement('p');
          hint.style="color:#888; font-size:0.9em; margin-top:10px; text-align:center;";
          hint.innerHTML="💡 Usa Shift+Tab dal campo input per vedere tutti i messaggi";
          c.appendChild(hint);
        }
      }
    }
    
    function openChat(){ 
       document.getElementById('chat-overlay').classList.remove('hidden'); 
       fetchChat(false); // Mostra solo l'ultimo messaggio
       
       // Annuncia solo che la chat è aperta, NON leggere i messaggi
       setTimeout(() => {
         speak("Chat aperta. Premi Shift Tab per vedere la cronologia completa.");
         
         const chatInput = document.getElementById('chat-input');
         chatInput.focus();
         
         // Rimuovi event listener precedente se esiste
         chatInput.onkeydown = null;
         
         // Aggiungi gestione Shift+Tab per vedere tutti i messaggi
         chatInput.addEventListener('keydown', (e) => {
           if(e.key === 'Tab' && e.shiftKey) {
             e.preventDefault();
             fetchChat(true); // Mostra tutti i messaggi
             speak("Visualizzazione cronologia completa. Usa le frecce per navigare tra i messaggi.");
             // Focus sul container dei messaggi per permettere la navigazione
             setTimeout(() => {
               const firstMsg = document.getElementById('chat-messages').querySelector('div[tabindex="0"]');
               if(firstMsg) firstMsg.focus();
             }, 100);
           } else if(e.key === 'Enter') {
             e.preventDefault();
             sendChatMessage();
           }
         });
       }, 150);
    }
    
    async function sendChatMessage(){
      const t=document.getElementById('chat-input').value.trim();
      if(!t) return;
      await _supabase.from('chat_messaggi').insert({stanza_id:roomId, giocatore_nome:document.getElementById('inp-name').value, messaggio:t});
      document.getElementById('chat-input').value="";
      fetchChat(false); // Torna a mostrare solo l'ultimo messaggio
      document.getElementById('chat-input').focus();
    }

    async function startNewRound(){
      if(!isHost) return;
      let n=currentStanza.round_giocati + 1;
      if(n>10){ await _supabase.from('stanze').update({stato:'terminata'}).eq('id', roomId); return; }
      
      // RESET tracking lettere chiamate
      lettersCalledThisRound = [];
      
      // ROUND SPECIALI: 4, 7, 10
      const isSpecial = (n === 4 || n === 7 || n === 10);
      
      if(isSpecial){
        // Carica UN tema casuale e TUTTE le sue 4 frasi
        // Prima ottieni tutti i temi disponibili (hint distinti)
        const {data:themes}=await _supabase.from('frasi').select('hint').eq('categoria','SITUAZIONI QUOTIDIANE');
        
        if(!themes || themes.length === 0){
          speak("Errore: non ci sono frasi speciali");
          return;
        }
        
        // Trova tutti i temi unici
        const uniqueThemes = [...new Set(themes.map(t => t.hint))];
        
        // Scegli un tema a caso
        const selectedTheme = uniqueThemes[Math.floor(Math.random() * uniqueThemes.length)];
        
        // Prendi TUTTE le frasi di questo tema
        const {data:fr}=await _supabase.from('frasi').select('id,hint,soluzione').eq('categoria','SITUAZIONI QUOTIDIANE').eq('hint', selectedTheme);
        
        if(!fr || fr.length < 4){
          speak(`Errore: tema "${selectedTheme}" ha solo ${fr?.length || 0} frasi, ne servono 4`);
          return;
        }
        
        // Salva gli ID delle 4 frasi
        specialPhraseIds = fr.map(f => f.id);
        isSpecialRound = true;
        specialPhraseIndex = 0;
        specialConsonantsUsed = 0;
        specialVowelsPhase = true;
        specialVowelsGiven = 0;
        
        // Inizia con la prima frase
        const firstPhraseId = specialPhraseIds[0];
        await _supabase.from('giocatori').update({punteggio_round:0}).eq('stanza_id', roomId);
        await _supabase.from('stanze').update({
          frase_corrente_id: firstPhraseId,
          stato:'gioco',
          round_giocati:n,
          lettere_rivelate:[],
          montepremi_round:0,
          fase_speciale:100, // Marker per round speciale
          ultima_azione:'round_speciale_start',
          ultimo_messaggio:`ROUND SPECIALE ${n} - Tema: ${selectedTheme}! Fase vocali: ${getSpecialVowelInstructions()}`,
          azione_timestamp:new Date().toISOString()
        }).eq('id', roomId);
        
      } else {
        // Round normale
        isSpecialRound = false;
        const {data:fr}=await _supabase.from('frasi').select('id').neq('categoria','SITUAZIONI QUOTIDIANE');
        const rid=fr[Math.floor(Math.random()*fr.length)].id;
        await _supabase.from('giocatori').update({punteggio_round:0}).eq('stanza_id', roomId);
        await _supabase.from('stanze').update({frase_corrente_id:rid,stato:'gioco',round_giocati:n,lettere_rivelate:[],montepremi_round:0,fase_speciale:0,ultima_azione:'nuovo',ultimo_messaggio:`Inizio Round ${n}`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
      }
    }
    
    function getSpecialVowelInstructions(){
      const numPlayers = currentStanza.giocatori.length;
      if(numPlayers === 1) return "Sistema regala 2 vocali";
      if(numPlayers === 2) return "Ognuno dice 1 vocale, sistema regala 1";
      if(numPlayers === 3) return "Ognuno dice 1 vocale";
      return "Fase vocali";
    }
    
    async function handleSpecialVowel(char, playerName, stanza){
      const numPlayers = stanza.giocatori.length;
      
      // TRACCIA questa vocale come "chiamata dai giocatori"
      if(!lettersCalledThisRound.includes(char)) {
        lettersCalledThisRound.push(char);
      }
      
      // Rivela la vocale sul tabellone (se presente)
      let foundIndices=[]; let gIdx=0;
      const sol=currentPuzzleText.toUpperCase();
      for(let i=0;i<sol.length;i++){
        if(sol[i].match(/[A-ZÀ-Ù]/)){
          if(cleanStr(sol[i])===cleanStr(char)) foundIndices.push(gIdx);
          gIdx++;
        }
      }
      
      if(foundIndices.length > 0){
        const newRev=[...new Set([...(stanza.lettere_rivelate||[]), ...foundIndices])];
        await _supabase.from('stanze').update({lettere_rivelate:newRev,ultimo_messaggio:`${playerName} chiama vocale: ${char}`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
      } else {
        // Vocale assente, ma conta comunque come "chiamata"
        await _supabase.from('stanze').update({ultimo_messaggio:`${playerName} chiama vocale: ${char} (assente)`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
      }
      
      specialVowelsGiven++;
      
      // Controlla se dobbiamo regalare vocali
      let systemVowels = 0;
      if(numPlayers === 1) systemVowels = 2;
      else if(numPlayers === 2 && specialVowelsGiven === 2) systemVowels = 1;
      
      if(systemVowels > 0){
        await giveSystemVowels(systemVowels, stanza);
      }
      
      // Se abbiamo 3 vocali totali chiamate (non importa se presenti), passa alla fase consonanti
      const totalVowels = specialVowelsGiven + systemVowels;
      if(totalVowels >= 3 || (numPlayers === 3 && specialVowelsGiven === 3)){
        specialVowelsPhase = false;
        await _supabase.from('stanze').update({
          fase_speciale:101, // Marker fase consonanti
          ultimo_messaggio:`Vocali complete! Fase consonanti: 12 consonanti totali da chiamare`,
          azione_timestamp:new Date().toISOString()
        }).eq('id', roomId);
      } else {
        passTurn();
      }
    }
    
    async function giveSystemVowels(count, stanza){
      const vowelsOrder = ['E','A','I','O','U']; // Ordine corretto di frequenza italiana
      
      // Trova quali vocali sono state CHIAMATE dai giocatori (presenti o assenti nella frase)
      const calledVowels = lettersCalledThisRound.filter(c => 'AEIOU'.includes(c));
      
      // Regala le vocali più frequenti NON ancora chiamate
      for(let v of vowelsOrder){
        if(count === 0) break;
        
        // Questa vocale NON deve essere stata chiamata dai giocatori
        if(!calledVowels.includes(v)){
          // Traccia come chiamata
          if(!lettersCalledThisRound.includes(v)) {
            lettersCalledThisRound.push(v);
          }
          
          // Rivela questa vocale sul tabellone (se presente)
          let foundIndices=[]; let gIdx=0;
          const sol=currentPuzzleText.toUpperCase();
          for(let i=0;i<sol.length;i++){
            if(sol[i].match(/[A-ZÀ-Ù]/)){
              if(sol[i]===v) foundIndices.push(gIdx);
              gIdx++;
            }
          }
          
          if(foundIndices.length > 0){
            const newRev=[...new Set([...(stanza.lettere_rivelate||[]), ...foundIndices])];
            await _supabase.from('stanze').update({lettere_rivelate:newRev,ultimo_messaggio:`Sistema regala vocale: ${v}`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
            stanza.lettere_rivelate = newRev;
          } else {
            // Vocale non presente nella frase, ma conta comunque come "data"
            await _supabase.from('stanze').update({ultimo_messaggio:`Sistema regala vocale: ${v} (non presente)`,azione_timestamp:new Date().toISOString()}).eq('id', roomId);
          }
          
          count--;
        }
      }
    }
    
    async function nextSpecialPhrase(solverName){
      specialPhraseIndex++;
      specialConsonantsUsed = 0;
      specialVowelsPhase = true;
      specialVowelsGiven = 0;
      
      const nextPhraseId = specialPhraseIds[specialPhraseIndex];
      await _supabase.from('stanze').update({
        frase_corrente_id: nextPhraseId,
        lettere_rivelate:[],
        montepremi_round:0,
        fase_speciale:100, // Torna alla fase vocali
        ultimo_messaggio:`${solverName} risolve! Frase ${specialPhraseIndex + 1}/4 - ${getSpecialVowelInstructions()}`,
        azione_timestamp:new Date().toISOString()
      }).eq('id', roomId);
    }

    async function leaveGame(){
      if(roomId && myId && !isHost) await _supabase.from('giocatori').delete().eq('id', myId);
      else if(roomId && isHost) await closeRoom();
      location.reload();
    }
    async function closeRoom(){ await _supabase.from('stanze').delete().eq('id', roomId); location.reload(); }
    
    async function surrenderPhrase(){
      if(!isHost) return;
      
      // ROUND SPECIALI: Passa alla frase successiva invece di finire il round
      if(isSpecialRound && specialPhraseIndex < 3){
        if(confirm("Arrenditi e passa alla frase successiva?")){
          await nextSpecialPhrase("HOST");
        }
        return;
      }
      
      // ROUND SPECIALI: Ultima frase (4/4) - finisce il round
      if(isSpecialRound && specialPhraseIndex === 3){
        if(confirm("Arrenditi? Finirà il round speciale.")){
          await _supabase.from('stanze').update({stato:'finito',ultima_azione:'arresa',ultimo_messaggio:'HOST SI È ARRESO - ROUND SPECIALE CONCLUSO',azione_timestamp:new Date().toISOString()}).eq('id', roomId);
        }
        return;
      }
      
      // Round normale
      if(confirm("Arrenditi?")){
        await _supabase.from('stanze').update({stato:'finito',ultima_azione:'arresa',ultimo_messaggio:'HOST SI È ARRESO',azione_timestamp:new Date().toISOString()}).eq('id', roomId);
      }
    }
    
    async function resetGame(){
      if(confirm("Reset partita?")){
        // Usiamo 'await' per assicurarci che il reset avvenga PRIMA di iniziare il nuovo round
        await _supabase.from('giocatori').update({punteggio_totale:0, punteggio_round:0}).eq('stanza_id', roomId);
        await _supabase.from('stanze').update({round_giocati:0, lettere_rivelate:[]}).eq('id', roomId);
        startNewRound();
      }
    }
  </script>
</body>
</html>