<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    font-src 'self' https://fonts.gstatic.com;
    connect-src 'self' https://azcwkpdjbysnivknnino.supabase.co wss://azcwkpdjbysnivknnino.supabase.co https://cdn.jsdelivr.net;
    img-src 'self' data: https:;
    media-src 'self' data: blob: https://raw.githubusercontent.com;
    base-uri 'self';
    form-action 'self';
  ">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <title>La Ruota - Gioco Online</title>
  <link rel="icon" href="data:," />
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
  'use strict';
  
  // ==========================================
  // CONFIGURAZIONE
  // ==========================================
  
  /*
   * ‚úÖ MODIFICHE APPLICATE PER CORREGGERE I TURNI:
   * 
   * 1. GIRO RUOTA ‚Üí Resetta vowelsBoughtThisTurn = 0
   * 2. TROVO CONSONANTE ‚Üí MANTENGO turno, NON resetto vowelsBoughtThisTurn
   * 3. NON TROVO CONSONANTE ‚Üí PASSO turno
   * 4. COMPRO VOCALE ‚Üí Possibile solo se:
   *    - Ho gi√† rivelato lettere (frase parziale visibile)
   *    - Ho abbastanza soldi nel round
   *    - Non ho gi√† comprato una vocale in questo giro
   * 5. TROVO VOCALE ‚Üí MANTENGO turno
   * 6. NON TROVO VOCALE ‚Üí PASSO turno
   * 7. DOPO VOCALE ‚Üí Posso solo RISOLVERE o attendere prossimo giro ruota
   * 
   * SEQUENZA CORRETTA:
   * GIRO ‚Üí CONSONANTE (trovata) ‚Üí posso VOCALE o RISOLVI
   * GIRO ‚Üí CONSONANTE (trovata) ‚Üí VOCALE (trovata) ‚Üí posso solo RISOLVI
   * GIRO ‚Üí CONSONANTE (trovata) ‚Üí VOCALE (non trovata) ‚Üí passo turno
   * GIRO ‚Üí CONSONANTE (non trovata) ‚Üí passo turno
   */
  
  // NOTA: Questa √® una chiave pubblica 'anon' di Supabase.
  // Le policy RLS (Row Level Security) su Supabase proteggono i dati sensibili.
  // NON includere MAI chiavi 'service_role' nel codice client!
  const SUPABASE_URL = 'https://azcwkpdjbysnivknnino.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF6Y3drcGRqYnlzbml2a25uaW5vIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2MzAwNDksImV4cCI6MjA3OTIwNjA0OX0.R8wkMJEmsP8cTVUUOcWtD4Rrg_ZhuOE-PYBJ56eGqMU';
  
  const _supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  
  // ==========================================
  // TRACCIAMENTO VINCITORI E TURNI ROUND
  // ==========================================
  
  // Traccia chi ha vinto gli ultimi round per determinare chi inizia il prossimo
  let lastRoundWinnerUUID = null;      // Vincitore dell'ultimo round
  let previousRoundWinnerUUID = null;  // Vincitore del penultimo round
  
  // Mappa: UUID giocatore -> numero di volte che ha iniziato un round
  let playerRoundStarts = {};
  
  // Costanti di configurazione
  const CONFIG = {
    PING_INTERVAL_MS: 10000,
    WHEEL_SPIN_DURATION_MS: 3000,
    ERROR_DISPLAY_DELAY_MS: 100,
    AUDIO_VOLUME: 0.3,
    DEBOUNCE_RESIZE_MS: 250,
    TILE_ANIMATION_DURATION_MS: 300,
    SOUND_DURATIONS: {
      SHORT: 60,
      MEDIUM: 100,
      LONG: 150
    },
    FREQUENCIES: {
      CORRECT: [523.25, 587.33, 659.25, 783.99],
      INCORRECT: [200, 150],
      WHEEL_START: 400,
      WHEEL_MAX: 800
    }
  };

  // ==========================================
  // UTILITY FUNCTIONS
  // ==========================================
  
  // Debounce utility
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        TimerManager.clearTimeout(timeout);
        func(...args);
      };
      TimerManager.clearTimeout(timeout);
      timeout = TimerManager.setTimeout(later, wait);
    };
  }
  
  // Escape HTML per prevenire XSS
  function escapeHTML(str) {
    if (str === null || str === undefined) return '';
    const div = document.createElement('div');
    div.textContent = String(str);
    return div.innerHTML;
  }
  
  // Safe localStorage operations
  function safeGetFromLocalStorage(key, defaultValue = null) {
    try {
      const item = localStorage.getItem(key);
      if (item === null) return defaultValue;
      if (typeof item === 'string' && item.trim().length > 0) {
        return item;
      }
      return defaultValue;
    } catch (error) {
      console.error(`Errore lettura localStorage (${key}):`, error);
      return defaultValue;
    }
  }
  
  function safeSetToLocalStorage(key, value) {
    try {
      if (value === null || value === undefined) {
        localStorage.removeItem(key);
        return true;
      }
      localStorage.setItem(key, String(value));
      return true;
    } catch (error) {
      console.error(`Errore scrittura localStorage (${key}):`, error);
      return false;
    }
  }
  
  // Fisher-Yates shuffle algorithm (migliore di Math.random() - 0.5)
  function shuffle(array) {
    const arr = [...array];
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  
  // Date utilities
  const DateUtils = {
    now() {
      return new Date().toISOString();
    },
    
    formatForDisplay(isoString) {
      try {
        const date = new Date(isoString);
        return date.toLocaleTimeString('it-IT', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });
      } catch (err) {
        console.error('Errore formattazione data:', err);
        return '‚Äî';
      }
    }
  };
  
  // Timer tracking per prevenire memory leak
  const TimerManager = {
    timeouts: new Set(),
    intervals: new Set(),
    
    setTimeout(callback, delay, ...args) {
      const id = setTimeout(() => {
        this.timeouts.delete(id);
        callback(...args);
      }, delay);
      this.timeouts.add(id);
      return id;
    },
    
    setInterval(callback, delay, ...args) {
      const id = setInterval(callback, delay, ...args);
      this.intervals.add(id);
      return id;
    },
    
    clearTimeout(id) {
      if (id) {
        clearTimeout(id);
        this.timeouts.delete(id);
      }
    },
    
    clearInterval(id) {
      if (id) {
        clearInterval(id);
        this.intervals.delete(id);
      }
    },
    
    clearAll() {
      this.timeouts.forEach(id => TimerManager.clearTimeout(id));
      this.intervals.forEach(id => TimerManager.clearInterval(id));
      this.timeouts.clear();
      this.intervals.clear();
    }
  };
  
  // Safe Supabase query wrapper
  async function safeQuery(queryFn, context = 'Operazione database') {
    try {
      const { data, error } = await queryFn();
      
      if (error) {
        console.error(`[${context}] Errore Supabase:`, error);
        
        if (error.code === 'PGRST116') {
          showFlashMessage('‚ùå Dati non trovati', 'bad');
        } else if (error.message?.includes('JWT')) {
          showFlashMessage('‚ö†Ô∏è Sessione scaduta', 'bad');
          TimerManager.setTimeout(() => location.reload(), 2000);
        } else if (error.message?.includes('network')) {
          showFlashMessage('üì° Problema di connessione', 'bad');
        } else {
          showFlashMessage('‚ùå Errore database', 'bad');
        }
        
        return { success: false, error, data: null };
      }
      
      return { success: true, data, error: null };
    } catch (err) {
      console.error(`[${context}] Eccezione:`, err);
      showFlashMessage('‚ùå Errore imprevisto', 'bad');
      return { success: false, error: err, data: null };
    }
  }

  
  // ==========================================
  // GESTIONE ERRORI GLOBALE
  // ==========================================
  
  /*
   * SISTEMA DI STABILIT√Ä E GESTIONE ERRORI - COMPLETO ‚úÖ
   * 
   * Questo sistema implementa tre livelli di protezione:
   * 
   * 1. ‚úÖ WRAPPER safeQuery (righe 218-245):
   *    - Avvolge ogni chiamata a Supabase
   *    - Gestisce automaticamente errori di rete e sessioni scadute
   *    - Previene il blocco del gioco durante problemi database
   * 
   * 2. ‚úÖ GESTORE ERRORI GLOBALE (window.onerror):
   *    - Intercetta errori JavaScript non gestiti
   *    - Mostra dialog interattivo con opzioni "Ignora" o "Ricarica"
   *    - Limita il numero di popup per evitare spam (MAX 3)
   *    - Sanitizza messaggi per prevenire XSS
   *    - Supporto tastiera (ESC per chiudere)
   * 
   * 3. ‚úÖ GESTORE PROMISE (unhandledrejection):
   *    - Intercetta errori asincroni non gestiti
   *    - Mostra dialog specifico per errori in background
   *    - Consiglia ricarica pagina per errori async
   *    - Stile visivo differenziato (arancione vs rosso)
   * 
   * COMPORTAMENTO:
   * - Primi 3 errori: mostrano dialog con opzioni
   * - Errori successivi: loggati in console, UI soppressa
   * - Errori ignorabili: ResizeObserver, Script error generico
   * - Focus automatico sui pulsanti per accessibilit√†
   * - Effetti hover per migliore UX
   */
  
  // Contatore errori per evitare spam
  let errorCount = 0;
  const MAX_ERROR_DISPLAYS = 3;
  
  // Gestore errori globale con UI
  window.onerror = function(msg, url, line, col, error) {
    if (!msg || typeof msg !== 'string') return false;
    
    // Ignora errori noti e non critici
    if (msg.includes('ResizeObserver')) return false;
    if (msg.includes('Script error')) return false;
    
    console.error('‚ùå Errore globale:', {
      message: msg,
      url: url,
      line: line,
      column: col,
      error: error
    });
    
    // Evita troppi popup
    errorCount++;
    if (errorCount > MAX_ERROR_DISPLAYS) {
      console.warn('‚ö†Ô∏è Troppi errori, dialoghi soppressi');
      return false;
    }
    
    // Mostra dialog di errore all'utente
    showErrorDialog(msg, url, line);
    
    return false; // Permette la propagazione per il logging
  };
  
  // Funzione per mostrare dialog di errore
  function showErrorDialog(message, url, line) {
    // Evita duplicati
    if (document.getElementById('airbag-error-box')) return;
    
    const box = document.createElement('div');
    box.id = 'airbag-error-box';
    box.setAttribute('role', 'alertdialog');
    box.setAttribute('aria-modal', 'true');
    box.setAttribute('aria-labelledby', 'error-title');
    box.setAttribute('aria-describedby', 'error-desc');
    
    box.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(40, 0, 0, 0.95);
      border: 4px solid #ff3333;
      color: white;
      padding: 30px;
      z-index: 99999;
      font-family: sans-serif;
      text-align: center;
      box-shadow: 0 0 50px rgba(255, 0, 0, 0.5);
      border-radius: 15px;
      min-width: 320px;
      max-width: 500px;
    `;
    
    // Prepara messaggio sanitizzato
    const shortMsg = escapeHTML(String(message).substring(0, 200));
    const lineInfo = line ? ` (linea ${line})` : '';
    
    box.innerHTML = `
      <h2 id='error-title' style='margin-top:0; color:#ff5555; font-size: 1.4em;'>
        ‚ö†Ô∏è ERRORE RILEVATO
      </h2>
      <p id='error-desc' style='margin:15px 0; color:#ccc; font-size: 0.95em; line-height: 1.5;'>
        Si √® verificato un errore nell'applicazione${lineInfo}.<br>
        <small style='color:#888; display:block; margin-top:8px;'>${shortMsg}</small>
      </p>
      <p style='margin:15px 0; color:#aaa; font-size: 0.9em;'>
        Puoi ignorare l'errore e continuare a giocare, oppure ricaricare la pagina per un reset completo.
      </p>
      <div style="display:flex; flex-direction:column; gap:10px; margin-top: 20px;">
        <button id="btn-ignore-err" style="
          padding:15px 20px;
          background:#444;
          color:#fff;
          border:2px solid #fff;
          font-weight:bold;
          cursor:pointer;
          font-size:1.1em;
          border-radius: 8px;
          transition: all 0.2s;
        ">IGNORA E CONTINUA</button>
        <button id="btn-reload-err" style="
          padding:12px 20px;
          background:transparent;
          color:#aaa;
          border:1px solid #666;
          cursor:pointer;
          border-radius: 8px;
          font-size: 0.95em;
          transition: all 0.2s;
        ">Ricarica Pagina (F5)</button>
      </div>
      <p style='margin-top:20px; color:#666; font-size: 0.8em;'>
        Premi ESC per chiudere
      </p>
    `;
    
    document.body.appendChild(box);
    
    // Gestore tastiera
    const handleKeydown = function(e) {
      if (e.key === 'Escape') {
        box.remove();
        document.removeEventListener('keydown', handleKeydown);
      }
    };
    document.addEventListener('keydown', handleKeydown);
    
    // Focus automatico sul pulsante principale
    TimerManager.setTimeout(() => {
      const btn = document.getElementById('btn-ignore-err');
      if (btn) btn.focus();
    }, CONFIG.ERROR_DISPLAY_DELAY_MS);
    
    // Event handlers
    const ignoreBtn = document.getElementById('btn-ignore-err');
    const reloadBtn = document.getElementById('btn-reload-err');
    
    if (ignoreBtn) {
      ignoreBtn.onclick = function() {
        box.remove();
        document.removeEventListener('keydown', handleKeydown);
        errorCount--; // Decrementa il contatore se l'utente ignora
      };
      
      // Hover effect
      ignoreBtn.onmouseenter = () => {
        ignoreBtn.style.background = '#555';
        ignoreBtn.style.transform = 'scale(1.02)';
      };
      ignoreBtn.onmouseleave = () => {
        ignoreBtn.style.background = '#444';
        ignoreBtn.style.transform = 'scale(1)';
      };
    }
    
    if (reloadBtn) {
      reloadBtn.onclick = function() {
        window.location.reload();
      };
      
      // Hover effect
      reloadBtn.onmouseenter = () => {
        reloadBtn.style.borderColor = '#999';
        reloadBtn.style.color = '#fff';
      };
      reloadBtn.onmouseleave = () => {
        reloadBtn.style.borderColor = '#666';
        reloadBtn.style.color = '#aaa';
      };
    }
  }
  
  // Gestione promise rejection non gestite
  window.addEventListener('unhandledrejection', function(event) {
    console.error('‚ùå Promise rejection non gestita:', event.reason);
    
    // Evita duplicati
    if (document.getElementById('airbag-error-box')) return;
    
    // Incrementa contatore errori
    errorCount++;
    if (errorCount > MAX_ERROR_DISPLAYS) {
      console.warn('‚ö†Ô∏è Troppi errori async, dialoghi soppressi');
      return;
    }
    
    const box = document.createElement('div');
    box.id = 'airbag-error-box';
    box.setAttribute('role', 'alertdialog');
    box.setAttribute('aria-modal', 'true');
    box.setAttribute('aria-labelledby', 'error-title-async');
    box.setAttribute('aria-describedby', 'error-desc-async');
    
    box.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(40, 0, 0, 0.95);
      border: 4px solid #ff9933;
      color: white;
      padding: 30px;
      z-index: 99999;
      font-family: sans-serif;
      text-align: center;
      box-shadow: 0 0 50px rgba(255, 153, 51, 0.5);
      border-radius: 15px;
      min-width: 320px;
      max-width: 500px;
    `;
    
    const errorMsg = event.reason ? 
      escapeHTML(String(event.reason).substring(0, 200)) : 
      'Errore sconosciuto';
    
    box.innerHTML = `
      <h2 id='error-title-async' style='margin-top:0; color:#ffaa55; font-size: 1.4em;'>
        ‚ö†Ô∏è ERRORE DI CARICAMENTO
      </h2>
      <p id='error-desc-async' style='margin:15px 0; color:#ccc; font-size: 0.95em; line-height: 1.5;'>
        Si √® verificato un problema durante il caricamento dei dati.<br>
        <small style='color:#888; display:block; margin-top:8px;'>${errorMsg}</small>
      </p>
      <p style='margin:15px 0; color:#aaa; font-size: 0.9em;'>
        Si consiglia di ricaricare la pagina per garantire il corretto funzionamento.
      </p>
      <div style="display:flex; flex-direction:column; gap:10px; margin-top: 20px;">
        <button id="btn-ignore-err-async" style="
          padding:15px 20px;
          background:#665522;
          color:#fff;
          border:2px solid #ffaa55;
          font-weight:bold;
          cursor:pointer;
          font-size:1.1em;
          border-radius: 8px;
          transition: all 0.2s;
        ">IGNORA E CONTINUA</button>
        <button id="btn-reload-err-async" style="
          padding:12px 20px;
          background:transparent;
          color:#aaa;
          border:1px solid #666;
          cursor:pointer;
          border-radius: 8px;
          font-size: 0.95em;
          transition: all 0.2s;
        ">Ricarica Pagina (F5)</button>
      </div>
      <p style='margin-top:20px; color:#666; font-size: 0.8em;'>
        Premi ESC per chiudere
      </p>
    `;
    
    document.body.appendChild(box);
    
    // Gestore tastiera
    const handleKeydown = function(e) {
      if (e.key === 'Escape') {
        box.remove();
        document.removeEventListener('keydown', handleKeydown);
      }
    };
    document.addEventListener('keydown', handleKeydown);
    
    // Focus automatico
    TimerManager.setTimeout(() => {
      const btn = document.getElementById('btn-ignore-err-async');
      if (btn) btn.focus();
    }, CONFIG.ERROR_DISPLAY_DELAY_MS);
    
    // Event handlers
    const ignoreBtn = document.getElementById('btn-ignore-err-async');
    const reloadBtn = document.getElementById('btn-reload-err-async');
    
    if (ignoreBtn) {
      ignoreBtn.onclick = function() {
        box.remove();
        document.removeEventListener('keydown', handleKeydown);
        errorCount--; // Decrementa se l'utente ignora
      };
      
      // Hover effect
      ignoreBtn.onmouseenter = () => {
        ignoreBtn.style.background = '#887733';
        ignoreBtn.style.transform = 'scale(1.02)';
      };
      ignoreBtn.onmouseleave = () => {
        ignoreBtn.style.background = '#665522';
        ignoreBtn.style.transform = 'scale(1)';
      };
    }
    
    if (reloadBtn) {
      reloadBtn.onclick = function() {
        window.location.reload();
      };
      
      // Hover effect
      reloadBtn.onmouseenter = () => {
        reloadBtn.style.borderColor = '#999';
        reloadBtn.style.color = '#fff';
      };
      reloadBtn.onmouseleave = () => {
        reloadBtn.style.borderColor = '#666';
        reloadBtn.style.color = '#aaa';
      };
    }
    
    event.preventDefault();
  });
</script>

  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-body:#050505; --bg-panel:#1a1a1a;
      --col-text:#fff; --col-accent:#ffd700; --col-neon:#00ffff; --col-green:#00ff00;
      --font-main:'Roboto Condensed',sans-serif;
    }
    body{background:var(--bg-body);color:var(--col-text);font-family:var(--font-main);margin:0;padding:0;text-align:center;overflow-x:hidden;padding-bottom:150px;} 
    body.high-contrast{--bg-body:#000;--bg-panel:#000;--col-text:#fff;--col-accent:#ff0;--col-neon:#0f0;}
    .sr-only{position:absolute;width:1px;height:1px;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);}
    
    /* Focus styles specifici per elementi interattivi */
    button:focus,
    a:focus,
    input:focus,
    textarea:focus,
    select:focus,
    [tabindex]:focus,
    [role="button"]:focus,
    [role="link"]:focus,
    [role="tab"]:focus {
      outline: 3px solid var(--col-neon);
      outline-offset: 2px;
      border-radius: 4px;
    }
    
    /* Rimuovi outline per mouse/touch, mantieni per tastiera */
    button:focus:not(:focus-visible),
    a:focus:not(:focus-visible),
    input:focus:not(:focus-visible) {
      outline: none;
    }
    
    /* Focus visibile chiaramente per navigazione da tastiera */
    button:focus-visible,
    a:focus-visible,
    input:focus-visible,
    textarea:focus-visible {
      outline: 3px solid var(--col-neon);
      outline-offset: 2px;
      box-shadow: 0 0 0 4px rgba(0, 255, 255, 0.3);
    }
    
    .container{max-width:900px;margin:0 auto;padding:10px;display:flex;flex-direction:column;align-items:center;}
    
    .hidden{display:none !important; visibility: hidden !important; pointer-events: none !important;}
    
    .info-bar{width:100%;display:flex;justify-content:space-between;align-items:center;background:linear-gradient(90deg,#222,#333,#222);padding:10px 15px;border-radius:0 0 15px 15px;border-bottom:2px solid #444;box-sizing:border-box;}
    .timer-display{font-size:2em;color:#ff4444;text-shadow:0 0 10px #ff0000;font-weight:900;min-width:60px;}
    .stats-display{text-align:right;font-size:1.1em;line-height:1.2;color:#ddd;}
    .money-box{margin-top:5px;display:flex;gap:15px;justify-content:center;font-size:1.3em;color:var(--col-accent);text-shadow:0 0 5px rgba(255,215,0,.5);}
    .section-header{width:95%;text-align:left;margin:15px 0 5px 0;color:#888;border-bottom:1px solid #444;padding-bottom:5px;font-size:1em;text-transform:uppercase;letter-spacing:1px;display:none;}
    /* Regola section-header rimossa - le intestazioni H3 sono state eliminate */
    .acc-nav { display: none; width: 98%; max-width: 800px; margin: 10px auto 5px auto; gap: 8px; }
    body.accessible-mode .acc-nav { display: grid; grid-template-columns: 1fr; }
    .acc-nav button { font-size: 0.95em; padding: 12px 10px; min-height: 52px; }
    @media (min-width: 769px) { body.accessible-mode .acc-nav { grid-template-columns: repeat(2, 1fr); } }
    
    /* Intestazioni e pulsanti extra visibili SOLO in modalit√† screenreader senza tastiera */
    body.accessible-mode #heading-gioco { display: block !important; }
    body.accessible-mode #heading-tabellone { display: block !important; }
    body.accessible-mode #btn-solve-after-board { display: block !important; }
    
    /* Nascondi pulsanti ridondanti in modalit√† STANDARD (con tastiera) */
    body:not(.accessible-mode) #btn-inspect-word,
    body:not(.accessible-mode) #btn-letters,
    body:not(.accessible-mode) #btn-chat,
    body:not(.accessible-mode) #btn-management {
      display: none !important;
    }

    #game-panel{width:100%;max-width:800px;margin-top:10px;display:flex;flex-direction:column;gap:5px;}
    .category-box{order:0;margin:5px 0;}
    #live-category{color:var(--col-neon);font-size:1.8em;margin:0;text-transform:uppercase;letter-spacing:2px;text-shadow:0 0 10px var(--col-neon);}
    #category-main{display:block;}
    #round-hint{display:block;color:#fff;font-size:0.67em;font-weight:normal;margin-top:5px;opacity:.8;text-transform:none;letter-spacing:normal;text-shadow:none;}

    .top-controls-wrapper{order:1;width:100%;margin-bottom:5px;}
    .controls-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;width:98%;margin:0 auto;}
    .bottom-controls-wrapper{order:3;width:98%;margin:10px auto;}

    button.action-btn{background:linear-gradient(180deg,#333,#111);color:#fff;border:1px solid #555;border-radius:8px;padding:15px 5px;font-size:1.1em;font-weight:bold;text-transform:uppercase;cursor:pointer;box-shadow:0 4px 0 #000;transition:all .1s;font-family:var(--font-main);display:flex;align-items:center;justify-content:center;min-height:60px;}
    button.action-btn:active{transform:translateY(4px);box-shadow:0 0 0 #000;}
    button.action-btn:disabled{opacity:.5;cursor:not-allowed;filter:grayscale(1);transform:none;box-shadow:none;color:#777;border-color:#333;}

    .btn-spin{background:linear-gradient(180deg,#ffd700,#b8860b);color:#000;border-color:#ffd700;text-shadow:0 1px 0 rgba(255,255,255,.4);font-size:1.3em;}
    .btn-vowel{background:linear-gradient(180deg,#00ffff,#008b8b);color:#000;border-color:#00ffff;}
    .btn-solve{background:linear-gradient(180deg,#ff4444,#8b0000);border-color:#ff4444;width:100%;font-size:1.5em;padding:20px;letter-spacing:2px;}
    .btn-pass{background:#444;color:#aaa;}
    .btn-chat{background:#222;border:1px solid #444;color:#ccc;}

    .board-wrapper{order:2;width:100%;}
    #board-container{display:flex;flex-direction:column;align-items:center;gap:8px;padding:15px;margin:0;min-height:100px;background:rgba(0,50,0,.3);border:2px solid #004400;border-radius:15px;}
    .board-row{display:flex;gap:4px;flex-wrap:wrap;justify-content:center;}
    .tile{width:35px;height:55px;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:1.8em;color:#000;background:#fff;border-radius:4px;box-shadow:2px 2px 5px #000;}
    .tile.empty{background:#003300;border:1px solid #005500;box-shadow:inset 0 0 5px #000;}
    .tile.revealed{background:#fff;animation:popIn .3s cubic-bezier(.175,.885,.32,1.275);}
    .tile.cursor-word{outline:3px solid var(--col-neon);box-shadow:0 0 15px var(--col-neon);}
    .tile.cursor-char{border:4px solid var(--col-accent);transform:scale(1.1);z-index:20;}

    @keyframes popIn{from{transform:scale(0);}to{transform:scale(1);}}
    @keyframes fadeIn{from{opacity:0;}to{opacity:1;}}

    #accessible-board-container{display:none;width:98%;margin:0 auto;text-align:left;}
    #acc-board-summary{background:#111;color:#fff;padding:15px;margin-bottom:15px;border:2px solid #555;border-radius:8px;font-size:1.3em;font-weight:bold;text-align:center;}
    #acc-word-list{display:flex;flex-direction:column;gap:8px;}
    /* Stili per le parole accessibili - semplici per flick */
    .acc-word-item{
      padding: 15px 20px;
      margin: 8px 0;
      background: #222;
      border: 2px solid #555;
      border-radius: 10px;
      font-size: 1.5em;
      font-family: monospace;
      letter-spacing: 2px;
      color: #fff;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
    }
    .acc-word-item:hover, .acc-word-item:focus {
      background: #333;
      border-color: var(--col-neon);
    }
    body.accessible-mode #board-container{display:none;}
    body.accessible-mode #accessible-board-container{display:block;}
    
    /* Nascondi sezioni duplicate in Modalit√† Screen Reader senza tastiera */
    body.accessible-mode .top-controls-wrapper{display:none;}
    body.accessible-mode .bottom-controls-wrapper{display:none;}
    body.accessible-mode #wheel-visual-wrap{display:none;}
    body.accessible-mode #audio-panel{display:none;}
    
    /* Disabilita animazioni e effetti pesanti in Modalit√† Screen Reader senza tastiera */
    body.accessible-mode *{
      animation: none !important;
      transition: none !important;
      backdrop-filter: none !important;
      filter: none !important;
      box-shadow: none !important;
      text-shadow: none !important;
      background-image: none !important;
    }
    
    /* Sfondi semplici per i pulsanti principali */
    body.accessible-mode .btn-spin{background: #b8860b !important;}
    body.accessible-mode .btn-vowel{background: #008b8b !important;}
    body.accessible-mode .btn-solve{background: #8b0000 !important;}
    body.accessible-mode button.action-btn{background: #222 !important;}
    
    /* Mantieni solo il focus outline */
    body.accessible-mode *:focus{
      box-shadow: 0 0 0 4px var(--col-neon) !important;
    }

    #wheel-visual-wrap{width:100%;display:flex;flex-direction:column;align-items:center;gap:8px;margin:8px 0;}
    #wheel-visual{
      width:220px;height:220px;border-radius:50%;
      border:4px solid #111;box-shadow:0 0 25px rgba(255,215,0,.15), inset 0 0 10px rgba(0,0,0,.8);
      background:conic-gradient(#ffd700 0deg 30deg,#00ffff 30deg 60deg,#ff4444 60deg 90deg,#00ff00 90deg 120deg,#ffd700 120deg 150deg,#00ffff 150deg 180deg,#ff4444 180deg 210deg,#00ff00 210deg 240deg,#ffd700 240deg 270deg,#00ffff 270deg 300deg,#ff4444 300deg 330deg,#00ff00 330deg 360deg);
      transition:transform 3s cubic-bezier(.12,.75,.2,1);
    }
    #wheel-pointer{width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:18px solid var(--col-accent);filter:drop-shadow(0 0 6px rgba(255,215,0,.6));margin-bottom:-6px;}

    #audio-panel{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;align-items:center;background:#222;border-top:2px solid #333;padding:15px;width:100%;position:relative;margin-top:40px;}
    #audio-panel button{min-height:auto;padding:10px 12px;border-radius:10px;font-size:1.1em;}
    #audio-panel .mutebtn{border-color:#777;background:#222;color:#ddd;}
    #audio-panel .label{color:#777;font-size:.85em;margin-right:6px;}

    #input-area, #privacy-dialog, #chat-overlay, #player-check-overlay, #round-over-panel, #end-panel, #pause-panel, #help-panel, #players-panel, #action-history-panel, #mystery-choice-overlay, #word-inspector-overlay, #result-popup {
      position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important;
      width: 100vw !important; height: 100vh !important; background: rgba(0,0,0,0.96) !important; z-index: 9999 !important;
      display: flex; flex-direction: column; justify-content: center; align-items: center; overflow-y: auto; backdrop-filter: blur(5px);
    }
    #result-popup .modal-content {
      background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
      border: 4px solid var(--col-neon);
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
    }
    #result-text {
      font-size: 2.5em;
      font-weight: bold;
      color: var(--col-accent);
      text-shadow: 0 0 20px var(--col-accent);
      margin: 30px 0;
      text-align: center;
    }
    .modal-content{background:#222;border:2px solid var(--col-neon);padding:20px;width:90%;max-width:500px;max-height: 90vh; overflow-y: auto; border-radius:15px;text-align:center;box-shadow:0 0 30px rgba(0,255,255,.2);}
    .inspector-tile{width:50px;height:70px;display:flex;align-items:center;justify-content:center;font-size:2em;font-weight:bold;background:#fff;color:#000;border-radius:8px;box-shadow:0 4px 8px rgba(0,0,0,.5);}
    .inspector-tile.empty{background:#333;color:#777;}
    .inspector-char-btn{display:flex;flex-direction:column;align-items:center;gap:5px;padding:15px;background:#222;border:2px solid #555;border-radius:8px;cursor:pointer;transition:all .2s;}
    .inspector-char-btn:hover, .inspector-char-btn:focus{background:#333;border-color:var(--col-neon);transform:scale(1.05);}
    input[type=text]{font-size:2em;padding:10px;text-align:center;width:90%;background:#000;color:#fff;border:2px solid #555;border-radius:8px;margin-bottom:20px;font-family:var(--font-main);text-transform:uppercase;}
    .history-item{display:block;width:100%;text-align:left;background:#111;color:#ddd;border:1px solid #333;border-radius:10px;padding:10px;margin:8px 0;font-size:1.05em;}
    .history-item strong{color:var(--col-accent);}

    @media (min-width:769px){
      .tile{width:50px;height:75px;font-size:2.5em;}
      .controls-grid{grid-template-columns:repeat(4,1fr);}
      button.action-btn{font-size:1.2em;}
    }
  </style>
</head>
<body aria-label="La Ruota - Gioco in corso">
  <!-- ‚úÖ SCREEN READER FIX: Cambiato in assertive + role alert per annuncio immediato
       aria-live="polite" causava la lettura di tutto il contenuto della pagina prima dell'annuncio.
       Con "assertive" + "alert", lo screen reader interrompe e annuncia SUBITO.
       Posizione: PRIMO elemento nel body per priorit√† massima. -->
  <div id="sr-announcer" class="sr-only" aria-live="assertive" role="alert" aria-atomic="true"></div>
  <div id="sr-chat" class="sr-only" aria-live="polite" role="status" aria-atomic="true"></div>
  <div id="flash-overlay" aria-hidden="true" style="position:fixed;top:20%;left:50%;transform:translate(-50%,-50%);font-size:2em;font-weight:bold;color:#fff;background:#000;padding:20px;border:3px solid #fff;opacity:0;pointer-events:none;transition:opacity .3s;z-index:5000;"><p id="flash-message"></p></div>

  <div style="display:flex; justify-content:space-between; width:95%; max-width:900px; margin:10px auto;">
    <button onclick="openHelp()" style="background:transparent; border:1px solid #555; color:#888; padding:5px 10px; border-radius:5px; font-size:0.8em;" aria-label="Aiuto tasti rapidi (H)">Aiuto (H)</button>
    <button onclick="toggleContrast()" style="background:transparent; border:1px solid #555; color:#888; padding:5px 10px; border-radius:5px; font-size:0.8em;">Contrasto</button>
    <button onclick="toggleAccessibleMode()" id="btn-acc-mode" style="background:transparent; border:1px solid #555; color:#fff; font-weight:bold; padding:5px 10px; border-radius:5px; font-size:0.8em;" aria-pressed="false">SCREEN READER SENZA TASTIERA</button>
    <button onclick="openActionHistory(true)" style="background:transparent; border:1px solid #555; color:#888; padding:5px 10px; border-radius:5px; font-size:0.8em;">Storico (A)</button>
  </div>

  <audio id="snd-spin" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/ruota.wav"></audio>
  <audio id="snd-hit" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/lettera%20presente.wav"></audio>
  <audio id="snd-miss" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/lettera%20assente.wav"></audio>
  <audio id="snd-turn" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/tocca_a_te.mp3"></audio>
  <audio id="snd-bankrupt" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/bancarotta.mp3"></audio>
  <audio id="snd-win" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/vittoria.mp3"></audio>
  <audio id="snd-clap" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/applausi.mp3"></audio>
  <audio id="snd-laugh" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/risata.mp3"></audio>
  <audio id="snd-boo" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/buuu.mp3"></audio>
  <audio id="snd-ooh" src="https://raw.githubusercontent.com/lellivalentina1992-lang/ruota/main/peccato.mp3"></audio>

  <div id="setup-panel" class="container">
    <h1 style="color:var(--col-accent); font-size:3em; margin-bottom:10px; text-shadow:0 0 20px rgba(255,215,0,0.3);">LA RUOTA</h1>
    
    <label for="inp-name" style="color:#fff; font-size:1.2em; display:block; margin-bottom:5px;">Nome Giocatore:</label>
    <div style="display:flex; gap:10px; align-items:center; width:90%; margin:0 auto;">
      <input id="inp-name" type="text" placeholder="NOME GIOCATORE" aria-label="Nome giocatore" aria-required="true" style="flex:1; margin-bottom:0;">
      <button onclick="document.getElementById('inp-name').value=''; document.getElementById('inp-name-display').textContent='(vuoto)'; document.getElementById('inp-name').focus();" class="action-btn" aria-label="Cancella nome" style="background:#cc0000; padding:10px 15px; min-height:auto; font-size:1em; margin-bottom:0;">CANC</button>
    </div>
    <div id="inp-name-display" style="color:#0f0; font-size:1.5em; min-height:1.5em; margin:5px 0 10px 0;" aria-hidden="true"></div>
    
    <label for="inp-code" style="color:#fff; font-size:1.2em; display:block; margin-bottom:5px; margin-top:10px;">
      Codice Stanza: <span style="color:#888; font-size:0.9em;">(scegli un codice per creare, es: AMICI23)</span>
    </label>
    <div style="display:flex; gap:10px; align-items:center; width:90%; margin:0 auto;">
      <input id="inp-code" type="text" placeholder="SCRIVI UN CODICE" aria-label="Codice stanza da creare o per entrare" aria-required="true" style="flex:1; margin-bottom:0;">
      <button onclick="document.getElementById('inp-code').value=''; document.getElementById('inp-code-display').textContent='(vuoto)'; document.getElementById('inp-code').focus();" class="action-btn" aria-label="Cancella codice" style="background:#cc0000; padding:10px 15px; min-height:auto; font-size:1em; margin-bottom:0;">CANC</button>
    </div>
    <div id="inp-code-display" style="color:#0f0; font-size:1.5em; min-height:1.5em; margin:5px 0 10px 0;" aria-hidden="true"></div>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; width:100%; margin-top:15px;">
      <button id="btn-create-room" class="action-btn btn-spin">CREA NUOVA STANZA</button>
      <button id="btn-join-room" class="action-btn btn-vowel">ENTRA<br><span style="font-size:0.8em;">(con codice)</span></button>
    </div>
    <div id="public-rooms-container" style="width:100%; margin-top:30px;">
      <button id="btn-refresh-rooms" class="action-btn" style="padding:10px;">AGGIORNA LISTA STANZE</button>
      <div id="rooms-list" style="width:100%; padding:10px; color:#aaa;"></div>
    </div>
  </div>

  <div id="pause-panel" class="hidden" role="alert">
    <div class="modal-content">
      <h1 style="color:red; font-size:3em;">PAUSA</h1>
      <p>GIOCO SOSPESO DALL'HOST</p>
      <button id="btn-resume-host" onclick="preResumeCheck()" class="action-btn btn-spin hidden" style="margin-top:20px;">RIPRENDI (HOST)</button>
    </div>
  </div>

  <div id="game-panel" class="container hidden">
    <div class="info-bar">
      <div id="timer-box" role="timer" aria-label="Tempo rimanente" class="timer-display">240</div>
      <div class="stats-display">
        <span id="round-indicator" style="color:#aaa;">R 1/10</span><br>
        <span id="turn-indicator" style="color:var(--col-green); font-weight:bold;">...</span>
      </div>
    </div>
    <div class="money-box">
      <span>GIRO: <span id="score-round" style="color:#fff;">0</span> ‚Ç¨</span>
      <span>TOT: <span id="score-total" style="color:#fff;">0</span> ‚Ç¨</span>
    </div>

    <div class="category-box">
      <h2 id="live-category" aria-live="polite" aria-atomic="true">
        <span id="category-main">...</span>
        <span id="round-hint"></span>
      </h2>
      <div id="jolly-indicator" class="hidden" style="color:#ff00ff; font-weight:bold; margin-top:5px; font-size:1.1em; text-shadow:0 0 5px #ff00ff;"></div>
      <div id="double-indicator" class="hidden" style="color:orange; font-weight:bold; margin-top:5px; font-size:1.1em; text-shadow:0 0 5px red; border:1px solid red; padding:2px;">RADDOPPIA ATTIVO! GIRA ANCORA!</div>
          <!-- ========== MODALIT√Ä SCREEN READER: STRUTTURA SEMPLIFICATA ========== -->
    <!-- 
    NAVIGAZIONE CON FLICK (scorrimento a destra):
    1. Intestazione "Comandi"
    2. Pulsante GIRA
    3. Pulsante VOCALE
    4. Pulsante PASSA (solo round speciali)
    5. Pulsante RISOLVI
    6. Altri comandi (collassabile)
    
    7. Intestazione "Tabellone"
    8. Riepilogo parole (es. "5 parole")
    9. Parola 1
    10. Parola 2
    11. Parola 3
    12. ...
    13. Pulsante RISOLVI (dopo le parole)
    -->
    
    <!-- ========== SEZIONE COMANDI ========== -->
    <h2 id="heading-gioco" style="color:var(--col-neon);font-size:1.8em;margin:20px auto 10px auto;text-align:left;width:95%;max-width:800px;">Comandi</h2>
    
    <div class="acc-nav" role="navigation" aria-label="Comandi principali di gioco">
      <!-- GIRA - pulsante principale -->
      <button id="btn-acc-spin" class="action-btn btn-spin" onclick="doSpin()" style="grid-column:1/-1;" aria-label="Gira la ruota per ottenere un valore">GIRA</button>
      
      <!-- VOCALE -->
      <button id="btn-acc-vowel" class="action-btn btn-vowel" onclick="tryOpenVowelInput()" style="grid-column:1/-1;">VOCALE</button>
      
      <!-- RISOLVI -->
      <button id="btn-acc-solve" class="action-btn btn-solve" onclick="openInput('solve')" style="grid-column:1/-1;">RISOLVI</button>
      
      <!-- Altri Comandi (collassabile) -->
      <button id="btn-acc-more" class="action-btn" onclick="toggleAccMoreCommands()" style="background:#333;border-color:#666;grid-column:1/-1;">
        ALTRI COMANDI ‚ñº
      </button>
      
      <div id="acc-more-commands" style="display:none;grid-column:1/-1;">
        <div style="display:grid;grid-template-columns:1fr;gap:8px;margin-top:8px;">
          <!-- PASSA TURNO rimosso: non serve nei round normali -->
          <button class="action-btn" onclick="openChat()">CHAT</button>
          <button class="action-btn" onclick="openPlayersPanel()">CLASSIFICA</button>
          <button class="action-btn" onclick="openHelp()">AIUTO</button>
          <button class="action-btn" style="background:#1a4d2e; border-color:#2ecc71;" onclick="announceTurn()">ANNUNCIA TURNO</button>
          <button class="action-btn" style="background:#1a4d2e; border-color:#2ecc71;" onclick="announceScore()">LEGGI PUNTEGGI</button>
          <button class="action-btn" onclick="readRevealedLetters()">LETTERE USCITE</button>
          <button class="action-btn" style="background:#2c3e50; font-size:0.9em;" onclick="playSharedAudio('snd-clap', 'Applauso')">APPLAUSO</button>
          <button class="action-btn" style="background:#2c3e50; font-size:0.9em;" onclick="playSharedAudio('snd-laugh', 'Risata')">RISATA</button>
          <button class="action-btn" style="background:#2c3e50; font-size:0.9em;" onclick="playSharedAudio('snd-boo', 'Fischi')">FISCHI</button>
          <button class="action-btn" style="background:#2c3e50; font-size:0.9em;" onclick="playSharedAudio('snd-ooh', 'Ooh')">OOH</button>
          <button class="action-btn" onclick="openActionHistory(true)">STORICO AZIONI</button>
          <button class="action-btn" onclick="toggleAudio()" id="btn-acc-audio">AUDIO</button>
        </div>
      </div>
    </div>
</div>

    <!-- Sezione comandi rimossa intestazione H3 ridondante -->
    <div class="top-controls-wrapper">
      <div class="controls-grid">
        <button id="btn-spin" class="action-btn btn-spin" onclick="doSpin()" aria-label="Gira la ruota per ottenere un valore">GIRA</button>
        <button id="btn-vowel" class="action-btn btn-vowel" onclick="tryOpenVowelInput()">VOCALE</button>
        <!-- PASSA e PASSA ALL'AVVERSARIO rimossi: non servono nei round normali (solo nella ruota/mistero) -->
        <button id="btn-inspect-word" class="action-btn" style="border-color:#555;background:#222;" onclick="openWordInspector()">ISPEZIONA PAROLA</button>
        <button id="btn-letters" class="action-btn" onclick="readRevealedLetters()" style="border-color:#aaa; background:#111; font-size:0.9em;">LETTERE USCITE</button>
      </div>
    </div>

    <!-- Sezione ruota rimossa intestazione H3 ridondante -->
    <div id="wheel-visual-wrap" role="region" aria-label="Ruota visuale">
      <div id="wheel-pointer" aria-hidden="true"></div>
      <div id="wheel-visual" aria-hidden="true"></div>
    </div>
    <div id="wheel-status-text" aria-live="off" aria-atomic="true" tabindex="-1" style="font-size:1.8em;font-weight:900;color:var(--col-accent);margin:10px 0;text-shadow:0 0 15px var(--col-accent);background:rgba(0,0,0,0.7);padding:15px 25px;border-radius:12px;border:2px solid var(--col-accent);min-height:60px;display:flex;align-items:center;justify-content:center;"></div>

    <!-- ========== SEZIONE TABELLONE ========== -->
    <h2 id="heading-tabellone" style="color:var(--col-neon);font-size:1.8em;margin:20px auto 10px auto;text-align:left;width:95%;max-width:800px;">Tabellone</h2>
    
    <div class="board-wrapper">
      <div id="board-container" role="grid" aria-label="Tabellone di gioco"></div>
    </div>
    
    <!-- TABELLONE ACCESSIBILE - Struttura lineare per flick -->
    <div id="accessible-board-container" role="region" aria-label="Tabellone testuale">
      <!-- Riepilogo numero parole - primo elemento dopo intestazione -->
      <div id="acc-board-summary" style="font-size:1.3em;padding:15px;margin-bottom:10px;"></div>
      
      <!-- Lista parole - ogni parola √® un elemento separato per flick -->
      <div id="acc-word-list" role="list" aria-label="Parole del tabellone"></div>
      
      <!-- PULSANTE RISOLVI subito dopo le parole -->
      <button id="btn-solve-after-board" class="action-btn btn-solve" onclick="openInput('solve')" 
              style="width:98%;max-width:800px;margin:20px auto;display:none;font-size:1.5em;padding:20px;letter-spacing:2px;grid-column:1/-1;">
        RISOLVI
      </button>
    </div>

    <!-- Sezione finale rimossa intestazione H3 ridondante -->
    <div class="bottom-controls-wrapper">
      <button id="btn-solve" class="action-btn btn-solve" onclick="openInput('solve')">RISOLVI FRASE</button>
      <button id="btn-surrender" class="action-btn hidden" onclick="surrenderPhrase()" style="background:linear-gradient(180deg,#8B0000,#400000); color:#fff; margin-top:10px; font-size:1.2em;">HOST: ARRENDITI</button>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px; margin-top:10px;">
        <button id="btn-chat" class="action-btn btn-chat" onclick="openChat()" style="font-size:0.8em; padding:10px;">CHAT (K)</button>
        <button id="btn-management" class="action-btn" onclick="openPlayersPanel()" style="font-size:0.8em; padding:10px; background:#222;">CLASSIFICA (S)</button>
      </div>
      <button id="btn-manual-cons" class="action-btn full-width hidden" style="background:var(--col-green); color:#000; margin-top:10px;" onclick="openInput('letter')">DI UNA CONSONANTE</button>
    </div>

    <button onclick="leaveGame()" style="background:transparent; border:none; color:#555; margin-top:30px; cursor:pointer;">ESCI</button>

    <div id="audio-panel">
      <span class="label">AUDIO:</span>
      <button class="action-btn" onclick="playAudio('snd-clap')" aria-label="Applauso">APPLAUSO</button>
      <button class="action-btn" onclick="playAudio('snd-laugh')" aria-label="Risata">RISATA</button>
      <button class="action-btn" onclick="playAudio('snd-boo')" aria-label="Buuu">BUUU</button>
      <button class="action-btn" onclick="playAudio('snd-ooh')" aria-label="Ohhh">OHHH</button>
      <button id="btn-mute" class="action-btn mutebtn" onclick="toggleMute()">AUDIO ON</button>
      <button id="btn-toggle-audio" class="action-btn mutebtn" onclick="toggleAudio()">Audio ON</button>
    </div>
  </div>

  <!-- ‚úÖ CORREZIONE 5: Input area NON ha role="alert" o aria-live
       Questo previene che NVDA legga l'intero modal prima di focalizzarsi sul campo.
       Il focus diretto sul campo √® sufficiente per l'accessibilit√†. -->
  <div id="input-area" class="hidden">
    <div class="modal-content">
      <h2 id="input-title" style="color:var(--col-accent);">INSERISCI</h2>
      <input id="game-input" type="text" autocomplete="off" inputmode="text" enterkeyhint="done" aria-label="Campo di inserimento testo" aria-describedby="input-title">
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
        <button onclick="submitInput()" class="action-btn btn-spin" style="grid-column:1/-1;">OK</button>
        <button id="btn-cancel-input" onclick="tryCancelInput()" class="action-btn btn-pass">ANNULLA</button>
      </div>
    </div>
  </div>

  <!-- Overlay SPECIALE per Modalit√† Screen Reader senza tastiera: input consonante a schermo intero -->
  <div id="accessible-letter-input" class="hidden" style="position:fixed;top:0;left:0;right:0;bottom:0;width:100vw;height:100vh;background:#000;z-index:10000;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:20px;">
    <div style="width:100%;max-width:600px;display:flex;flex-direction:column;gap:20px;">
      <h1 id="accessible-input-title" style="color:var(--col-accent);font-size:2em;margin:0;text-align:center;">INSERISCI CONSONANTE</h1>
      <p id="accessible-input-info" style="color:#fff;font-size:1.3em;margin:0;text-align:center;">Hai girato 800 ‚Ç¨</p>
      <input id="accessible-game-input" type="text" autocomplete="off" aria-label="Campo per inserire consonante" style="font-size:3em;padding:20px;text-align:center;width:100%;background:#111;color:#fff;border:4px solid var(--col-accent);border-radius:15px;font-family:var(--font-main);text-transform:uppercase;box-sizing:border-box;">
      <div style="display:grid;grid-template-columns:1fr;gap:15px;width:100%;">
        <button onclick="submitAccessibleLetterInput()" class="action-btn btn-spin" style="font-size:1.5em;padding:25px;">CONFERMA</button>
        <button onclick="showAccessibleRevealedLetters()" class="action-btn" style="background:#2c3e50;border-color:#3498db;font-size:1.3em;padding:20px;">LETTERE CHIAMATE</button>
        <button onclick="closeAccessibleLetterInput()" class="action-btn btn-pass" style="font-size:1.3em;padding:20px;">ANNULLA</button>
      </div>
    </div>
  </div>

  <div id="chat-overlay" class="hidden" role="dialog" aria-modal="true" aria-label="Finestra Chat">
    <div class="modal-content" style="height:80%; max-width:600px; display:flex; flex-direction:column;">
      <h2 style="color:var(--col-neon);">CHAT</h2>
      <div id="chat-messages" role="log" style="flex:1; overflow-y:auto; text-align:left; border:1px solid #444; padding:10px; margin-bottom:10px; background:#000; color:#ddd;"></div>
      <input id="chat-input" type="text" placeholder="Messaggio..." aria-label="Scrivi messaggio chat" style="font-size:1.2em; width:95%; margin-bottom:10px;">
      <div style="display:flex; gap:10px; width:100%;">
        <button onclick="sendChatMessage()" class="action-btn btn-vowel" style="flex:1;">INVIA</button>
        <button onclick="document.getElementById('chat-overlay').classList.add('hidden')" class="action-btn btn-pass" style="flex:1;">CHIUDI</button>
      </div>
    </div>
  </div>

  <div id="help-panel" class="hidden">
    <div class="modal-content" style="max-width:700px; text-align:left; max-height:85vh; overflow-y:auto;">
      <h1 style="color:var(--col-accent); text-align:center; margin-top:10px;">GUIDA COMPLETA</h1>
      
      <h2 style="color:var(--col-neon); margin-top:30px;">PULSANTI PRINCIPALI (in alto)</h2>
      <div style="color:#ddd; line-height:1.6;">
        <ul>
          <li><strong>Aiuto (H)</strong> - Apre questa guida</li>
          <li><strong>Contrasto</strong> - Cambia il tema dei colori per una migliore visibilit√†. Alterna tra tema normale e tema ad alto contrasto (nero/bianco/giallo/verde). Utile per persone con problemi di vista o in ambienti molto luminosi.</li>
          <li><strong>SCREEN READER SENZA TASTIERA</strong> - Modalit√† ottimizzata per chi usa lo screen reader da smartphone senza tastiera fisica. 
            <ul style="margin-top:8px; line-height:1.6;">
              <li><strong>SMARTPHONE SENZA TASTIERA:</strong> ATTIVA questa modalit√†! Il tabellone diventa testuale con pulsanti cliccabili. Avrai accesso a TUTTI i comandi tramite pulsanti dedicati (annuncia turno, punteggi, effetti sonori, ecc.). Ideale per NVDA Touch, TalkBack, VoiceOver.</li>
              <li><strong>PC o SMARTPHONE CON TASTIERA ESTERNA:</strong> LASCIA DISATTIVATA questa modalit√†! Usa il tabellone visuale standard e i tasti rapidi (G, V, R, P, T, D, ecc.). Molto pi√π veloce e comodo con la tastiera.</li>
              <li><strong>Importante:</strong> Se hai una tastiera Bluetooth/USB collegata allo smartphone, usa sempre la modalit√† STANDARD con i tasti rapidi, NON questa modalit√†!</li>
            </ul>
          </li>
          <li><strong>Storico (A)</strong> - Mostra tutte le azioni recenti del gioco (giri, lettere chiamate, passaggi di turno, ecc.)</li>
        </ul>
      </div>
      
      <h2 style="color:var(--col-neon); margin-top:30px;">PULSANTI HOST (solo per il creatore della stanza)</h2>
      <div style="color:#ddd; line-height:1.6;">
        <p>Questi pulsanti appaiono nella schermata <strong>CLASSIFICA (S)</strong> e sono disponibili solo per l'host:</p>
        <ul>
          <li><strong>PAUSA</strong> - Mette in pausa il gioco. Tutti i giocatori vedranno una schermata di pausa. Utile per fare una pausa o risolvere problemi tecnici. Premi di nuovo per riprendere.</li>
          <li><strong>RESET PARTITA</strong> - Azzera tutti i punteggi e ricomincia da capo. ATTENZIONE: questa azione cancella tutti i progressi!</li>
          <li><strong>ARRENDITI</strong> - L'host si arrende alla frase corrente. Il round termina e si passa al round successivo. Usalo se la frase √® troppo difficile o se nessuno riesce a risolverla.</li>
          <li><strong>BOT</strong> - Aggiunge un giocatore automatico (bot) alla partita. Il bot gioca in automatico quando √® il suo turno.</li>
        </ul>
      </div>
      
      <h2 style="color:var(--col-neon); margin-top:30px;">TASTI RAPIDI</h2>
      <ul style="line-height:1.8; color:#ddd; font-size:1.1em;">
        <li><strong>G</strong> o <strong>Ctrl+G</strong>: Gira la ruota</li>
        <li><strong>V</strong> o <strong>Ctrl+V</strong>: Compra vocale</li>
        <li><strong>R</strong> o <strong>Ctrl+R</strong>: Risolvi</li>
        <li><strong>P</strong> o <strong>Ctrl+P</strong>: Passa</li>
        <li><strong>T</strong> o <strong>Ctrl+T</strong>: Di chi √® il turno</li>
        <li><strong>K</strong> o <strong>Ctrl+K</strong>: Chat</li>
        <li><strong>S</strong> o <strong>Ctrl+S</strong>: Controlli e Classifica</li>
        <li><strong>L</strong> o <strong>Ctrl+L</strong>: Lettere uscite</li>
        <li><strong>A</strong> o <strong>Ctrl+A</strong>: Storico azioni</li>
        <li><strong>D</strong> o <strong>Ctrl+D</strong>: Ascolta punteggio (parziale e totale)</li>
        <li><strong>B</strong> o <strong>Ctrl+B</strong>: Aggiungi Bot veloce (Solo Host)</li>
        <li><strong>H</strong> o <strong>Ctrl+H</strong>: Aiuto</li>
        <li><strong>I</strong> o <strong>Ctrl+I</strong>: Ispeziona parola (modalit√† accessibile) - Apre una finestra che mostra tutte le lettere della parola corrente, sia quelle trovate che quelle nascoste. Puoi cliccare su una lettera per selezionarla.</li>
        <li><strong>Spazio</strong>: Riapri ultimo input</li>
        <li><strong>Frecce ‚Üë‚Üì‚Üê‚Üí (NAVIGAZIONE CON TASTIERA)</strong>: 
          <ul style="margin-top:8px; line-height:1.6;">
            <li><strong>Freccia DESTRA (‚Üí)</strong>: Passa al carattere successivo nella stessa parola</li>
            <li><strong>Freccia SINISTRA (‚Üê)</strong>: Torna al carattere precedente nella stessa parola</li>
            <li><strong>Freccia SU (‚Üë)</strong>: Passa alla parola precedente</li>
            <li><strong>Freccia GI√ô (‚Üì)</strong>: Passa alla parola successiva</li>
            <li><em>Nota: Le frecce sinistra/destra NON cambiano parola, rimangono sempre all'interno della parola corrente. Per cambiare parola usa SU/GI√ô.</em></li>
            <li><em>Il carattere selezionato viene evidenziato con un bordo dorato brillante per facilitare la navigazione visiva.</em></li>
          </ul>
        </li>
        <li><strong>ESC</strong>: Chiudi finestre</li>
        <li><strong>1-4</strong>: Effetti sonori (1=applauso, 2=risata, 3=fischi, 4=ooh)</li>
      </ul>
      
      <h2 style="color:var(--col-neon); margin-top:30px;">REGOLE DEL GIOCO</h2>
      <div style="color:#ddd; line-height:1.6;">
        <p><strong>La Ruota</strong> √® un gioco dove devi indovinare frasi nascoste lettera per lettera.</p>
        
        <h3 style="color:var(--col-accent);">Come si gioca:</h3>
        <ul>
          <li><strong>Gira la ruota (G)</strong> per scoprire quanto vale ogni consonante che indovini</li>
          <li><strong>Di una consonante</strong> quando la ruota si ferma - se √® presente guadagni il valore della ruota moltiplicato per il numero di volte che appare!</li>
          <li><strong>Compra vocale (V)</strong> costa tra 250‚Ç¨ e 2000‚Ç¨ (dipende dalla lunghezza della frase) ma ti aiuta a capire la frase. Puoi comprare solo una vocale per giro di ruota.</li>
          <li><strong>Risolvi (R)</strong> quando pensi di sapere la frase completa - se sbagli perdi il turno!</li>
          <li><strong>Passa (P)</strong> se non sai cosa fare - il turno passa al prossimo giocatore</li>
        </ul>
        
        <h3 style="color:var(--col-accent);">Settori speciali della ruota:</h3>
        <ul>
          <li><strong>BANCAROTTA / PERDE TUTTO</strong> - Perdi tutto il punteggio del round corrente E il punteggio totale! Il settore pi√π pericoloso.</li>
          <li><strong>PASSA TURNO</strong> - Il turno passa automaticamente al giocatore successivo</li>
          <li><strong>JOLLY</strong> - Ti protegge da bancarotta e passa turno! Puoi accumulare max 2 Jolly. Dura 5 round (compreso quello in cui lo prendi). Viene consumato automaticamente quando peschi uno di questi settori (ne usi 1 alla volta).</li>
          <li><strong>MISTERO (?)</strong> - Scegli se aprire (rischio/opportunit√†) o prendere 500‚Ç¨ sicuri. Aprendo il mistero puoi trovare: RADDOPPIA, BANCAROTTA, +1000‚Ç¨, JOLLY, PASSA TURNO o PASSA ALL'AVVERSARIO</li>
          <li><strong>RADDOPPIA</strong> - Il prossimo giro vale il doppio! Quando lo peschi, devi girare di nuovo e il valore sar√† moltiplicato x2.</li>
          <li><strong>+1000‚Ç¨</strong> - Aggiungi 1000‚Ç¨ al tuo punteggio di round e gira di nuovo!</li>
        </ul>
        
        <h3 style="color:var(--col-accent);">Punteggio:</h3>
        <ul>
          <li>Ogni consonante presente vale quanto indicato dalla ruota moltiplicato per quante volte appare</li>
          <li>Chi risolve la frase guadagna 1000‚Ç¨ bonus</li>
          <li>Il punteggio del round si aggiunge al totale quando qualcuno risolve</li>
          <li>Vince chi ha pi√π soldi alla fine della partita (default: 10 round)!</li>
        </ul>
        
        <h3 style="color:var(--col-accent);">Timer:</h3>
        <ul>
          <li>Hai 4 minuti (240 secondi) per ogni turno</li>
          <li>Il timer appare in alto a sinistra e diventa rosso quando √® il tuo turno</li>
          <li>Se il tempo scade, il turno passa automaticamente</li>
        </ul>
      </div>
      
      <h2 style="color:var(--col-neon); margin-top:30px;">ALTRI PULSANTI</h2>
      <div style="color:#ddd; line-height:1.6;">
        <ul>
          <li><strong>ISPEZIONA PAROLA</strong> - Apre una finestra dettagliata della parola su cui ti trovi, mostrando tutte le lettere</li>
          <li><strong>LETTERE USCITE</strong> - Legge ad alta voce tutte le lettere gi√† chiamate nel round corrente</li>
          <li><strong>CHAT (K)</strong> - Apre la chat per comunicare con gli altri giocatori</li>
          <li><strong>CLASSIFICA (S)</strong> - Mostra la classifica attuale, i punteggi di tutti i giocatori e (per l'host) i pulsanti di controllo del gioco</li>
          <li><strong>ESCI</strong> - Esci dalla stanza (in basso alla pagina)</li>
          <li><strong>Effetti audio</strong> - In fondo alla pagina trovi pulsanti per effetti sonori (applauso, risata, fischi, ooh) e controlli audio</li>
        </ul>
      </div>
      
      <button onclick="closeHelp()" class="action-btn btn-solve" style="margin:30px 0; width:100%;">TORNA ALLA RUOTA</button>
    </div>
  </div>

  <div id="players-panel" class="hidden" role="dialog">
    <div class="modal-content" style="max-width:700px; text-align:left;">
      <h2 style="color:var(--col-neon);">GIOCATORI E CLASSIFICA</h2>
      <div id="players-list" style="margin:20px 0;"></div>
      <button onclick="closePlayers()" class="action-btn full-width">TORNA ALLA RUOTA</button>
    </div>
  </div>

  <div id="action-history-panel" class="hidden" role="dialog" aria-label="Storico azioni">
    <div class="modal-content" style="max-width:700px; text-align:left;">
      <h2 style="color:var(--col-neon);">STORICO</h2>
      <div id="action-history-list" style="max-height:420px; overflow-y:auto;"></div>
      <button onclick="closeActionHistory()" class="action-btn full-width" style="margin-top:10px;">CHIUDI</button>
    </div>
  </div>

  <div id="mystery-choice-overlay" class="hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <h2 id="mystery-title" style="color:var(--col-neon);">MISTERO</h2>
      <p id="mystery-desc" style="color:#ddd; font-size:1.1em; line-height:1.4;">
        Vuoi aprire il Mistero oppure prendere <strong>500‚Ç¨</strong> in palio?
      </p>
      <div style="display:grid; grid-template-columns:1fr; gap:10px; margin-top:15px;">
        <button id="btn-mystery-open" class="action-btn btn-spin" onclick="chooseMystery(true)">APRI IL MISTERO</button>
        <button id="btn-mystery-500" class="action-btn btn-vowel" onclick="chooseMystery(false)">PRENDI 500‚Ç¨ IN PALIO</button>
      </div>
      <button onclick="chooseMystery(false)" style="margin-top:10px; background:none; border:none; color:#aaa;">ANNULLA (ESC)</button>
    </div>
  </div>

  <div id="word-inspector-overlay" class="hidden" role="dialog" aria-modal="true">
    <div class="modal-content">
      <h2 id="inspector-title" style="color:var(--col-neon);">ISPEZIONA PAROLA</h2>
      <div id="inspector-letters-container" style="margin:20px 0;"></div>
      <button onclick="closeWordInspector()" class="action-btn full-width">TORNA ALLA RUOTA</button>
    </div>
  </div>

  <div id="player-check-overlay" class="hidden" role="dialog" aria-modal="true" aria-label="Appello presenze">
    <div class="modal-content">
      <h2 style="color:orange;">APPELLO PRESENZE</h2>
      <p style="color:#ddd; line-height:1.4;">Controlla chi risulta in stanza.</p>
      <div id="player-check-list" style="text-align:left; margin:20px 0; max-height:300px; overflow-y:auto;"></div>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; width:100%;">
        <button id="btn-confirm-resume" onclick="confirmResumeGame()" class="action-btn btn-spin">RIPRENDI ORA</button>
        <button onclick="closePlayerCheckOverlay()" class="action-btn btn-pass">ASPETTA</button>
      </div>
    </div>
  </div>

  <div id="round-over-panel" class="hidden">
    <div class="modal-content">
      <h2 style="color:var(--col-green);">FINE ROUND</h2>
      <p id="round-winner-msg" style="font-size:1.2em; color:#fff;"></p>
      <p id="solution-msg" style="color:var(--col-accent); font-size:1.5em; font-weight:bold; margin:20px 0;"></p>
      <p>Prossimo round: <span id="next-round-timer">15</span>s</p>
      <button onclick="startNewRound()" id="btn-host-next" class="action-btn btn-spin full-width hidden">AVVIA ORA (HOST)</button>
    </div>
  </div>

  <div id="end-panel" class="hidden">
    <div class="modal-content">
      <h2 style="color:var(--col-accent);">CLASSIFICA FINALE</h2>
      <ul id="ranking-list" style="list-style:none; padding:0; text-align:left;"></ul>
      <button id="btn-new-game" onclick="resetGame()" class="action-btn btn-spin full-width hidden" style="margin:10px 0;">NUOVA PARTITA (HOST)</button>
      <button onclick="leaveGame()" class="action-btn btn-pass full-width">ESCI</button>
    </div>
  </div>

  <div id="privacy-dialog" class="hidden">
    <div class="modal-content">
      <h2>TIPO STANZA</h2>
      <div style="display:flex; gap:10px;">
        <button onclick="createRoomFinal(true)" class="action-btn btn-vowel" style="flex:1;">PUBBLICA</button>
        <button onclick="createRoomFinal(false)" class="action-btn btn-pass" style="flex:1;">PRIVATA</button>
      </div>
      <button onclick="document.getElementById('privacy-dialog').classList.add('hidden')" style="margin-top:10px; background:none; border:none; color:#aaa;">ANNULLA</button>
    </div>
  </div>

  <div id="result-popup" class="hidden">
    <div class="modal-content">
      <h2 style="color:var(--col-neon); margin-bottom:20px;">RISULTATO</h2>
      <div id="result-text"></div>
      <button onclick="closeResultPopup()" class="action-btn btn-spin" style="font-size:1.5em; padding:20px 40px; margin-top:20px;">OK</button>
    </div>
  </div>

  <script>
    

    const NATO = {
      'A':'Ancona','B':'Bologna','C':'Como','D':'Domodossola','E':'Empoli','F':'Firenze','G':'Genova','H':'Hotel','I':'Imola',
      'J':'Jolly','K':'Kappa','L':'Livorno','M':'Milano','N':'Napoli','O':'Otranto','P':'Palermo','Q':'Quadro','R':'Roma',
      'S':'Savona','T':'Torino','U':'Udine','V':'Venezia','W':'Washington','X':'Xilofono','Y':'Yogurt','Z':'Zara',
      '√Ä':'A accentata','√à':'E aperta','√â':'E chiusa','√å':'I accentata','√í':'O accentata','√ô':'U accentata',
      "'":"Apostrofo","?":"Punto di domanda","!":"Punto esclamativo",".":"Punto",",":"Virgola"
    };

    const WHEEL_VALUES=[100,200,300,400,500,600,700,800,900,1000,2000,'MISTERO','PASSA','BANCAROTTA','JOLLY'];
    const MISTERO_VALUES=['RADDOPPIA','BANCAROTTA','PASSA','PASSA_AVVERSARIO','+1000','JOLLY'];
    const TURN_LIMIT_SEC=240;
    const MAX_PLAYERS=3;

    let myId, myIndex, roomId, isHost=false;
    let currentFrase=null, currentStanza=null, currentPuzzleText="", currentHintText="", fullSolutionText="";
    // ‚úÖ FIX: Testo puzzle senza tema/hint (solo la parte da indovinare)
    let currentPuzzleTextWithoutHint = "";
    // ‚úÖ FIX: Variabili per congelare lo stato quando si apre RISOLVI
    let frozenSolvePuzzleText = null;
    let frozenSolveFraseId = null;
    let frozenSolveRevealedLetters = null;
    
    // ‚úÖ RIMOSSA: getRevealedLettersWithHint() non serve pi√π
    // Il tabellone ora mostra solo currentPuzzleTextWithoutHint, quindi gli indici
    // in lettere_rivelate puntano direttamente alle lettere da indovinare
    
    let lastTimestamp="", isSpinning=false, inputMode=null, parsedBoard=[], localAnnouncementMade=false;
    let isFetching=false, isProcessingInput=false, isHandlingTimeout=false, actionJustCompleted=false;
    let processingInputTimeout=null; // ‚úÖ Timeout di sicurezza per isProcessingInput
    let vowelsBoughtThisTurn=0, wasMyTurn=false, wasBotTurn=false;
    let actionHistory=[];
    let isAccessibleMode=false;
    let speechTimeouts=[];
    let nextRoundInterval=null;
    let isMuted=false;
    let wheelRotation=0;
    let navWordIdx = 0, navCharIdx = 0;
    let lastInputMode = null;
    let spellingTimer = null;
    let nextRoundSec = 15;
    let lastSpinTimestamp = null; 
    
    let lastAutoPassTime = 0;
    let isBotThinking = false;
    const BOT_BREATH_TIME = 200; // ‚úÖ VELOCIZZATO: 200ms - Pausa tra azioni bot
    
    // ‚úÖ FIX MEMORY LEAK: Funzione globale per convertire input in maiuscolo
    // Definita una sola volta, pu√≤ essere rimossa e ri-aggiunta senza accumulo
    const uppercaseInputHandler = function(e) {
      // ‚úÖ NUOVO: Questo handler viene chiamato DOPO che l'utente ha gi√† digitato
      // Quindi il valore contiene gi√† la nuova lettera
      
      const cursorPos = e.target.selectionStart;
      const value = e.target.value;
      
      // ‚úÖ STRATEGIA: Rimuovi asterischi ADIACENTI alle lettere che l'utente ha appena scritto
      // Esempio: "A*ORE" ‚Üí utente scrive "M" in posizione 1 ‚Üí "AMORE"
      // L'asterisco vicino viene rimosso automaticamente
      
      let result = '';
      let isStartOfSentence = true;
      let skipNext = false;
      
      for(let i = 0; i < value.length; i++) {
        if(skipNext) {
          skipNext = false;
          continue;
        }
        
        const char = value[i];
        const nextChar = value[i + 1];
        
        // Se questa √® una lettera E il prossimo √® asterisco ‚Üí salta asterisco
        if(/[A-Z√Ä-√ôa-z√†-√π]/.test(char) && nextChar === '*') {
          result += isStartOfSentence ? char.toUpperCase() : char.toLowerCase();
          skipNext = true; // Salta asterisco successivo
          isStartOfSentence = false;
        }
        // Se questo √® asterisco E il prossimo √® lettera ‚Üí salta asterisco
        else if(char === '*' && nextChar && /[A-Z√Ä-√ôa-z√†-√π]/.test(nextChar)) {
          // Salta questo asterisco, sar√† processato con la lettera successiva
          continue;
        }
        // Se √® un asterisco normale (isolato o parte di sequenza)
        else if(char === '*') {
          result += char;
          isStartOfSentence = false;
        }
        // Se √® una lettera
        else if(/[A-Z√Ä-√ôa-z√†-√π]/.test(char)) {
          result += isStartOfSentence ? char.toUpperCase() : char.toLowerCase();
          isStartOfSentence = false;
        }
        // Spazi, punteggiatura
        else {
          result += char;
          if(/[.!?]/.test(char)) {
            isStartOfSentence = true;
          }
        }
      }
      
      e.target.value = result;
      e.target.setSelectionRange(cursorPos - (value.length - result.length), cursorPos - (value.length - result.length));
    };
    
    // ‚úÖ NUOVO: Handler separato per RISOLVI che sostituisce SOLO l'asterisco dove digiti
    // NON rimuove asterischi adiacenti o in altre posizioni
    let lastSolveValue = ''; // Memorizza il valore precedente
    
    // ‚úÖ CORREZIONE CRITICA BUG 10 (segnalato da utente):
    // La logica di sostituzione asterischi era troppo complessa e causava:
    // - Spostamento lettere in posizioni sbagliate
    // - Conversione automatica maiuscole/minuscole che rompeva parole tipo "CHE"
    // - Confusione per screen reader
    //
    // SOLUZIONE SEMPLICE: Campo vuoto, l'utente scrive la soluzione completa
    const solveInputHandler = function(e) {
      const cursorPos = e.target.selectionStart;
      let newValue = e.target.value;
      
      // ‚úÖ NON applicare formattazione automatica maiuscole/minuscole
      // L'utente scrive come vuole, il confronto sar√† case-insensitive con cleanStr()
      
      // Limita lunghezza massima per prevenire spam
      const maxLength = 200;
      if(newValue.length > maxLength) {
        newValue = newValue.substring(0, maxLength);
        e.target.value = newValue;
      }
      
      lastSolveValue = newValue;
      e.target.setSelectionRange(cursorPos, cursorPos);
    };
    
    // ‚úÖ RIMOSSA formatSolveText() - Non serve pi√π!
    // Il confronto in submitInput usa cleanStr() che √® case-insensitive
    
    // Helper per resettare isBotThinking con delay
    function botFinishAction(delayMs = BOT_BREATH_TIME) {
      TimerManager.setTimeout(() => {
        isBotThinking = false;
      }, delayMs);
    }
    
    // ‚úÖ Helper per formattare categorie: Prima maiuscola, resto minuscolo
    function formatCategory(cat) {
      if(!cat || typeof cat !== 'string') return '';
      return cat.toLowerCase().replace(/\b\w/g, c => c.toUpperCase());
    }
    
    let previousPlayersList = []; 
    
    
    let lettersCalledThisRound = []; 
        
    // Cleanup variables
    let gameChannel = null;
    let playersChannel = null; // ‚úÖ CORREZIONE CHATGPT: Channel per subscription giocatori
    let chatChannel = null;
    let turnTimerInterval = null;
    let pingInterval = null; // ‚úÖ CORREZIONE CHATGPT: Intervallo per ping periodico
    
    // ‚úÖ CORREZIONE 2: Offset temporale tra server e client
    // Utilizzato per calcolare il tempo rimanente in modo affidabile
    let serverTimeOffset = 0; // in millisecondi
    
    
    // NOTA: La protezione dei dati sensibili viene gestita tramite Row Level Security (RLS)
    // su Supabase. Non √® necessaria oscuramento lato client che pu√≤ causare problemi.
    
    
    
    const FREQ_CONS_GROUPS = [
      ['R','T','N'],        
      ['S','L','C'],        
      ['D','P','M'],        
      ['G','B','F','V']     
    ];
    const FREQ_VOW_GROUPS = [
      ['A','E'],            
      ['I','O'],            
      ['U']                 
    ];

    document.addEventListener('DOMContentLoaded', () => {
      // ‚úÖ FIX: Non pre-compilare i campi automaticamente
      // Gli utenti con screen reader preferiscono campi vuoti
      // I valori vengono comunque salvati quando si entra in una stanza
      
      const inpName = document.getElementById('inp-name');
      const inpCode = document.getElementById('inp-code');
      const displayName = document.getElementById('inp-name-display');
      const displayCode = document.getElementById('inp-code-display');
      
      // Inizializza i display come vuoti
      if(displayName) displayName.textContent = '(vuoto)';
      if(displayCode) displayCode.textContent = '(vuoto)';
      
      document.getElementById('btn-create-room')?.addEventListener('click', () => askPrivacy());
      document.getElementById('btn-join-room')?.addEventListener('click', () => joinGame(false));
      document.getElementById('btn-refresh-rooms')?.addEventListener('click', () => fetchPublicRooms());

      
      document.getElementById('inp-name')?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          
          const name = document.getElementById('inp-name').value.trim();
          if (name) {
            document.getElementById('inp-code')?.focus();
          }
        }
      });
      
      document.getElementById('inp-code')?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          
          const code = document.getElementById('inp-code').value.trim();
          if (code) {
            joinGame(false);
          } else {
            askPrivacy();
          }
        }
      });
      
      // Aggiorna display per inp-name
      document.getElementById('inp-name')?.addEventListener('input', (e) => {
        const value = e.target.value;
        const display = document.getElementById('inp-name-display');
        if(display){
          display.textContent = value || '(vuoto)';
        }
      });
      
      // Aggiorna display per inp-code
      document.getElementById('inp-code')?.addEventListener('input', (e) => {
        const value = e.target.value;
        const display = document.getElementById('inp-code-display');
        if(display){
          display.textContent = value || '(vuoto)';
        }
      });

      document.getElementById('game-input')?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            submitInput();
        }
      });
      
      document.getElementById('chat-input')?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            sendChatMessage();
        }
      });
      
      
      const hash = window.location.hash;
      if(hash && hash.startsWith('#stanza=')){
        const roomCode = hash.replace('#stanza=', '');
        if(roomCode && typeof roomCode === 'string'){
          const upperRoomCode = roomCode.toUpperCase();
          document.getElementById('inp-code').value = upperRoomCode;
          speak(`Link rilevato: stanza ${upperRoomCode}. Inserisci il tuo nome e premi Entra.`);
        }
      }
    });

    function clearSpeechQueue(){ if(speechTimeouts && Array.isArray(speechTimeouts)) speechTimeouts.forEach(t=>TimerManager.clearTimeout(t)); speechTimeouts=[]; }
    // ‚úÖ CORREZIONE 5: Debounce per evitare saturazione sr-announcer
    let lastSpeakTime = 0;
    const SPEAK_DEBOUNCE_MS = 200; // Minimo 200ms tra annunci
    
    function speak(t){
      if(!t) return;
      
      // ‚úÖ CORREZIONE 5: Previeni saturazione degli annunci
      const now = Date.now();
      if(now - lastSpeakTime < SPEAK_DEBOUNCE_MS) {
        console.log('[Speak] Debounced:', t);
        return; // Ignora annunci troppo ravvicinati
      }
      lastSpeakTime = now;
      
      const e=document.getElementById('sr-announcer');
      
      // ‚úÖ NVDA FIX: NON usare il "flicker" (svuota/riempi)
      // Il pattern e.textContent=''; setTimeout(()=>e.textContent=t, 50);
      // causa un "sussulto" del cursore virtuale che pu√≤ far uscire NVDA da Focus Mode
      // 
      // SOLUZIONE: Aggiungi un carattere zero-width space invisibile per forzare
      // NVDA a rilevare il cambiamento senza causare il flicker visivo del DOM
      clearSpeechQueue();
      
      // Alterna tra testo normale e testo con zero-width space
      // Questo forza NVDA a rilevare il cambiamento anche se il testo √® uguale
      const currentText = e.textContent;
      const hasZWS = currentText.endsWith('\u200B');
      const newText = hasZWS ? t : t + '\u200B';
      
      e.textContent = newText;
    }
    function speakChat(t){
      if(!t) return;
      const e=document.getElementById('sr-chat');
      
      // ‚úÖ NVDA FIX: Stesso problema di speak() - elimina il flicker
      // Usa zero-width space invece di svuotare/riempire
      const currentText = e.textContent;
      const hasZWS = currentText.endsWith('\u200B');
      const newText = hasZWS ? t : t + '\u200B';
      
      e.textContent = newText;
    }
    function playAudio(id){
      if(isMuted) return;
      const a=document.getElementById(id);
      if(a){ a.pause(); a.currentTime=0; a.play().catch(()=>{}); }
    }
    
    async function playSharedAudio(soundId, soundName){
      // Riproduci localmente
      playAudio(soundId);
      
      // Condividi con tutti i giocatori
      if(roomId && myId){
        const myName = document.getElementById('inp-name').value;
        const message = `[SOUND:${soundId}]${soundName}`;
        await _supabase.from('chat_messaggi').insert({
          stanza_id: roomId, 
          giocatore_nome: myName, 
          messaggio: message
        });
      }
    }
    let multipleHitsTimeouts = []; // ‚úÖ FIX: Array per tracciare i timeout attivi
    
    function playMultipleHits(count) {
        // ‚úÖ FIX: Cancella qualsiasi timeout precedente ancora in esecuzione
        if(multipleHitsTimeouts && Array.isArray(multipleHitsTimeouts)) multipleHitsTimeouts.forEach(timeout => TimerManager.clearTimeout(timeout));
        multipleHitsTimeouts = [];
        
        // ‚úÖ FIX: Riproduci UN beep per OGNI lettera trovata
        // Il primo beep parte subito, poi uno ogni 250ms
        if(count >= 1) {
            playAudio('snd-hit'); // Primo beep immediato
            
            // Beep successivi con delay
            for(let i = 1; i < count; i++) {
                const timeout = TimerManager.setTimeout(() => playAudio('snd-hit'), i * 250);
                multipleHitsTimeouts.push(timeout);
            }
        }
    }
    function toggleMute(){
      isMuted=!isMuted;
      document.getElementById('btn-mute').textContent = isMuted ? 'AUDIO OFF' : 'AUDIO ON';
      speak(isMuted ? "Audio disattivato" : "Audio attivato");
    }
    // ‚úÖ CORREZIONE 4: Normalizzazione migliorata per il confronto delle soluzioni
    function cleanStr(s) { 
      if(!s || typeof s !== 'string') return "";
      
      return s
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "") // Rimuove accenti
        .replace(/['']/g, "'")            // ‚úÖ Normalizza apostrofi curvi ‚Üí dritti
        .replace(/\s+/g, " ")             // ‚úÖ Normalizza spazi multipli ‚Üí singolo
        .trim()                            // Rimuove spazi iniziali/finali
        .replace(/[^a-z0-9' ]/g, "");     // ‚úÖ Mantieni apostrofi e spazi per confronto naturale
    }
    
    
    function getNextConsonantHuman(alreadyRevealed){
      // üß† INTELLIGENZA SEMANTICA: Prova a completare parole quasi finite
      const smartLetter = tryCompleteWord(alreadyRevealed);
      // ‚úÖ FIX CRITICO: VERIFICA che smartLetter NON sia una vocale!
      // Le vocali si comprano, non si chiamano dopo aver girato la ruota!
      if(smartLetter && !"AEIOU".includes(smartLetter.toUpperCase())) {
        return smartLetter;
      }
      
      // Fallback: usa frequenze statistiche
      for(let group of FREQ_CONS_GROUPS){
        const shuffled = shuffle(group);
        for(let c of shuffled){
          if(!alreadyRevealed.includes(c)) return c;
        }
      }
      return null;
    }
    
    function tryCompleteWord(alreadyRevealed){
      // Analizza il parsedBoard per trovare parole con 1-2 lettere mancanti
      if(!parsedBoard || parsedBoard.length === 0) return null;
      
      const vowels = ['A','E','I','O','U'];
      const allRevealed = (alreadyRevealed || []).filter(l => l && typeof l === 'string').map(l => l.toUpperCase());
      
      // Costruisci una rappresentazione delle parole con _ per lettere nascoste
      const wordsWithBlanks = parsedBoard.map(wordObj => {
        let word = '';
        wordObj.chars.forEach(charData => {
          if(!charData.isLetter) {
            word += charData.char; // Punteggiatura rimane
          } else if(charData.isRevealed) {
            word += charData.char; // Lettera rivelata
          } else {
            word += '_'; // Lettera nascosta
          }
        });
        return word.toUpperCase();
      });
      
      // Dizionario di pattern comuni per parole italiane
      const patterns = [
        // Pattern con 1 lettera mancante
        {pattern: /^G_TTO$/i, missing: 1, suggest: 'A'}, // GATTO
        {pattern: /^C_NE$/i, missing: 1, suggest: 'A'}, // CANE
        {pattern: /^C_SA$/i, missing: 1, suggest: 'A'}, // CASA
        {pattern: /^M_RE$/i, missing: 1, suggest: 'A'}, // MARE
        {pattern: /^P_NE$/i, missing: 1, suggest: 'A'}, // PANE
        {pattern: /^S_LE$/i, missing: 1, suggest: 'O'}, // SOLE
        {pattern: /^L_NA$/i, missing: 1, suggest: 'U'}, // LUNA
        {pattern: /^V_NO$/i, missing: 1, suggest: 'I'}, // VINO
        {pattern: /^F_ME$/i, missing: 1, suggest: 'A'}, // FAME
        {pattern: /^R_SO$/i, missing: 1, suggest: 'I'}, // RISO
        {pattern: /^_ORA$/i, missing: 1, suggest: 'O'}, // ORA -> MORA, NORA...
        {pattern: /^PI_ZA$/i, missing: 1, suggest: 'Z'}, // PIZZA
        {pattern: /^PA_TA$/i, missing: 1, suggest: 'S'}, // PASTA
        {pattern: /^_ORTE$/i, missing: 1, suggest: 'P'}, // PORTE
        {pattern: /^LI_RO$/i, missing: 1, suggest: 'B'}, // LIBRO
        {pattern: /^MO_DO$/i, missing: 1, suggest: 'N'}, // MONDO
        {pattern: /^TE_PO$/i, missing: 1, suggest: 'M'}, // TEMPO
        {pattern: /^_IOCO$/i, missing: 1, suggest: 'G'}, // GIOCO
        {pattern: /^_UOCO$/i, missing: 1, suggest: 'F'}, // FUOCO
        {pattern: /^FI_ME$/i, missing: 1, suggest: 'L'}, // FILME
        {pattern: /^_ONTE$/i, missing: 1, suggest: 'F'}, // FONTE
        {pattern: /^CA_TO$/i, missing: 1, suggest: 'N'}, // CANTO
        {pattern: /^_ESTO$/i, missing: 1, suggest: 'T'}, // TESTO
        {pattern: /^VI_A$/i, missing: 1, suggest: 'T'}, // VITA
        
        // Pattern con 2 lettere mancanti
        {pattern: /^G__TO$/i, missing: 2, suggest: 'T'}, // GATTO (manca T se manca anche A)
        {pattern: /^C__E$/i, missing: 2, suggest: 'N'}, // CANE (manca N)
        {pattern: /^C__A$/i, missing: 2, suggest: 'S'}, // CASA (manca S)
        {pattern: /^M__E$/i, missing: 2, suggest: 'R'}, // MARE (manca R)
        {pattern: /^P__E$/i, missing: 2, suggest: 'N'}, // PANE (manca N)
        {pattern: /^S__E$/i, missing: 2, suggest: 'L'}, // SOLE (manca L)
        {pattern: /^L__A$/i, missing: 2, suggest: 'N'}, // LUNA (manca N)
        {pattern: /^V__O$/i, missing: 2, suggest: 'N'}, // VINO (manca N)
        {pattern: /^PI__A$/i, missing: 2, suggest: 'Z'}, // PIZZA (manca Z)
        {pattern: /^PA__A$/i, missing: 2, suggest: 'S'}, // PASTA (manca S)
        {pattern: /^LI__O$/i, missing: 2, suggest: 'B'}, // LIBRO (manca B)
        {pattern: /^MO__O$/i, missing: 2, suggest: 'N'}, // MONDO (manca N)
        {pattern: /^TE__O$/i, missing: 2, suggest: 'M'}, // TEMPO (manca M)
        
        // Pattern comuni di fine parola
        {pattern: /_IONE$/i, missing: 0, suggest: 'Z'}, // -ZIONE
        {pattern: /_MENTE$/i, missing: 0, suggest: 'L'}, // -MENTE
        {pattern: /_ZZO$/i, missing: 0, suggest: 'P'}, // -AZZO, -OZZO
        {pattern: /AZIO_E$/i, missing: 0, suggest: 'N'}, // -AZIONE
        {pattern: /_TTO$/i, missing: 0, suggest: 'T'}, // -ETTO, -ATTO, -OTTO
      ];
      
      // Analizza ogni parola
      for(const word of wordsWithBlanks){
        const blankCount = (word.match(/_/g) || []).length;
        
        // Considera solo parole con 1-2 lettere mancanti
        if(blankCount < 1 || blankCount > 2) continue;
        
        // Prova ogni pattern
        for(const p of patterns){
          if(p.pattern.test(word) && p.suggest && typeof p.suggest === 'string'){
            const suggestedLetter = p.suggest.toUpperCase();
            
            // Verifica che non sia gi√† stata chiamata e non sia una vocale
            if(!allRevealed.includes(suggestedLetter) && !vowels.includes(suggestedLetter)){
              return suggestedLetter;
            }
          }
        }
        
        // Analisi generica: se manca solo 1 lettera, prova consonanti comuni nell'ordine
        if(blankCount === 1){
          const commonConsonants = ['N', 'R', 'T', 'L', 'S', 'C', 'D', 'P', 'M', 'B', 'G', 'V', 'F', 'Z'];
          for(const c of commonConsonants){
            if(!allRevealed.includes(c)){
              return c;
            }
          }
        }
      }
      
      return null; // Nessun completamento trovato
    }
    
    function getNextVowelHuman(alreadyRevealed){
      for(let group of FREQ_VOW_GROUPS){
        const shuffled = shuffle(group);
        for(let v of shuffled){
          if(!alreadyRevealed.includes(v)) return v;
        }
      }
      return null;
    }
    
    function setBtnState(id,d){ const b=document.getElementById(id); if(!b) return; if(d){ b.disabled=true; b.setAttribute('aria-disabled','true'); } else { b.disabled=false; b.setAttribute('aria-disabled','false'); } }
    function isBtnDisabled(id){ const b=document.getElementById(id); return b && b.getAttribute('aria-disabled')==='true'; }
    function showFlashMessage(msg,type){
      const ov=document.getElementById('flash-overlay'),txt=document.getElementById('flash-message');
      txt.textContent=msg; txt.style.color=type==='bad'?'#f00':(type==='good'?'#0f0':'#ffd700');
      ov.style.borderColor=txt.style.color; ov.style.opacity=1; TimerManager.setTimeout(()=>{ ov.style.opacity=0; },4000);
    }

    function jumpToSection(id){
      const el = document.getElementById(id);
      if(!el) return;
      el.scrollIntoView({behavior:'smooth', block:'start'});
      TimerManager.setTimeout(()=>{ try{ el.focus({preventScroll:true}); } catch(e){ try{ el.focus(); }catch(_){ } } }, 250);
    }

    function toggleContrast(){ document.body.classList.toggle('high-contrast'); speak("Contrasto cambiato"); }
    function openHelp(){ 
      const panel = document.getElementById('help-panel');
      panel.classList.remove('hidden'); 
      // ‚úÖ FIX: Rendi il pannello focusable e dai il focus
      panel.setAttribute('tabindex', '0');
      panel.setAttribute('role', 'dialog');
      panel.setAttribute('aria-modal', 'true');
      panel.setAttribute('aria-label', 'Aiuto e tasti rapidi');
      TimerManager.setTimeout(() => {
        panel.focus();
        speak("Aiuto aperto. Usa frecce per scorrere, ESC o bottone Chiudi per uscire.");
      }, 100);
    }
    function closeHelp(){ 
      document.getElementById('help-panel').classList.add('hidden'); 
      speak("Aiuto chiuso");
    }
    function addActionToHistory(txt){
      actionHistory.unshift({text:txt, time:new Date().toLocaleTimeString()});
      if(actionHistory.length>50) actionHistory.pop();
    }
    
    
    function showResultPopup(message, speakMessage = null){
      document.getElementById('result-text').textContent = message;
      document.getElementById('result-popup').classList.remove('hidden');
      speak(speakMessage || message);
      addActionToHistory(message); 
      TimerManager.setTimeout(() => {
        const btn = document.getElementById('result-popup').querySelector('button');
        if(btn) btn.focus();
      }, 100);
    }
    
    function closeResultPopup(){
      document.getElementById('result-popup').classList.add('hidden');
      // In modalit√† screen reader senza tastiera, ritorna focus su GIRA
      if(isAccessibleMode){
        TimerManager.setTimeout(()=> document.getElementById('btn-acc-spin')?.focus(), 100);
      }
    }
    
    function openActionHistory(focusFirst=false){
      document.getElementById('action-history-panel').classList.remove('hidden');
      const c=document.getElementById('action-history-list'); c.innerHTML='';
      if(!actionHistory.length){
        c.innerHTML='<p style="color:#aaa;">Nessuna azione.</p>';
      } else {
        if(actionHistory && Array.isArray(actionHistory)) actionHistory.forEach((a, idx)=>{
          const b=document.createElement('button');
          b.className='history-item';
          b.type='button';
          b.dataset.idx=idx;
          b.innerHTML = `<strong>${escapeHTML(a.time)}</strong> ‚Äî ${escapeHTML(a.text)}`;
          b.onclick = ()=> speak(`${a.time}. ${a.text}`);
          c.appendChild(b);
        });
      }
      speak("Storico aperto. Usa freccia su e gi√π per navigare.");
      if(focusFirst){
        TimerManager.setTimeout(()=>{ const first=c.querySelector('.history-item'); if(first) first.focus(); },60);
      }
    }
    function closeActionHistory(){ document.getElementById('action-history-panel').classList.add('hidden'); }

    let mysteryChoiceResolver = null;
    let isMysteryModalOpen = false;

    function openMysteryModal(){
      if(isMysteryModalOpen) return;
      isMysteryModalOpen = true;
      const ov = document.getElementById('mystery-choice-overlay');
      if(ov) ov.classList.remove('hidden');
      speak("Mistero! Scegli: Apri il mistero, oppure prendi 500 in palio.");
      TimerManager.setTimeout(()=>{ const b=document.getElementById('btn-mystery-open'); if(b) b.focus(); }, 120);
    }
    function closeMysteryModal(){
      isMysteryModalOpen = false;
      const ov = document.getElementById('mystery-choice-overlay');
      if(ov) ov.classList.add('hidden');
    }
    function chooseMystery(openIt){
      const res = mysteryChoiceResolver;
      mysteryChoiceResolver = null;
      closeMysteryModal();
      if(typeof res === 'function') res(!!openIt);
    }
    function askMysteryChoice(){
      return new Promise(resolve=>{
        mysteryChoiceResolver = resolve;
        openMysteryModal();
      });
    }
    const NATO_ALPHABET = {
      'A':'Ancona', 'B':'Bologna', 'C':'Como', 'D':'Domodossola', 'E':'Empoli',
      'F':'Firenze', 'G':'Genova', 'H':'Hotel', 'I':'Imola', 'J':'Jersey',
      'K':'Kappa', 'L':'Livorno', 'M':'Milano', 'N':'Napoli', 'O':'Otranto',
      'P':'Padova', 'Q':'Quarto', 'R':'Roma', 'S':'Savona', 'T':'Torino',
      'U':'Udine', 'V':'Venezia', 'W':'Washington', 'X':'Xilofono', 'Y':'York', 'Z':'Zara'
    };

    async function readRevealedLetters(){
      if(!currentStanza || !currentPuzzleText) return;
      
      // Mostra le lettere trovate (ricostruite dal puzzle)
      const revealedIndices = currentStanza.lettere_rivelate || [];
      const allRevealedLetters = new Set();
      
      // Scansiona il puzzle e trova quali lettere corrispondono agli indici rivelati
      const sol = currentPuzzleTextWithoutHint.toUpperCase();
      let globalIdx = 0;
      
      for(let i = 0; i < sol.length; i++) {
        if(sol[i].match(/[A-Z√Ä-√ô]/)) {
          if(revealedIndices.includes(globalIdx)) {
            const cleanLetter = cleanStr(sol[i]);
            allRevealedLetters.add(cleanLetter);
          }
          globalIdx++;
        }
      }
      
      // Converti Set in array ordinato
      const list = [...allRevealedLetters].sort();
      
      // Separa consonanti e vocali
      const consonants = list.filter(c => !'AEIOU'.includes(c.toUpperCase()));
      const vowels = list.filter(c => 'AEIOU'.includes(c.toUpperCase()));
      
      if(list.length === 0) {
        speak("Nessuna lettera trovata ancora in questo round.");
        return;
      }
      
      clearSpeechQueue();
      
      // Annuncia consonanti trovate
      if(consonants.length > 0) {
        speak(`Consonanti trovate: ${consonants.length}`);
        for(let i=0; i<consonants.length; i++){
          await new Promise(r => TimerManager.setTimeout(r, 500));
          const letterUpper = consonants[i].toUpperCase();
          const letterLower = consonants[i].toLowerCase();
          const word = NATO_ALPHABET[letterUpper] || letterLower;
          speak(`${letterLower}, ${word}`);
        }
      }
      
      // Annuncia vocali trovate
      if(vowels.length > 0) {
        await new Promise(r => TimerManager.setTimeout(r, 800));
        speak(`Vocali trovate: ${vowels.length}`);
        for(let i=0; i<vowels.length; i++){
          await new Promise(r => TimerManager.setTimeout(r, 500));
          const letterUpper = vowels[i].toUpperCase();
          const letterLower = vowels[i].toLowerCase();
          const word = NATO_ALPHABET[letterUpper] || letterLower;
          speak(`${letterLower}, ${word}`);
        }
      }
    }
    
    function moveWordNav(d) {
      clearSpeechQueue();
      if(spellingTimer) TimerManager.clearTimeout(spellingTimer);
      if(!parsedBoard.length) return;
      let n = navWordIdx + d;
      if(n < 0) n = 0;
      else if(n >= parsedBoard.length) n = parsedBoard.length - 1;
      
      if(n !== navWordIdx) {
        navWordIdx = n;
        navCharIdx = -1; // ‚úÖ FIX 3: Reset sempre a -1 quando cambi parola
        highlightNav();
        let w = parsedBoard[n];
        if(!w) return; 
        let letterCount = (w && w.chars) ? w.chars.length : 0;
        let spelling = "";
        if(w && w.chars && Array.isArray(w.chars)) w.chars.forEach(c => {
          if(c && c.isLetter && !c.isRevealed) spelling += " * "; // ‚úÖ Asterisco staccato
          else spelling += " " + (c.char ? c.char.toLowerCase() : "");
        });
        // ‚úÖ Normalizza spazi multipli e trim
        spelling = spelling.replace(/\s+/g, ' ').trim();
        speak(`Parola ${n + 1}, ${letterCount} lettere. ${spelling}`);
      } else {
        // ‚úÖ FIX 3: Anche se non cambia parola, resetta il carattere
        navCharIdx = -1;
        highlightNav();
        let w = parsedBoard[n];
        if(!w) return;
        let letterCount = (w && w.chars) ? w.chars.length : 0;
        let spelling = "";
        if(w && w.chars && Array.isArray(w.chars)) w.chars.forEach(c => {
          if(c && c.isLetter && !c.isRevealed) spelling += " * "; // ‚úÖ Asterisco staccato
          else spelling += " " + (c.char ? c.char.toLowerCase() : "");
        });
        // ‚úÖ Normalizza spazi multipli e trim
        spelling = spelling.replace(/\s+/g, ' ').trim();
        speak(`Parola ${n + 1}, ${letterCount} lettere. ${spelling}`);
      }
    }

    function moveNav(d) {
      clearSpeechQueue();
      if(spellingTimer) TimerManager.clearTimeout(spellingTimer);
      if(!parsedBoard.length) return;
      
      // ‚úÖ SALVA la parola corrente PRIMA di fare qualsiasi calcolo
      const savedWordIdx = navWordIdx;
      let currentW = parsedBoard[navWordIdx];
      if(!currentW) return; 
      
      let newCharIdx = navCharIdx + d;
      
      // ‚úÖ FIX: Se navCharIdx √® -1 (nessuna lettera selezionata)
      if(navCharIdx === -1) {
        if(d > 0) {
          // Freccia destra da inizio parola: vai alla prima lettera (se esiste)
          if(currentW.chars.length > 0) {
            navCharIdx = 0;
            highlightNav();
            readSingleChar();
          } else {
            speak("Parola vuota");
          }
        } else {
          // Freccia sinistra da inizio parola: NON fare nulla
          speak("Inizio parola");
        }
        return;
      }
      
      // ‚úÖ FIX CRITICO: Blocca COMPLETAMENTE il movimento oltre i limiti
      // NON permettere MAI di cambiare parola con le frecce orizzontali!
      if(newCharIdx < 0) {
        // Tentativo di andare prima del primo carattere
        speak("Inizio parola"); 
        return; // ‚Üê RETURN IMMEDIATO, non cambiare NULLA
      }
      
      if(newCharIdx >= currentW.chars.length) {
        // Tentativo di andare oltre l'ultimo carattere
        speak("Fine parola"); 
        return; // ‚Üê RETURN IMMEDIATO, non cambiare NULLA
      }
      
      // ‚úÖ Movimento valido DENTRO la stessa parola
      navCharIdx = newCharIdx;
      
      // ‚úÖ VERIFICA POST-MODIFICA: assicurati che non sia cambiata la parola
      if(navWordIdx !== savedWordIdx) {
        navWordIdx = savedWordIdx; // Ripristina se qualcosa ha cambiato la parola
      }
      
      highlightNav();
      readSingleChar();
    }

    function highlightNav() {
      document.querySelectorAll('.cursor-char').forEach(e => e.classList.remove('cursor-char'));
      document.querySelectorAll('.cursor-word').forEach(e => e.classList.remove('cursor-word'));
      document.getElementById(`row-${navWordIdx}`)?.classList.add('cursor-word');
      if(navCharIdx >= 0) {
        document.getElementById(`tile-${navWordIdx}-${navCharIdx}`)?.classList.add('cursor-char');
      }
    }

    function readSingleChar() {
      if(!parsedBoard[navWordIdx]) return;
      const c = parsedBoard[navWordIdx].chars[navCharIdx];
      if(!c) return;
      
      
      const totalLetters = parsedBoard[navWordIdx].chars.length;
      const position = navCharIdx + 1; 
      
      const charText = c.isLetter && !c.isRevealed ? "Asterisco" : (NATO[c.char] || c.char);
      speak(`${charText}, ${position} di ${totalLetters}`);
    }

    function openWordInspector() {
      if(!parsedBoard.length) return speak("Nessuna parola.");
      const w = parsedBoard[navWordIdx];
      if(!w) return;
      const cont = document.getElementById('inspector-letters-container');
      cont.innerHTML = "";
      w.chars.forEach((c, idx) => {
        const btn = document.createElement('div');
        btn.className = 'inspector-char-btn';
        btn.setAttribute('role', 'button');
        btn.setAttribute('tabindex', '0');
        let visualChar = (c.isLetter && !c.isRevealed) ? "_" : c.char;
        let spelling = "";
        if(!c.isLetter) spelling = (NATO[c.char] || c.char);
        else if(!c.isRevealed) spelling = `Nascosta`;
        else spelling = `${c.char}, ${NATO[c.char] || ''}`;
        
        btn.innerHTML = `<span>Lettera ${idx + 1}</span> <strong>${visualChar}</strong>`;
        btn.onclick = () => speak(spelling);
        btn.onkeydown = (e) => {
          if(e.key === 'Enter' || e.key === ' ') speak(spelling);
        };
        cont.appendChild(btn);
      });
      document.getElementById('word-inspector-overlay').classList.remove('hidden');
      TimerManager.setTimeout(() => { const first = cont.querySelector('.inspector-char-btn'); if(first) first.focus(); }, 100);
      
      speak(`Dettaglio parola ${navWordIdx + 1}. Usa tab per scorrere le lettere.`);
    }

    function closeWordInspector() {
      document.getElementById('word-inspector-overlay').classList.add('hidden');
      document.getElementById('btn-inspect-word').focus();
    }

    async function reopenLastInput() {
      // ‚úÖ FIX: Non riaprire se l'input √® gi√† aperto
      if(inputMode) return;
      
      // ‚úÖ FIX: Non riaprire se stiamo ancora processando l'input precedente
      if(isProcessingInput) {
        speak("Attendere elaborazione...");
        return;
      }
      
      // ‚úÖ FIX: Non riaprire se non c'√® un lastInputMode salvato
      if(!lastInputMode) return;
      
      // ‚úÖ FIX: Non riaprire se l'azione √® appena stata completata (entro 2 secondi)
      if(actionJustCompleted) {
        speak("Azione gi√† completata");
        return;
      }
      
      // ‚úÖ FIX: Non riaprire se l'azione √® gi√† stata completata
      // Ricarica stato fresco dal database per verificare
      const { data: freshStanza, error } = await _supabase
        .from('stanze')
        .select('*, giocatori(*)')
        .eq('id', roomId)
        .single();
      
      if(error || !freshStanza) return;
      
      const isMe = (freshStanza.id_giocatore_corrente === myId);
      
      // Se non √® pi√π il tuo turno, non riaprire
      if(!isMe) {
        speak("Non √® pi√π il tuo turno");
        return;
      }
      
      // ‚úÖ Se era consonante: Controlla se montepremi_round √® 0 (hai gi√† girato o chiamato)
      // In questo caso non riaprire perch√© l'azione √® completata
      if(lastInputMode === 'letter' && freshStanza.montepremi_round === 0) {
        speak("Hai gi√† chiamato la consonante");
        return;
      }
      
      // ‚úÖ Se era vocale o soluzione: Controlla ultima_azione
      // Se l'ultima azione √® stata completata, non riaprire
      const lastAction = freshStanza.ultima_azione || '';
      if(lastInputMode === 'vowel' && lastAction === 'chiama_lettera') {
        // La vocale √® gi√† stata chiamata
        speak("Hai gi√† chiamato la vocale");
        return;
      }
      
      if(lastInputMode === 'solve' && (lastAction === 'risolto' || lastAction === 'errore_risolvi')) {
        // Hai gi√† risolto (o tentato di risolvere)
        speak("Hai gi√† tentato di risolvere");
        return;
      }
      
      // ‚úÖ OK: Riapri il campo
      const typeMsg = lastInputMode === 'vowel' ? "vocale" : lastInputMode === 'letter' ? "consonante" : "soluzione";
      openInput(lastInputMode);
      speak(`Campo ${typeMsg} riaperto.`);
    }

    async function reorganizePlayers(){
      if(!isHost || !roomId) return;
      
      
      // ‚úÖ UUID: Salva l'UUID del giocatore corrente (non l'indice!)
      const {data: currentStanza} = await _supabase
        .from('stanze')
        .select('id_giocatore_corrente')
        .eq('id', roomId)
        .single();
      
      const currentPlayerUUID = currentStanza?.id_giocatore_corrente; // Ora √® UUID!
      
      // Ottieni tutti i giocatori
      const {data: players, error} = await _supabase
        .from('giocatori')
        .select('*')
        .eq('stanza_id', roomId)
        .order('indice');
        
      if(error || !players || players.length === 0){
        return;
      }
      
      
      // ‚úÖ UUID: Trova il giocatore che aveva il turno (per UUID)
      const currentPlayer = players.find(p => p.id === currentPlayerUUID);
      
      // Riassegna indici consecutivi 0, 1, 2...
      for(let i = 0; i < players.length; i++){
        if(players[i] && players[i].indice !== i){
          await _supabase
            .from('giocatori')
            .update({indice: i})
            .eq('id', players[i].id);
        }
      }
      
      // ‚úÖ UUID: Ripristina il turno usando UUID (se il giocatore esiste ancora)
      let newTurnUUID = null;
      if(currentPlayer){
        // Il giocatore √® ancora attivo, mantieni il suo UUID
        newTurnUUID = currentPlayer.id;
      } else {
        // Il giocatore √® uscito, passa al primo disponibile
        newTurnUUID = players[0]?.id || null;
      }
      
      await _supabase
        .from('stanze')
        .update({
          id_giocatore_corrente: newTurnUUID, // ‚Üê UUID invece di indice!
          ultima_azione: 'riorganizza',
          ultimo_messaggio: 'Turni riorganizzati',
          azione_timestamp: DateUtils.now()
        })
        .eq('id', roomId);
        
      
      // Refresh
      await fetchFullState();
    }

    async function togglePause() {
      if(!isHost || !currentStanza) return;
      const newState = !currentStanza.in_pausa;
      
      // ‚úÖ FIX TIMER PAUSA: Non aggiornare azione_timestamp qui
      // Sar√† aggiornato da reorganizePlayers() quando si toglie la pausa
      await _supabase.from('stanze').update({
        in_pausa: newState, 
        ultimo_messaggio: newState ? "GIOCO IN PAUSA" : "GIOCO RIPRESO"
      }).eq('id', roomId);
      
      // Se togli la pausa, riorganizza i giocatori (che aggiorner√† azione_timestamp)
      if(!newState){
        await reorganizePlayers();
      } else {
        // Se METTI in pausa, aggiorna timestamp ora (per fermare il timer)
        await _supabase.from('stanze').update({
          azione_timestamp: DateUtils.now()
        }).eq('id', roomId);
        await fetchFullState();
      }
    }

    async function preResumeCheck() {
      if(!isHost) return;
      
      
      await checkAndRemoveDisconnectedPlayers();
      
      const { data: pl } = await _supabase.from('giocatori').select('*').eq('stanza_id', roomId).order('indice');
      const listDiv = document.getElementById('player-check-list');
      listDiv.innerHTML = "";
      pl.forEach(p => {
        const row = document.createElement('div');
        row.style = "display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid #555;padding:10px;";
        
        
        const lastPing = p.ultimo_ping ? new Date(p.ultimo_ping) : null;
        const now = new Date();
        const secondsSinceLastPing = lastPing ? Math.floor((now - lastPing) / 1000) : 9999;
        const statusColor = secondsSinceLastPing > 15 ? '#ff4444' : '#00ff00';
        const statusText = secondsSinceLastPing > 15 ? 'OFFLINE' : 'ONLINE';
        
        row.innerHTML = `<span style="font-size:1.2em;color:#fff;">${escapeHTML(p.nome)} <span style="color:${statusColor};font-size:0.85em;">${statusText}</span></span>`;
        const delBtn = document.createElement('button');
        delBtn.textContent = "ELIMINA";
        delBtn.className = "action-btn";
        delBtn.style = "padding:8px 15px;font-size:.9em;background:red;border:none;min-height:auto;";
        delBtn.onclick = async () => {
          if(confirm("Eliminare " + p.nome + "?")) {
            await _supabase.from('giocatori').delete().eq('id', p.id);
            row.remove();
            speak(`${p.nome} eliminato`);
          }
        };
        row.appendChild(delBtn);
        listDiv.appendChild(row);
      });
      document.getElementById('player-check-overlay').classList.remove('hidden');
      speak("Controllo presenze. I giocatori offline sono stati rimossi automaticamente. Verifica e conferma.");
      TimerManager.setTimeout(() => document.getElementById('btn-confirm-resume').focus(), 150);
    }
    
    async function checkAndRemoveDisconnectedPlayers() {
      if(!isHost || !roomId) return;
      
      const { data: players } = await _supabase.from('giocatori').select('*').eq('stanza_id', roomId);
      if(!players || players.length === 0) return;
      
      const now = new Date();
      const TIMEOUT_SECONDS = 45; // ‚úÖ FIX CHATGPT: Da 15s a 45s (ping ogni 10s)
      
      for(const player of players) {
        const lastPing = player.ultimo_ping ? new Date(player.ultimo_ping) : null;
        const secondsSinceLastPing = lastPing ? Math.floor((now - lastPing) / 1000) : 9999;
        
        
        if(secondsSinceLastPing > TIMEOUT_SECONDS) {
          await _supabase.from('giocatori').delete().eq('id', player.id);
          showFlashMessage(`${player.nome} disconnesso e rimosso`, 'bad');
          speak(`${player.nome} si √® disconnesso`);
        }
      }
    }

    async function confirmResumeGame() {
      document.getElementById('player-check-overlay').classList.add('hidden');
      await togglePause();
    }

    function closePlayerCheckOverlay(){
      document.getElementById('player-check-overlay').classList.add('hidden');
      speak("Rimaniamo in pausa.");
    }

    function announceTurn(){
      if(!currentStanza || !currentStanza.giocatori) return;
      // ‚úÖ UUID: Confronta per UUID
      const currentPlayer = currentStanza.giocatori.find(p=>p.id===currentStanza.id_giocatore_corrente);
      const isMe = (currentStanza.id_giocatore_corrente === myId);
      const turnMsg = isMe ? "√à il tuo turno!" : `Turno di ${currentPlayer?.nome || 'sconosciuto'}`;
      
      
      let totalWords = parsedBoard.length;
      let totalLetters = 0;
      let revealedLetters = 0;
      
      parsedBoard.forEach(w => {
        if(w && w.chars && Array.isArray(w.chars)) w.chars.forEach(c => {
          if(c.isLetter){
            totalLetters++;
            if(c.isRevealed) revealedLetters++;
          }
        });
      });
      
      const boardMsg = `Tabellone: ${totalWords} parole, ${totalLetters} lettere totali, ${revealedLetters} scoperte.`;
      
      // ‚úÖ Leggi categoria e tema dai due span dentro l'H2
      const categoryMain = document.getElementById('category-main')?.textContent || '';
      const hintText = document.getElementById('round-hint')?.textContent || '';
      
      let categoryMsg = '';
      if(categoryMain && categoryMain !== '...') {
        categoryMsg = ` Categoria: ${categoryMain}.`;
        
        // Se c'√® un tema/argomento, leggilo separatamente
        if(hintText) {
          categoryMsg += ` ${hintText}.`;
        }
      }
      
      speak(`${turnMsg} ${boardMsg}${categoryMsg}`);
    }

    function announceScore(){
      if(!currentStanza) return;
      
      // Ordina giocatori per punteggio totale (come nella classifica)
      const sorted = [...currentStanza.giocatori].sort((a,b) => (b.punteggio_totale||0) - (a.punteggio_totale||0));
      
      if(sorted.length === 0) {
        speak("Nessun giocatore trovato");
        return;
      }
      
      // Costruisci l'annuncio per tutti i giocatori
      let announcement = "Punteggi. ";
      
      sorted.forEach((player, index) => {
        const roundScore = player.punteggio_round || 0;
        const totalScore = player.punteggio_totale || 0;
        
        announcement += `${player.nome}: Parziale ${roundScore} euro. Totale ${totalScore} euro. `;
      });
      
      speak(announcement);
    }

    async function openPlayersPanel(){
      const panel = document.getElementById('players-panel');
      panel.classList.remove('hidden');
      
      const list = document.getElementById('players-list');
      list.innerHTML = '<p style="color:#888; text-align:center; padding:20px;">Caricamento...</p>';
      
      
      if(roomId){
        const {data: freshStanza} = await _supabase.from('stanze').select('*, giocatori(*)').eq('id', roomId).maybeSingle();
        if(freshStanza && freshStanza.giocatori && freshStanza.giocatori.length > 0){
          list.innerHTML = '<h3 style="color:var(--col-accent); margin-bottom:15px;">CLASSIFICA</h3>';
          
          
          const sorted = [...freshStanza.giocatori].sort((a,b) => (b.punteggio_totale||0) - (a.punteggio_totale||0));
          sorted.forEach((p, i) => {
            const div = document.createElement('div');
            div.style = 'background:#111; border:1px solid #333; padding:15px; margin-bottom:20px; border-radius:8px; display:flex; flex-direction:column; gap:10px;';
            
            const info = document.createElement('span');
            info.style = 'color:#ddd; font-size:1.1em; display:block;'; // display:block per separare ogni giocatore
            info.innerHTML = `<strong style="color:var(--col-accent);">${i+1}.</strong> ${escapeHTML(p.nome)} - <strong>${p.punteggio_totale||0} ‚Ç¨</strong> (Giro: ${p.punteggio_round||0} ‚Ç¨)`;
            div.appendChild(info);
            
            
            if(isHost && p.id !== myId){
              const btnContainer = document.createElement('div');
              btnContainer.style = 'display:flex; gap:8px; flex-wrap:wrap;';
              
              
              const btnHost = document.createElement('button');
              btnHost.textContent = 'PASSA HOST';
              btnHost.className = 'action-btn';
              btnHost.style = 'padding:10px 15px; font-size:0.9em; background:#1a5490; border-color:#4a90e2; min-height:auto;';
              btnHost.onclick = () => transferHost(p.id, p.nome);
              btnContainer.appendChild(btnHost);
              
              
              const btnDel = document.createElement('button');
              btnDel.textContent = 'ELIMINA';
              btnDel.className = 'action-btn';
              btnDel.style = 'padding:10px 15px; font-size:0.9em; background:#8b0000; border-color:#ff0000; min-height:auto;';
              btnDel.onclick = () => removePlayer(p.id, p.nome);
              btnContainer.appendChild(btnDel);
              
              div.appendChild(btnContainer);
            }
            
            list.appendChild(div);
          });
          
          speak("Pannello giocatori aperto");
          
          
          if(isHost){
            const hostControls = document.createElement('div');
            hostControls.style = 'margin-top:25px; padding-top:20px; border-top:2px solid #444;';
            hostControls.innerHTML = '<h3 style="color:#888; margin-bottom:15px; text-transform:uppercase;">CONTROLLI HOST</h3>';
            
            const controlsGrid = document.createElement('div');
            controlsGrid.style = 'display:grid; grid-template-columns:1fr 1fr; gap:10px;';
            
            
            const btnShare = document.createElement('button');
            btnShare.textContent = 'CONDIVIDI LINK';
            btnShare.className = 'action-btn';
            btnShare.style = 'padding:12px; font-size:1em; background:#1a5490; border-color:#4a90e2; min-height:auto;';
            btnShare.onclick = shareRoom;
            controlsGrid.appendChild(btnShare);
            
            
            const btnBot = document.createElement('button');
            btnBot.textContent = 'AGGIUNGI BOT (B)';
            btnBot.className = 'action-btn';
            btnBot.style = 'padding:12px; font-size:1em; background:#1a1a5a; border-color:cyan; color:cyan; min-height:auto;';
            btnBot.onclick = () => { addBot(); closePlayers(); };
            controlsGrid.appendChild(btnBot);
            
            
            const btnPause = document.createElement('button');
            btnPause.textContent = 'PAUSA';
            btnPause.className = 'action-btn';
            btnPause.style = 'padding:12px; font-size:1em; background:#5a3a1a; border-color:orange; min-height:auto;';
            btnPause.onclick = () => { togglePause(); closePlayers(); };
            controlsGrid.appendChild(btnPause);
            
            
            const btnReset = document.createElement('button');
            btnReset.textContent = 'RESET PARTITA';
            btnReset.className = 'action-btn';
            btnReset.style = 'padding:12px; font-size:1em; background:#1a1a5a; border-color:blue; min-height:auto;';
            btnReset.onclick = () => { resetGame(); closePlayers(); };
            controlsGrid.appendChild(btnReset);
            
            
            const btnClose = document.createElement('button');
            btnClose.textContent = 'CHIUDI STANZA';
            btnClose.className = 'action-btn';
            btnClose.style = 'padding:12px; font-size:1em; background:#5a1a1a; border-color:red; min-height:auto;';
            btnClose.onclick = closeRoom;
            controlsGrid.appendChild(btnClose);
            
            hostControls.appendChild(controlsGrid);
            list.appendChild(hostControls);
          }
          
          
          TimerManager.setTimeout(() => {
            const firstBtn = list.querySelector('button') || panel.querySelector('button');
            if(firstBtn) firstBtn.focus();
          }, 100);
          
        } else {
          list.innerHTML = '<p style="color:#888; text-align:center; padding:20px;">Nessun giocatore presente.</p>';
          speak("Nessun giocatore");
        }
      } else {
        list.innerHTML = '<p style="color:#888; text-align:center; padding:20px;">Nessuna partita attiva.</p>';
        speak("Nessuna partita attiva");
      }
    }

    function closePlayers(){
      document.getElementById('players-panel').classList.add('hidden');
    }

    async function removePlayer(playerId, playerName){
      if(!isHost) return;
      if(!confirm(`Eliminare ${playerName}?`)) return;
      
      try {
        
        // Elimina il giocatore
        const {error: deleteError} = await _supabase
          .from('giocatori')
          .delete()
          .eq('stanza_id', roomId)
          .eq('id', playerId);
          
        if(deleteError){
          alert('Errore nell\'eliminazione: ' + deleteError.message);
          return;
        }
        
        showFlashMessage(`${playerName} eliminato dal database...`, 'info');
        
        // Riorganizza tutti i giocatori rimasti
        await reorganizePlayers();
        
        speak(`${playerName} eliminato. Turni riorganizzati. Tutti i giocatori sono stati risincronizzati.`);
        showFlashMessage(`${playerName} eliminato e turni riorganizzati`, 'success');
        
        // Riapri il pannello giocatori aggiornato
        TimerManager.setTimeout(() => openPlayersPanel(), 500);
        
      } catch(e){
        alert('Errore: ' + e.message);
      }
    }

    async function transferHost(newHostId, newHostName){
      if(!isHost) return;
      if(!confirm(`Passare il controllo della stanza a ${newHostName}?`)) return;
      
      try {
        // Rimuovi host al vecchio
        const {error: removeError} = await _supabase.from('giocatori').update({is_host: false}).eq('id', myId);
        if(removeError){
          alert('Errore: ' + removeError.message);
          return;
        }
        
        // Assegna host al nuovo
        const {error: assignError} = await _supabase.from('giocatori').update({is_host: true}).eq('id', newHostId);
        if(assignError){
          alert('Errore: ' + assignError.message);
          return;
        }
        
        // Aggiorna stato locale
        isHost = false;
        
        // Aggiorna database stanza
        await _supabase.from('stanze').update({
          ultima_azione: 'passa_host',
          ultimo_messaggio: `${newHostName} √® ora l'host`,
          azione_timestamp: DateUtils.now()
        }).eq('id', roomId);
        
        speak(`${newHostName} √® ora l'host della stanza.`);
        
        // Aggiorna stato
        await fetchFullState();
        
        // Riapri pannello aggiornato
        TimerManager.setTimeout(() => openPlayersPanel(), 300);
        
      } catch(e){
        alert('Errore: ' + e.message);
      }
    }

    async function shareRoom(){
      if(!currentStanza) return;
      
      const roomCode = currentStanza.codice;
      const shareUrl = `${window.location.origin}${window.location.pathname}#stanza=${roomCode}`;
      
      
      if(navigator.share){
        
        try {
          await navigator.share({
            title: 'La Ruota - Unisciti alla partita!',
            text: `Entra nella stanza "${roomCode}"`,
            url: shareUrl
          });
          speak("Link condiviso");
        } catch(e){
          
          if(e.name !== 'AbortError') {
            speak("Condivisione annullata");
          }
        }
      } else {
        
        try {
          await navigator.clipboard.writeText(shareUrl);
          speak("Link copiato negli appunti!");
          alert(`Link della stanza copiato!\n\n${shareUrl}\n\nCondividilo con altri giocatori.`);
        } catch(e){
          
          speak("Copia questo link");
          prompt("Copia questo link per condividere la stanza:", shareUrl);
        }
      }
    }

    function readAllScores(){
      if(!currentStanza) return;
      let txt="Classifica: ";
      currentStanza.giocatori.forEach(p=> txt += `${p.nome} ${p.punteggio_totale}, `);
      speak(txt);
    }

    function parseAndRenderBoard(text, rev, resetNavigation = false) {
      rev = Array.isArray(rev) ? rev : [];
      
      // ‚úÖ FIX CRITICO: SALVA la posizione corrente prima di ricostruire il tabellone
      // SOLO se non vogliamo resettare (es: quando √® la stessa frase ma si aggiorna)
      const savedWordIdx = resetNavigation ? 0 : navWordIdx;
      const savedCharIdx = resetNavigation ? -1 : navCharIdx;
      
      const c = document.getElementById('board-container');
      c.innerHTML = '';
      parsedBoard = [];
      let gI = 0;
      let totalLetters = 0;
      let revealedLetters = 0;
      if(!text) return; 

      text.toUpperCase().split(' ').forEach(wS => {
        let wO = { str: wS, chars: [] };
        const r = document.createElement('div');
        r.className = 'board-row';
        r.id = `row-${parsedBoard.length}`;
        r.setAttribute('role', 'row');
        r.setAttribute('aria-label', `Parola ${parsedBoard.length + 1}`);
        
        for(let j = 0; j < wS.length; j++) {
          const ch = wS[j];
          const isL = ch.match(/[A-Z√Ä-√ô]/);
          const isR = !isL || rev.includes(gI);
          wO.chars.push({ char: ch, isRevealed: isR, isLetter: !!isL });
          const d = document.createElement('div');
          d.className = 'tile' + (isL && !isR ? ' empty' : '') + (isL ? '' : ' punct');
          if(isL && isR) d.classList.add('revealed');
          if(isL && !isR) d.textContent = '';
          else d.textContent = ch;
          
          if(isL && !isR) d.setAttribute('aria-label', 'Lettera nascosta');
          else if(isL && isR) {
            const natoWord = NATO[ch] || ch;
            d.setAttribute('aria-label', `${ch}, ${natoWord}`);
          } else d.setAttribute('aria-label', NATO[ch] || ch);
          
          d.id = `tile-${parsedBoard.length}-${j}`;
          d.setAttribute('tabindex', '-1');
          r.appendChild(d);
          if(isL) { gI++; totalLetters++; if(isR) revealedLetters++; }
        }
        c.appendChild(r);
        parsedBoard.push(wO);
      });
      
      // ‚úÖ FIX CRITICO: RIPRISTINA la posizione salvata, con clamp ai limiti
      // Se la parola salvata esiste ancora, torna l√¨
      if(savedWordIdx >= 0 && savedWordIdx < parsedBoard.length) {
        navWordIdx = savedWordIdx;
        const currentWord = parsedBoard[navWordIdx];
        // Clamp navCharIdx ai limiti della parola corrente
        if(savedCharIdx >= currentWord.chars.length) {
          navCharIdx = currentWord.chars.length - 1; // Vai all'ultimo carattere
        } else if(savedCharIdx < -1) {
          navCharIdx = -1; // Nessun carattere selezionato
        } else {
          navCharIdx = savedCharIdx; // Ripristina posizione esatta
        }
      } else {
        // La parola salvata non esiste pi√π (frase cambiata), resetta
        navWordIdx = 0;
        navCharIdx = -1;
      }
      
      const numWords = parsedBoard.length;
      const summary = `Tabellone: ${numWords} parole, ${totalLetters} lettere totali, ${revealedLetters} scoperte.`;
      c.setAttribute('aria-label', summary);
      highlightNav();
      if(isAccessibleMode) updateAccessibleBoard();
    }

    window.addEventListener('keydown', (e)=>{
      if(!e.key) return;
      
      // üîí BLOCCO TASTI DI SISTEMA USATI DAL GIOCO
      // Previene conflitti con scorciatoie browser (es. Ctrl+T apre nuova scheda)
      // Blocca SOLO i tasti gi√† assegnati alle funzioni del gioco
      const k = ((e && e.key) || "").toLowerCase();
      
      // Lista tasti Ctrl usati dal gioco (da bloccare per evitare conflitti)
      const gameTasteCtrl = ['i', 'h', 'g', 'r', 't', 'k', 's', 'l', 'd', 'b'];
      
      if(e.ctrlKey && gameTasteCtrl.includes(k)) {
        e.preventDefault();
        e.stopPropagation();
      }
      
      // Nota: Ctrl+V e Ctrl+A vengono gestiti dopo (servono per input)
      // Nota: Ctrl+P NON bloccato (passa turno manuale rimosso, puoi stampare)
      
      // ‚úÖ GESTIONE NAVIGAZIONE PANNELLO CRONOLOGIA (prima di tutto)
      const historyPanel=document.getElementById('action-history-panel');
      const historyOpen = historyPanel && !historyPanel.classList.contains('hidden');
      if(historyOpen) {
        const list=document.getElementById('action-history-list');
        const items=[...list.querySelectorAll('.history-item')];
        if(items.length) {
          const key = ((e && e.key) || "").toLowerCase();
          if(['arrowdown','arrowup','home','end'].includes(key)) {
            e.preventDefault();
            const active=document.activeElement;
            let idx=items.indexOf(active);
            if(idx<0) idx=0;
            if(key==='arrowdown') idx=Math.min(items.length-1, idx+1);
            if(key==='arrowup') idx=Math.max(0, idx-1);
            if(key==='home') idx=0;
            if(key==='end') idx=items.length-1;
            items[idx].focus();
            return;
          }
        }
      }

      // ‚úÖ GESTIONE TASTI RAPIDI DI GIOCO
      if((e.ctrlKey && e.shiftKey && e.key && e.key.toLowerCase() === 'r') || (e.key && e.key.toLowerCase() === 'f5')) return;
      
      // k √® gi√† dichiarato sopra alla riga 2700
      
      // ‚úÖ FIX: I tasti rapidi di gioco funzionano SOLO quando sei nella stanza
      // Non interferire con i campi di input nella schermata di setup
      const isInSetup = !document.getElementById('game-panel').classList.contains('hidden') === false;
      const setupPanel = document.getElementById('setup-panel');
      const isInSetupScreen = setupPanel && !setupPanel.classList.contains('hidden');
      
      // ESC deve funzionare SEMPRE, anche in input mode
      if(k === 'escape'){
         e.preventDefault();
         
         // ‚úÖ FIX: Prima controlla se c'√® un pannello informativo aperto
         const infoPanels = ['action-history-panel', 'help-panel', 'players-panel', 'chat-overlay', 'player-check-overlay', 'word-inspector-overlay', 'mystery-choice-overlay'];
         let panelClosed = false;
         
         for(const panelId of infoPanels) {
           const panel = document.getElementById(panelId);
           if(panel && !panel.classList.contains('hidden')) {
             panel.classList.add('hidden');
             panelClosed = true;
           }
         }
         
         // Se abbiamo chiuso un pannello, termina qui
         if(panelClosed) {
           speak("Pannello chiuso.");
           return;
         }
         
         // ‚úÖ Altrimenti controlla se √® il caso di chiudere l'input
         const s = currentStanza;
         const isMe = (s?.id_giocatore_corrente === myId);
         
         // Se sei in modalit√† consonante (letter) E √® ancora il tuo turno, NON chiudere!
         if(inputMode === 'letter' && isMe){
           speak("Non puoi annullare la consonante! Devi inserirla.");
           return;
         }
         
         // Altrimenti chiudi l'input
         const inputArea = document.getElementById('input-area');
         if(inputArea && !inputArea.classList.contains('hidden')) {
           inputArea.classList.add('hidden');
           closeInput();
           speak("Input chiuso.");
         }
         
         return;
      }
      
      // Blocca altri tasti se sei in input mode, MA permetti Ctrl+Tasto
      if(inputMode && !e.ctrlKey) return;

      const isInInput = document.activeElement && document.activeElement.tagName==='INPUT';
      
      // ‚úÖ FIX: Se sei in un campo di input del gioco (consonante/vocale/soluzione/chat),
      // blocca SOLO Ctrl+V (deve incollare) e Ctrl+A (deve selezionare tutto)
      // MA lascia passare tutti gli altri Ctrl (G, L, T, ecc.) che attivano le funzioni del gioco
      const gameInput = document.getElementById('game-input');
      const chatInput = document.getElementById('chat-input');
      if(isInInput && (document.activeElement === gameInput || document.activeElement === chatInput)) {
        if(e.ctrlKey && k === 'v') {
          // Lascia passare Ctrl+V al browser per incollare
          return;
        }
        if(e.ctrlKey && k === 'a') {
          // Lascia passare Ctrl+A al browser per selezionare tutto
          return;
        }
        // Tutti gli altri Ctrl continuano nel codice sotto per attivare funzioni del gioco
      }
      
      // ‚úÖ FIX: Se sei nella schermata di setup (prima di entrare in stanza),
      // NON intercettare i tasti - lascia funzionare tutto normalmente (Ctrl+A, ecc)
      if(isInSetupScreen && e.key && !e.key.toLowerCase().startsWith('f')) {
        // Permetti solo F5 e simili, tutto il resto passa al browser
        return;
      }
      
      if(isMysteryModalOpen){
        const btn1 = document.getElementById('btn-mystery-open');
        const btn2 = document.getElementById('btn-mystery-500');
        if(['arrowleft','arrowright','arrowup','arrowdown'].includes(k)){
          e.preventDefault();
          if(document.activeElement === btn1 && btn2) btn2.focus();
          else if(btn1) btn1.focus();
          return;
        }
        if(k==='enter'){ e.preventDefault(); if(document.activeElement) document.activeElement.click(); return; }
        if(e.ctrlKey || /^[a-z]$/.test(k)) { e.preventDefault(); return; }
      }

      // ‚úÖ FIX: Se sei in un campo input, permetti le frecce per navigare nel testo
      // NON intercettare le frecce quando l'utente sta editando testo
      if(isInInput && ['arrowleft','arrowright','arrowup','arrowdown','home','end'].includes(k)){
        // Lascia che il browser gestisca normalmente la navigazione nel campo input
        return; // Non fare e.preventDefault(), lascia funzionare normalmente
      }
      
      // ‚úÖ FIX: Se il pannello aiuto √® aperto, permetti frecce per scorrere
      const helpPanel = document.getElementById('help-panel');
      if(helpPanel && !helpPanel.classList.contains('hidden')) {
        if(['arrowup','arrowdown','pageup','pagedown','home','end'].includes(k)){
          // Lascia che il browser scrolli il pannello normalmente
          return;
        }
      }

      if(k==='arrowup'){ e.preventDefault(); moveWordNav(-1); return; }
      if(k==='arrowdown'){ e.preventDefault(); moveWordNav(1); return; }
      if(k==='arrowleft'){ e.preventDefault(); moveNav(-1); return; }
      if(k==='arrowright'){ e.preventDefault(); moveNav(1); return; }
      if(k===' ' && !isInInput){ e.preventDefault(); reopenLastInput(); return; }
      if((k==='i' && !isInInput) || (e.ctrlKey && k==='i')){ e.preventDefault(); openWordInspector(); return; }
      
      if(k==='1'){ playSharedAudio('snd-clap', 'Applauso'); return; }
      if(k==='2'){ playSharedAudio('snd-laugh', 'Risata'); return; }
      if(k==='3'){ playSharedAudio('snd-boo', 'Fischi'); return; }
      if(k==='4'){ playSharedAudio('snd-ooh', 'Ooh'); return; }
      
      
      if((k==='h' && !isInInput) || (e.ctrlKey && k==='h')){ e.preventDefault(); const p=document.getElementById('help-panel'); if(p.classList.contains('hidden')) openHelp(); else closeHelp(); return; }
      if((k==='g' && !isInInput) || (e.ctrlKey && k==='g')){ e.preventDefault(); doSpin(); return; }
      // ‚úÖ Ctrl+V apre vocale SOLO se NON sei in un campo input (altrimenti Ctrl+V = incolla)
      if((k==='v' && !isInInput) || (e.ctrlKey && k==='v' && !isInInput)){ e.preventDefault(); tryOpenVowelInput(); return; }
      if((k==='r' && !isInInput) || (e.ctrlKey && k==='r')){ e.preventDefault(); openInput('solve'); return; }
      if((k==='t' && !isInInput) || (e.ctrlKey && k==='t')){ e.preventDefault(); announceTurn(); return; }
      if((k==='k' && !isInInput) || (e.ctrlKey && k==='k')){ e.preventDefault(); openChat(); return; }
      if((k==='s' && !isInInput) || (e.ctrlKey && k==='s')){ 
        e.preventDefault(); 
        openPlayersPanel(); 
        return;
      }
      if((k==='l' && !isInInput) || (e.ctrlKey && k==='l')){ e.preventDefault(); readRevealedLetters(); return; }
      if(k==='a' && !isInInput){ 
        e.preventDefault(); 
        openActionHistory(true); 
        return; 
      }
      if(e.ctrlKey && k==='a' && !isInInput){ 
        e.preventDefault(); 
        openActionHistory(true); 
        return; 
      }
      if((k==='d' && !isInInput) || (e.ctrlKey && k==='d')){ 
        e.preventDefault(); 
        announceScore(); 
        return;
      }
      if((k==='b' && !isInInput) || (e.ctrlKey && k==='b')){ e.preventDefault(); addBot(); return; } 
    });

    function toggleAccessibleMode(){
      isAccessibleMode=!isAccessibleMode;
      document.body.classList.toggle('accessible-mode', isAccessibleMode);
      const btn=document.getElementById('btn-acc-mode');
      btn.setAttribute('aria-pressed', isAccessibleMode);
      btn.style.background=isAccessibleMode ? "#fff" : "transparent";
      btn.style.color=isAccessibleMode ? "#000" : "#fff";
      if(isAccessibleMode){
        updateAccessibleBoard();
        document.getElementById('board-container').setAttribute('aria-hidden','true');
        speak("Modalit√† Screen Reader senza tastiera attivata.");
        // Porta focus su GIRA
        TimerManager.setTimeout(()=> document.getElementById('btn-acc-spin')?.focus(), 200);
      } else {
        document.getElementById('board-container').setAttribute('aria-hidden','false');
        speak("Vista Grafica attivata.");
      }
    }
    function updateAccessibleBoard(){
      if(!currentFrase || !parsedBoard.length) return;
      const container=document.getElementById('acc-word-list');
      container.innerHTML="";
      let totalRevealed=0,totalLetters=0;
      parsedBoard.forEach(w=>w.chars.forEach(c=>{ if(c.isLetter){ totalLetters++; if(c.isRevealed) totalRevealed++; } }));
      
      // Riepilogo - pi√π prominente e chiaro
      document.getElementById('acc-board-summary').textContent = `${parsedBoard.length} parole - Lettere: ${totalRevealed}/${totalLetters}`;

      // Crea ogni parola come elemento div semplice per flick facile
      parsedBoard.forEach((w, idx)=>{
        // Wrapper con role="listitem" per semantica corretta
        const wordDiv = document.createElement('div');
        wordDiv.setAttribute('role', 'listitem');
        wordDiv.className = "acc-word-item";
        wordDiv.style.cssText = `
          padding: 15px 20px;
          margin: 8px 0;
          background: #222;
          border: 2px solid #555;
          border-radius: 10px;
          font-size: 1.5em;
          font-family: monospace;
          letter-spacing: 2px;
          color: #fff;
        `;
        
        // ‚úÖ NUOVO: Costruisci parole ATTACCATE (no spazi tra lettere)
        let visualText = "", srText = `${idx+1}. `;
        w.chars.forEach(c=>{
          if(c.isLetter){
            if(c.isRevealed){ 
              visualText += c.char; // ‚úÖ NO spazio!
              srText += c.char; // ‚úÖ NO spazio!
            } else { 
              visualText += "*"; // ‚úÖ Asterisco attaccato
              srText += "asterisco"; // ‚úÖ Screen reader dice "asterisco"
            }
          } else { 
            // Punteggiatura o apostrofo ‚Üí attaccato
            visualText += c.char;
            srText += (NATO[c.char] || c.char);
          }
        });
        
        // Contenuto: numero parola + lettere ATTACCATE
        wordDiv.innerHTML = `<span style="color:var(--col-accent);font-weight:bold;margin-right:15px;">${idx+1}.</span><span>${visualText}</span>`;
        
        // Attributo aria-label per screen reader
        wordDiv.setAttribute('aria-label', srText);
        
        // Opzionale: rendi cliccabile per azioni rapide (ma non necessario per flick)
        wordDiv.style.cursor = 'pointer';
        wordDiv.onclick = () => {
          navWordIdx = idx;
          textNavWordIdx = idx;
          speak(srText);
          openWordQuickMenu(idx);
        };
        
        container.appendChild(wordDiv);
      });
    }
    
    // Menu rapido per azioni sulla parola nel tabellone
    function openWordQuickMenu(wordIdx){
      const overlay = document.getElementById('word-quick-menu-overlay');
      if(!overlay) {
        // Crea overlay se non esiste
        const newOverlay = document.createElement('div');
        newOverlay.id = 'word-quick-menu-overlay';
        newOverlay.className = 'hidden';
        newOverlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;width:100vw;height:100vh;background:rgba(0,0,0,0.96);z-index:9999;display:flex;flex-direction:column;justify-content:center;align-items:center;backdrop-filter:blur(5px);';
        newOverlay.innerHTML = `
          <div class="modal-content" style="max-width:400px;">
            <h2 style="color:var(--col-neon);margin-bottom:20px;">PAROLA <span id="quick-menu-word-num"></span></h2>
            <div style="display:flex;flex-direction:column;gap:10px;">
              <button id="btn-quick-inspect" class="action-btn" style="background:#1a4d2e;border-color:#2ecc71;font-size:1.2em;padding:18px;">ISPEZIONA PAROLA</button>
              <button id="btn-quick-spin" class="action-btn btn-spin" style="font-size:1.2em;padding:18px;">GIRA LA RUOTA</button>
              <button id="btn-quick-letters" class="action-btn" style="background:#2c3e50;border-color:#3498db;font-size:1.1em;padding:18px;">LETTERE SCOPERTE</button>
              <button id="btn-quick-close" class="action-btn btn-pass" style="font-size:1.1em;">CHIUDI</button>
            </div>
          </div>
        `;
        document.body.appendChild(newOverlay);
      }
      
      // Mostra overlay e aggiorna numero parola
      const menuOverlay = document.getElementById('word-quick-menu-overlay');
      const wordNumSpan = document.getElementById('quick-menu-word-num');
      if(wordNumSpan) wordNumSpan.textContent = (wordIdx + 1);
      
      menuOverlay.classList.remove('hidden');
      
      // Riconfigura event listeners con il wordIdx corretto (closure)
      document.getElementById('btn-quick-inspect').onclick = () => {
        closeWordQuickMenu();
        openWordInspectorForWord(wordIdx);
      };
      document.getElementById('btn-quick-spin').onclick = () => {
        closeWordQuickMenu();
        doSpin();
      };
      document.getElementById('btn-quick-letters').onclick = () => {
        closeWordQuickMenu();
        readRevealedLetters();
      };
      document.getElementById('btn-quick-close').onclick = () => {
        closeWordQuickMenu();
      };
      
      // Focus sul primo pulsante
      TimerManager.setTimeout(() => document.getElementById('btn-quick-inspect')?.focus(), 100);
    }
    
    function closeWordQuickMenu(){
      const overlay = document.getElementById('word-quick-menu-overlay');
      if(overlay) overlay.classList.add('hidden');
      
      // Ritorna focus su GIRA in vista accessibile
      if(isAccessibleMode){
        TimerManager.setTimeout(() => document.getElementById('btn-acc-spin')?.focus(), 100);
      }
    }
    
    // Variabile per tracciare l'indice della parola corrente nella navigazione
    let textNavWordIdx = 0;
    
    // Toggle pannello "Altri Comandi"
    function toggleAccMoreCommands(){
      const panel = document.getElementById('acc-more-commands');
      const btn = document.getElementById('btn-acc-more');
      if(panel.style.display === 'none' || !panel.style.display){
        panel.style.display = 'grid';
        btn.textContent = 'ALTRI COMANDI ‚ñ≤';
        btn.style.background = '#444';
      } else {
        panel.style.display = 'none';
        btn.textContent = 'ALTRI COMANDI ‚ñº';
        btn.style.background = '#333';
        // Ritorna focus su GIRA
        TimerManager.setTimeout(()=> document.getElementById('btn-acc-spin')?.focus(), 100);
      }
    }
    
    // Navigazione tabellone in modalit√† screen reader senza tastiera
    function navigateTextBoard(direction){
      if(!parsedBoard.length) return;
      
      if(direction === 'first'){
        textNavWordIdx = 0;
      } else if(direction === 'next'){
        textNavWordIdx = Math.min(textNavWordIdx + 1, parsedBoard.length - 1);
      } else if(direction === 'prev'){
        textNavWordIdx = Math.max(textNavWordIdx - 1, 0);
      }
      
      announceCurrentWord();
    }
    
    // Annuncia la parola corrente
    function announceCurrentWord(){
      if(!parsedBoard[textNavWordIdx]) return;
      
      const word = parsedBoard[textNavWordIdx];
      let srText = `Parola ${textNavWordIdx + 1}: `;
      
      // ‚úÖ NUOVO: Parole ATTACCATE (no spazi tra lettere)
      word.chars.forEach(c=>{
        if(c.isLetter){
          if(c.isRevealed){ 
            srText += c.char; // ‚úÖ NO spazio!
          } else { 
            srText += "asterisco"; // ‚úÖ Dice "asterisco" invece di "nascosta"
          }
        } else { 
          srText += (NATO[c.char] || c.char); // Punteggiatura attaccata
        }
      });
      
      speak(srText);
    }
    
    // Apri inspector per parola specifica
    function openWordInspectorForWord(wordIdx){
      if(!parsedBoard[wordIdx]) return;
      navWordIdx = wordIdx;
      openWordInspector();
    }


    function askPrivacy(){
      const nm=document.getElementById('inp-name').value.trim();
      if(!nm) return speak("Inserisci nome.");
      document.getElementById('privacy-dialog').classList.remove('hidden');
      TimerManager.setTimeout(()=>{ const b=document.getElementById('privacy-dialog').querySelector('button'); if(b) b.focus(); },100);
    }
    async function createRoomFinal(isPublic){
      document.getElementById('privacy-dialog').classList.add('hidden');
      let cd=document.getElementById('inp-code').value.trim().toUpperCase();
      if(!cd) {
        speak("Devi inserire un codice stanza");
        document.getElementById('setup-panel').classList.remove('hidden');
        document.getElementById('inp-code').focus();
        return;
      }
      joinGame(true, cd, isPublic);
    }
    async function fetchPublicRooms(){
      const l=document.getElementById('rooms-list'); l.innerHTML="Cerco...";
      const {data:s}=await _supabase.from('stanze').select('codice,stato').eq('is_public',true).neq('stato','terminata').limit(10);
      if(!s||!s.length){ l.innerHTML="Nessuna stanza."; return; }
      l.innerHTML="";
      s.forEach(r=>{
        const b=document.createElement('button'); b.className='action-btn'; b.style="width:100%;margin:5px 0;padding:10px;font-size:0.8em;";
        b.textContent=`${r.codice} (${r.stato})`;
        b.onclick=()=>{ document.getElementById('inp-code').value=r.codice; joinGame(false); };
        l.appendChild(b);
      });
    }

    async function joinGame(cr, forcedCode=null, isPublic=false){
      const nm=document.getElementById('inp-name').value.trim().toUpperCase();
      const cd=forcedCode || document.getElementById('inp-code').value.trim().toUpperCase();
      if(!nm) return speak("Nome mancante");

      try{
        let st;
        if(cr){
          // ‚úÖ FIX: Controlla se il codice esiste gi√† prima di creare
          const {data: existing} = await _supabase.from('stanze').select('codice').eq('codice', cd).maybeSingle();
          
          if(existing){
            speak(`Errore: esiste gi√† una stanza con codice ${cd}. Scegline un altro!`);
            alert(`ERRORE: Esiste gi√† una stanza con il codice "${cd}".\n\nScegli un codice diverso o entra nella stanza esistente usando il pulsante ENTRA.`);
            document.getElementById('privacy-dialog').classList.add('hidden');
            document.getElementById('setup-panel').classList.remove('hidden');
            document.getElementById('inp-code').focus();
            return;
          }
          
          const {data:fr}=await _supabase.from('frasi').select('id,categoria').neq('categoria','SITUAZIONI QUOTIDIANE').limit(500);
          if(!fr || fr.length === 0){
            speak("Errore: nessuna frase disponibile");
            return;
          }
          
          const validPhrases = fr.filter(f => f.categoria !== 'SITUAZIONI QUOTIDIANE');
          if(validPhrases.length === 0){
            speak("Errore: tutte le frasi sono SITUAZIONI QUOTIDIANE");
            return;
          }
          const rid=validPhrases[Math.floor(Math.random()*validPhrases.length)].id;
          const {data}=await _supabase.from('stanze').insert({
            codice:cd, 
            frase_corrente_id:rid, 
            is_public:isPublic, 
            round_giocati:1,
            stato:'gioco',
            in_pausa:false,
            montepremi_round:0,
            lettere_rivelate:[],
            ultima_azione:'creazione', 
            azione_timestamp:DateUtils.now()
          }).select().maybeSingle();
          st=data;
        } else {
          const {data}=await _supabase.from('stanze').select('*').eq('codice',cd).maybeSingle();
          if(!data) {
            return speak("Stanza inesistente");
          }
          st=data;
        }
        roomId=st.id;
        
        
        safeSetToLocalStorage('lastRoomCode', cd);
        safeSetToLocalStorage('lastPlayerName', nm);

        const {data:exist}=await _supabase.from('giocatori').select('*').eq('stanza_id',roomId).eq('nome',nm).maybeSingle();
        if(exist){ 
          myId=exist.id; 
          myIndex=exist.indice; 
          isHost=exist.is_host;
          
          // Verifica che myId sia un UUID valido
          if(typeof myId === 'number') {
            alert("ERRORE DATABASE: Il tuo ID giocatore √® un numero vecchio. Devi ricreare la stanza!");
          }
        }
        else{
          // ‚úÖ CONTROLLO LIMITE: Massimo 3 giocatori per stanza
          const {data:allPlayers}=await _supabase.from('giocatori').select('id').eq('stanza_id',roomId);
          if(allPlayers && allPlayers.length >= 3){
            alert("Stanza piena! Massimo 3 giocatori.");
            speak("Stanza piena. Massimo tre giocatori.");
            return;
          }
          
          const {data:mx}=await _supabase.from('giocatori').select('indice').eq('stanza_id',roomId).order('indice',{ascending:false}).limit(1).maybeSingle();
          myIndex=(mx)?mx.indice+1:0; isHost=(myIndex===0);
          const {data:pl, error:plError}=await _supabase.from('giocatori').insert({
            stanza_id:roomId,
            nome:nm,
            indice:myIndex,
            is_host:isHost,
            // ‚úÖ BUG FIX: Non inizializzare scadenza_jolly qui
            // Il database lo imposter√† automaticamente a NULL o array vuoto
            ultimo_ping: DateUtils.now()
          }).select().maybeSingle();
          
          if(plError || !pl) {
            speak('Errore database: ' + (plError?.message || 'Controlla che il campo ultimo_ping esista nella tabella giocatori'));
            return;
          }
          myId=pl.id;
          
          // ‚úÖ UUID: Se sono il primo giocatore (host), imposto il mio UUID come turno corrente
          if(isHost && myIndex === 0){
            await _supabase.from('stanze').update({
              id_giocatore_corrente: pl.id // ‚Üê UUID del primo giocatore!
            }).eq('id', roomId);
          }
        }

        document.getElementById('setup-panel').classList.add('hidden');
        document.getElementById('game-panel').classList.remove('hidden');
        document.getElementById('btn-host-next').classList.toggle('hidden', !isHost);
        document.getElementById('btn-resume-host').classList.toggle('hidden', !isHost);
        
        
        const btnManagement = document.getElementById('btn-management');
        if(btnManagement) {
          btnManagement.textContent = isHost ? 'CONTROLLI E CLASSIFICA (S)' : 'CLASSIFICA (S)';
        }

        // ‚úÖ MEMORY LEAK FIX: Cleanup dei channel esistenti prima di ricrearne di nuovi
        if(gameChannel) {
          await gameChannel.unsubscribe();
          gameChannel = null;
        }
        if(playersChannel) {
          await playersChannel.unsubscribe();
          playersChannel = null;
        }
        if(chatChannel) {
          await chatChannel.unsubscribe();
          chatChannel = null;
        }

        gameChannel = _supabase.channel('game').on('postgres_changes',{event:'UPDATE',schema:'public',table:'stanze',filter:`id=eq.${roomId}`},fetchFullState).subscribe();
        
        // ‚úÖ CORREZIONE CHATGPT: Subscription realtime su giocatori (INSERT, UPDATE, DELETE)
        playersChannel = _supabase.channel('players').on('postgres_changes',{event:'*',schema:'public',table:'giocatori',filter:`stanza_id=eq.${roomId}`}, async (payload) => {
          
          // Ricarica stato completo quando cambia la lista giocatori
          await fetchFullState();
          
          // Annuncia cambiamenti significativi
          if(payload.eventType === 'INSERT' && payload.new){
            speak(`${payload.new.nome} √® entrato nella stanza`);
          } else if(payload.eventType === 'DELETE' && payload.old){
            speak(`${payload.old.nome} ha lasciato la stanza`);
          }
        }).subscribe();
        
        chatChannel = _supabase.channel('chat').on('postgres_changes',{event:'INSERT',schema:'public',table:'chat_messaggi',filter:`stanza_id=eq.${roomId}`},payload=>{
          
          const message = payload.new.messaggio;
          const senderName = payload.new.giocatore_nome;
          
          // Check if it's a sound effect
          if(message.startsWith('[SOUND:')){
            const soundMatch = message.match(/\[SOUND:([^\]]+)\](.+)/);
            if(soundMatch){
              const soundId = soundMatch[1];
              const soundName = soundMatch[2];
              
              // Play the sound for everyone (including sender)
              playAudio(soundId);
              
              // Speak it if it's from someone else
              if(senderName !== nm) {
                speakChat(`${senderName} ha fatto: ${soundName}`);
              }
              
              // Show a visual notification
              showFlashMessage(`${senderName} ${soundName}`, 'info');
            }
          } else {
            // Normal chat message
            if(senderName !== nm) {
              speakChat(`${senderName} scrive: ${message}`);
            }
          }
          
          const chatOverlay = document.getElementById('chat-overlay');
          if(chatOverlay && !chatOverlay.classList.contains('hidden')) {
            fetchChat(false); 
          }
        }).subscribe();

        fetchFullState();
        
        // ‚úÖ MEMORY LEAK FIX: Cleanup del timer esistente prima di ricrearne uno nuovo
        if(turnTimerInterval) {
          TimerManager.clearInterval(turnTimerInterval);
          turnTimerInterval = null;
        }
        turnTimerInterval = TimerManager.setInterval(checkTurnTimer, 1000);
        
        // ‚úÖ CORREZIONE CHATGPT: Avvia ping periodico dopo join
        startPeriodicPing();
        
        
        
        /* if(isHost) {
          TimerManager.setInterval(async () => {
            await checkAndRemoveDisconnectedPlayers();
          }, 10000);
        } */
      } catch(e){
        speak("Errore connessione.");
      }
    }

    async function fetchFullState(){
      if(isFetching) return; isFetching=true;
      
      // ‚úÖ CORREZIONE 2: Calcola offset temporale tra server e client
      const clientTimeBeforeQuery = Date.now();
      
      const {data:s}=await _supabase.from('stanze').select('*,frasi(*),giocatori(*)').eq('id',roomId).maybeSingle();
      
      // Calcola l'offset solo alla prima chiamata o periodicamente
      if(s && s.azione_timestamp && serverTimeOffset === 0) {
        const clientTimeAfterQuery = Date.now();
        const roundTripTime = clientTimeAfterQuery - clientTimeBeforeQuery;
        const serverTime = new Date(s.azione_timestamp).getTime();
        
        // Stima il tempo del server considerando met√† del tempo di andata/ritorno
        serverTimeOffset = serverTime + (roundTripTime / 2) - clientTimeAfterQuery;
        
        console.log(`[Sync] Offset server-client: ${serverTimeOffset}ms, RTT: ${roundTripTime}ms`);
      }
      
      isFetching=false;
      if(s) updateUI(s);
    }

    function getVowelCost(){
      // ‚úÖ FIX: Usa currentPuzzleTextWithoutHint per calcolare il costo, non il tema
      const len=(currentPuzzleTextWithoutHint||"").length;
      if(!len) return 1000;
      if(len<=50) return 500;
      if(len<=80) return 1000;
      return 2000;
    }
    
    function tryOpenVowelInput(){
      // ‚úÖ SICUREZZA: Verifica che sia il TUO turno
      if(!currentStanza) return;
      const isMyTurn = (currentStanza.id_giocatore_corrente === myId);
      
      if(!isMyTurn) {
        speak("Non √® il tuo turno.");
        playAudio('snd-miss');
        return;
      }
      
      // ‚úÖ REGOLA CRITICA: NON puoi comprare vocali subito dopo aver girato la ruota!
      // Devi prima chiamare una consonante
      // montepremi_round > 0 significa che hai appena girato e non hai ancora chiamato consonante
      if(currentStanza.montepremi_round > 0) {
        playAudio('snd-miss');
        speak("Devi prima chiamare una consonante! Hai appena girato la ruota.");
        alert("Hai appena girato la ruota!\nDevi chiamare una CONSONANTE prima di poter comprare una vocale.");
        return;
      }
      
      // ‚úÖ REGOLA: Puoi comprare vocali anche se non ci sono lettere rivelate
      // (esempio: inizio round, hai soldi dal round precedente, compri vocale PRIMA di girare)
      // RIMOSSO il controllo revealedLetters.length === 0
      
      // Controlla condizioni PRIMA di aprire l'input
      const cost = getVowelCost();
      const me = currentStanza?.giocatori?.find(p=>p.id===myId);
      const myRoundMoney = me ? (me.punteggio_round||0) : 0;
      
      // Controlla se hai abbastanza soldi
      if(myRoundMoney < cost){
        playAudio('snd-miss');
        speak(`Non hai abbastanza soldi! Servono ${cost} euro, hai ${myRoundMoney} euro.`);
        alert(`Non hai abbastanza soldi per la vocale!\nCosto: ‚Ç¨${cost}\nHai: ‚Ç¨${myRoundMoney}`);
        return;
      }
      
      // Controlla se hai gi√† comprato una vocale
      if(vowelsBoughtThisTurn >= 1){
        playAudio('snd-miss');
        speak("Hai gi√† comprato una vocale! Devi girare la ruota prima di comprarne un'altra.");
        alert("Hai gi√† comprato una vocale in questo giro!\nGira la ruota prima di comprarne un'altra.");
        return;
      }
      
      // Ok, apri l'input
      openInput('vowel');
    }

    function hasActiveJolly(me, stanza){
      if(!me || !stanza) return false;
      const currentRound = stanza.round_giocati || 1;
      const jollyArray = Array.isArray(me.scadenza_jolly) ? me.scadenza_jolly : [];
      const activeJollies = jollyArray.filter(expiryRound => expiryRound >= currentRound);
      return activeJollies.length > 0;
    }
    async function consumeJolly(){ 
      // ‚úÖ NUOVO: Rimuove il jolly con scadenza pi√π vicina
      const me = currentStanza?.giocatori?.find(p => p.id === myId);
      if(!me) return;
      
      const currentRound = currentStanza?.round_giocati || 1;
      let jollyArray = Array.isArray(me.scadenza_jolly) ? [...me.scadenza_jolly] : [];
      
      // Filtra jolly ancora validi
      jollyArray = jollyArray.filter(expiryRound => expiryRound >= currentRound);
      
      // Rimuovi il jolly con scadenza pi√π vicina (il primo che scadrebbe)
      if(jollyArray.length > 0) {
        jollyArray.sort((a, b) => a - b); // Ordina per scadenza crescente
        jollyArray.shift(); // Rimuovi il primo (quello che scade prima)
      }
      
      await _supabase.from('giocatori').update({scadenza_jolly: jollyArray}).eq('id', myId);
    }

    async function tryUseJollyToAvoid(kindLabel){
      if(!currentStanza || !currentStanza.giocatori) {
        return false;
      }
      
      const me = currentStanza.giocatori.find(p=>p.id===myId);
      if(!me) {
        return false;
      }
      
      const hasJolly = hasActiveJolly(me, currentStanza);
      
      if(!hasJolly) {
        return false;
      }
      
      // Show custom dialog asking if player wants to use Jolly
      const useJolly = await showJollyProtectionDialog(kindLabel, me, currentStanza);
      if(!useJolly) {
        console.log('tryUseJollyToAvoid: giocatore ha scelto di NON usare il Jolly');
        return false;
      }
      
      await consumeJolly();
      
      const myName = document.getElementById('inp-name').value || 'Giocatore';
      await _supabase.from('stanze').update({montepremi_round:0,ultima_azione:'jolly',ultimo_messaggio:`${myName} usa JOLLY per evitare ${kindLabel}!`,azione_timestamp: DateUtils.now()}).eq('id', roomId);
      
      speak(`JOLLY usato! Hai evitato ${kindLabel}!`);
      showFlashMessage('JOLLY USATO!', 'good');
      
      return true;
    }
    
    function showJollyProtectionDialog(kindLabel, me, stanza) {
      return new Promise((resolve) => {
        // Get Jolly info
        const currentRound = stanza.round_giocati || 1;
        let jollyArray = Array.isArray(me.scadenza_jolly) ? [...me.scadenza_jolly] : [];
        jollyArray = jollyArray.filter(expiryRound => expiryRound >= currentRound);
        jollyArray.sort((a, b) => a - b);
        
        let jollyInfo = '';
        if(jollyArray.length === 1) {
          jollyInfo = `Hai 1 Jolly (scade al round ${jollyArray[0]})`;
        } else if(jollyArray.length === 2) {
          jollyInfo = `Hai 2 Jolly (scadono ai round ${jollyArray[0]} e ${jollyArray[1]})`;
        }
        
        // Create overlay
        const overlay = document.createElement('div');
        overlay.id = 'jolly-protection-overlay';
        overlay.setAttribute('role', 'alertdialog');
        overlay.setAttribute('aria-modal', 'true');
        overlay.setAttribute('aria-labelledby', 'jolly-dialog-title');
        overlay.setAttribute('aria-describedby', 'jolly-dialog-desc');
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.95);
          z-index: 99999;
          display: flex;
          align-items: center;
          justify-content: center;
          animation: fadeIn 0.2s ease-out;
        `;
        
        overlay.innerHTML = `
          <div style="
            background: linear-gradient(135deg, #1a0a00 0%, #2d1810 100%);
            border: 5px solid #FFD700;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5), inset 0 0 30px rgba(255, 215, 0, 0.1);
            text-align: center;
          ">
            <div style="font-size: 4em; margin-bottom: 20px;">üÉè</div>
            <h2 id="jolly-dialog-title" style="
              color: #FFD700;
              margin: 0 0 15px 0;
              font-size: 2em;
              text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            ">‚ö†Ô∏è JOLLY DISPONIBILE! ‚ö†Ô∏è</h2>
            
            <p id="jolly-dialog-desc" style="
              color: #ff6b6b;
              font-size: 1.5em;
              margin: 20px 0;
              font-weight: bold;
              text-shadow: 0 0 5px rgba(255, 107, 107, 0.5);
            ">Hai pescato: ${escapeHTML(kindLabel)}</p>
            
            <p style="color: #fff; font-size: 1.2em; margin: 15px 0;">
              ${escapeHTML(jollyInfo)}
            </p>
            
            <p style="color: #aaa; font-size: 1em; margin: 20px 0 30px 0;">
              Vuoi usare un JOLLY per proteggerti?
            </p>
            
            <div style="display: flex; gap: 15px; justify-content: center;">
              <button id="jolly-use-btn" style="
                padding: 20px 40px;
                background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
                color: #000;
                border: 3px solid #FFE55C;
                border-radius: 12px;
                font-size: 1.4em;
                font-weight: bold;
                cursor: pointer;
                box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
                transition: all 0.2s;
              " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                ‚úÖ USA JOLLY
              </button>
              
              <button id="jolly-decline-btn" style="
                padding: 20px 40px;
                background: linear-gradient(135deg, #666 0%, #333 100%);
                color: #fff;
                border: 3px solid #888;
                border-radius: 12px;
                font-size: 1.4em;
                font-weight: bold;
                cursor: pointer;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
                transition: all 0.2s;
              " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                ‚ùå NON USARE
              </button>
            </div>
          </div>
        `;
        
        document.body.appendChild(overlay);
        
        // Focus first button for accessibility
        TimerManager.setTimeout(() => {
          document.getElementById('jolly-use-btn')?.focus();
        }, 100);
        
        // Handle button clicks
        document.getElementById('jolly-use-btn').addEventListener('click', () => {
          overlay.remove();
          resolve(true);
        });
        
        document.getElementById('jolly-decline-btn').addEventListener('click', () => {
          overlay.remove();
          resolve(false);
        });
        
        // Announce to screen reader
        speak(`Attenzione! Hai pescato ${kindLabel}. Hai un JOLLY disponibile. Vuoi usarlo per proteggerti?`);
      });
    }

    
    async function addBot(){
      if(!isHost || !roomId) return;
      
      
      const {data: freshStanza} = await _supabase.from('stanze').select('*, giocatori(*)').eq('id', roomId).maybeSingle();
      if(!freshStanza) return;
      
      
      if(freshStanza.giocatori.length >= MAX_PLAYERS) {
        speak("Stanza piena! Massimo " + MAX_PLAYERS + " giocatori.");
        return;
      }
      
      const botNames = [
        "BOT Giulia", "BOT Matteo", "BOT Sofia", "BOT Luca",
        "BOT Elena", "BOT Marco", "BOT Chiara", "BOT Andrea",
        "BOT Francesca", "BOT Alessandro", "BOT Federico", "BOT Lorenzo"
      ];
      const usedNames = freshStanza.giocatori.map(p => p.nome);
      
      // Filtra i nomi disponibili
      const availableNames = botNames.filter(n => !usedNames.includes(n));
      
      // Scegli un nome casuale tra quelli disponibili
      const name = availableNames.length > 0 
        ? availableNames[Math.floor(Math.random() * availableNames.length)]
        : "BOT " + Math.floor(Math.random()*1000);
      
      const lastInd = freshStanza.giocatori[freshStanza.giocatori.length-1].indice;
      
      await _supabase.from('giocatori').insert({
        stanza_id:roomId, 
        nome:name, 
        indice:lastInd+1, 
        is_host:false,
        // ‚úÖ BUG FIX: Non inizializzare scadenza_jolly qui
        ultimo_ping: DateUtils.now()
      });
      speak("Bot aggiunto: " + name);
      
      
      await fetchFullState();
    }

    async function playBotTurn(botPlayer){
       if(isBotThinking) return;
       isBotThinking = true;
       
       try {
         await _supabase.from('giocatori').update({
           ultimo_ping: DateUtils.now()
         }).eq('id', botPlayer.id);

         
         const thinkTime = 200 + Math.random() * 300; // ‚úÖ VELOCIZZATO: 0.2-0.5 secondi
         await new Promise(r => TimerManager.setTimeout(r, thinkTime));

       const s = currentStanza;
       // ‚úÖ FIX: Conta solo le lettere della parte da indovinare, non del tema
       const totalLetters = currentPuzzleTextWithoutHint.replace(/[^A-Z√Ä-√ô]/gi, '').length;
       const revealedIndices = s.lettere_rivelate || [];
       
       // ‚úÖ CORREZIONE: Conta solo le lettere DELLA FRASE CORRENTE (non di tutto il round)
       const phraseUpper = currentPuzzleTextWithoutHint.toUpperCase();
       let revealedInCurrentPhrase = 0;
       let posInBoard = 0;
       
       for(let i = 0; i < phraseUpper.length; i++) {
         if(phraseUpper[i].match(/[A-Z√Ä-√ô]/)) {
           if(revealedIndices.includes(posInBoard)) {
             revealedInCurrentPhrase++;
           }
           posInBoard++;
         }
       }
       
       const ratio = revealedInCurrentPhrase / totalLetters;
       
       // ‚úÖ Vincolo minimo: deve essere rivelato almeno l'85% DELLA FRASE + minimo 5 lettere
       const minLettersNeeded = Math.max(5, Math.floor(totalLetters * 0.5));
       
       // ‚úÖ LOGICA PI√ô UMANA:
       // - 85-89% lettere: 30% chance di tentare, 70% successo (rischioso!)
       // - 90-94% lettere: 50% chance di tentare, 85% successo (ancora rischioso)
       // - 95%+ lettere: 80% chance di tentare, 95% successo (quasi sicuro)
       
       let shouldTry = false;
       let successRate = 0;
       
       if(ratio >= 0.95 && revealedInCurrentPhrase >= minLettersNeeded) {
         shouldTry = Math.random() < 0.80; // 80% prova
         successRate = 0.95; // 95% successo
       } else if(ratio >= 0.90 && revealedInCurrentPhrase >= minLettersNeeded) {
         shouldTry = Math.random() < 0.50; // 50% prova
         successRate = 0.85; // 85% successo
       } else if(ratio >= 0.85 && revealedInCurrentPhrase >= minLettersNeeded) {
         shouldTry = Math.random() < 0.30; // 30% prova
         successRate = 0.70; // 70% successo
       }
       
       if(shouldTry) {
          //‚è±Ô∏è PAUSA DRAMMATICA: Il bot "pensa" prima di tentare la soluzione
          const thinkTimeBeforeSolve = 300 + Math.random() * 500; // ‚úÖ PI√ô UMANO: 0.3-0.8 secondi
          await new Promise(r => TimerManager.setTimeout(r, thinkTimeBeforeSolve));
          
          if(Math.random() > successRate) {
             // Sbaglia!
             await _supabase.from('stanze').update({ultima_azione: 'errore', ultimo_messaggio: `${botPlayer.nome} tenta ma sbaglia la soluzione!`, azione_timestamp: DateUtils.now()}).eq('id', roomId);
             await passTurnBot(true); // ‚úÖ Mantieni il messaggio "sbaglia la soluzione"
             botFinishAction();
             return;
          }
          
          // ‚úÖ TRACCIAMENTO VINCITORE: Salva chi ha vinto questo round
          previousRoundWinnerUUID = lastRoundWinnerUUID;
          lastRoundWinnerUUID = botPlayer.id;
          
          await _supabase.from('giocatori').update({punteggio_totale:(botPlayer.punteggio_totale||0)+(botPlayer.punteggio_round||0)+1000, punteggio_round:0}).eq('id', botPlayer.id);
          
          // Round normale - vittoria
          await _supabase.from('stanze').update({stato:'finito',ultima_azione:'vittoria',ultimo_messaggio:`${botPlayer.nome} HA RISOLTO LA FRASE! Soluzione: ${currentPuzzleTextWithoutHint}`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
          
          botFinishAction();
          return;
       }

       
       if(Math.random() < 0.07 && lettersCalledThisRound.length > 3) {
          const errorChar = lettersCalledThisRound[Math.floor(Math.random()*lettersCalledThisRound.length)];
          await _supabase.from('stanze').update({ultima_azione: 'errore', ultimo_messaggio: `${botPlayer.nome} richiama la "${errorChar}" gi√† provata!`, azione_timestamp: DateUtils.now()}).eq('id', roomId);
          await passTurnBot(true); // ‚úÖ Mantieni il messaggio "lettera gi√† provata"
          botFinishAction();
          return;
       }

       
       let chosenChar = null;
       let isVowel = false;
       const costVowel = getVowelCost();
       const botMoney = botPlayer.punteggio_round || 0;

       
       // ‚úÖ REGOLE CORRETTE: Le vocali si COMPRANO pagando dal punteggio del ROUND
       // Il bot pu√≤ comprarle quando:
       // 1. Ha soldi sufficienti nel punteggio_round
       // 2. NON ha appena girato la ruota (montepremi_round === 0)
       // 3. Non ha gi√† comprato una vocale in questo "giro" (vowelsBoughtThisTurn < 1)
       // 
       // SEQUENZE VALIDE:
       // ‚úÖ COMPRA VOCALE ‚Üí GIRA ‚Üí CHIAMA CONSONANTE
       // ‚úÖ GIRA ‚Üí CHIAMA CONSONANTE ‚Üí COMPRA VOCALE
       // ‚ùå GIRA ‚Üí COMPRA VOCALE (vietato!)
       if(botMoney >= costVowel && s.montepremi_round === 0 && ratio > 0.15 && ratio < 0.65 && Math.random() < 0.50 && vowelsBoughtThisTurn < 1) {
           // ‚è±Ô∏è PAUSA REALISTICA: Il bot "pensa" prima di comprare la vocale
           const thinkTimeBeforeVowel = 200 + Math.random() * 300;
           await new Promise(r => TimerManager.setTimeout(r, thinkTimeBeforeVowel));
           
           chosenChar = getNextVowelHuman(lettersCalledThisRound);
           if(chosenChar) isVowel = true;
       }

       // ‚úÖ REGOLE UFFICIALI: La ruota si gira SOLO per le CONSONANTI, MAI per le vocali!
       if(s.montepremi_round === 0 && !isVowel) {
           
           // ‚úÖ RESET: Quando si gira la ruota, si pu√≤ comprare una nuova vocale NEL PROSSIMO GIRO
           // IMPORTANTE: NON resettare qui! Deve essere resettato SOLO dopo aver chiamato la consonante
           // altrimenti il bot potrebbe comprare una vocale subito dopo aver girato!
           // vowelsBoughtThisTurn = 0; // ‚ùå SPOSTATO DOPO
           
           let wheelValues = WHEEL_VALUES;
           
           let val = wheelValues[Math.floor(Math.random()*wheelValues.length)];
           
           
           
           
           // ‚úÖ FIX COMPLETO: Gestione settori speciali corretta
           
           // MISTERO: il bot sceglie intelligentemente
           if(val === 'MISTERO') {
              // Round normale: il bot decide se rischiare
              let takeSafe = 0.5; // default 50%
              
              // ‚úÖ LOGICA CORRETTA: 
              // Pochi soldi ‚Üí rischia di pi√π (non ha niente da perdere)
              // Tanti soldi ‚Üí pi√π conservativo (ha molto da perdere con bancarotta)
              if(botMoney < 500) {
                 takeSafe = 0.20; // 20% prende sicuro, 80% rischia (coraggioso!)
              } else if(botMoney > 1500) {
                 takeSafe = 0.75; // 75% prende sicuro, 25% rischia (conservativo)
              }
              
              if(Math.random() < takeSafe) {
                 // Prende 500‚Ç¨ sicuri
                 await _supabase.from('stanze').update({montepremi_round:500,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} gira MISTERO, prende 500‚Ç¨ sicuri!`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
                 botFinishAction();
                 return;
              } else {
                 // Apre il mistero - pesca un valore random da MISTERO_VALUES
                 const MISTERO_VALUES_BOT = ['RADDOPPIA','BANCAROTTA','PASSA','PASSA_AVVERSARIO','+1000','JOLLY'];
                 val = MISTERO_VALUES_BOT[Math.floor(Math.random()*MISTERO_VALUES_BOT.length)];
                 // Continua sotto per processare il valore pescato
              }
           }
           
           // JOLLY: salvalo e gira ancora
           if(val === 'JOLLY') {
              // ‚úÖ NUOVO: Accumulo max 2 Jolly con scadenza a 5 round
              const currentRound = s.round_giocati || 1;
              const maxRounds = 10;
              const jollyDuration = 5;
              
              let jollyArray = Array.isArray(botPlayer.scadenza_jolly) ? [...botPlayer.scadenza_jolly] : [];
              jollyArray = jollyArray.filter(expiryRound => expiryRound >= currentRound);
              
              const expiryRound = Math.min(currentRound + jollyDuration - 1, maxRounds);
              let msg;
              
              if(jollyArray.length >= 2) {
                msg = `${botPlayer.nome} pesca JOLLY ma ha gi√† il massimo (2 Jolly)`;
              } else {
                jollyArray.push(expiryRound);
                jollyArray.sort((a, b) => a - b);
                await _supabase.from('giocatori').update({scadenza_jolly: jollyArray}).eq('id', botPlayer.id);
                
                if(jollyArray.length === 1) {
                  msg = `${botPlayer.nome} pesca JOLLY! Ha 1 Jolly (scade al round ${expiryRound})`;
                } else {
                  msg = `${botPlayer.nome} pesca JOLLY! Ha 2 Jolly (scadono ai round ${jollyArray[0]} e ${jollyArray[1]})`;
                }
              }
              
              await _supabase.from('stanze').update({montepremi_round:0,ultima_azione:'gira_ruota',ultimo_messaggio:msg,azione_timestamp:DateUtils.now()}).eq('id', roomId);
              botFinishAction();
              return;
           }
           
           // +1000: aggiungi 1000‚Ç¨ e gira ancora
           if(val === '+1000') {
              await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)+1000}).eq('id', botPlayer.id);
              await _supabase.from('stanze').update({montepremi_round:0,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} becca +1000‚Ç¨! Gira ancora.`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
              botFinishAction();
              return;
           }
           
           // RADDOPPIA: attiva raddoppio e gira ancora
           if(val === 'RADDOPPIA') {
              await _supabase.from('stanze').update({montepremi_round:0,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} trova RADDOPPIA! Gira ancora.`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
              botFinishAction();
              return;
           }
           
           // BANCAROTTA: usa JOLLY se disponibile, altrimenti perde solo il round (NON il totale!)
           if(val === 'BANCAROTTA') {
               // ‚úÖ NUOVO: Controlla se ha almeno 1 JOLLY valido
               const currentRound = s.round_giocati || 1;
               let jollyArray = Array.isArray(botPlayer.scadenza_jolly) ? [...botPlayer.scadenza_jolly] : [];
               jollyArray = jollyArray.filter(expiryRound => expiryRound >= currentRound);
               const hasJolly = jollyArray.length > 0;
               
               if(hasJolly) {
                  // Usa il JOLLY per evitare la bancarotta (rimuovi il pi√π vicino alla scadenza)
                  jollyArray.sort((a, b) => a - b);
                  jollyArray.shift();
                  await _supabase.from('giocatori').update({scadenza_jolly: jollyArray}).eq('id', botPlayer.id);
                  await _supabase.from('stanze').update({montepremi_round:0,ultima_azione:'jolly',ultimo_messaggio:`${botPlayer.nome} usa JOLLY per evitare BANCAROTTA!`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
                  botFinishAction();
                  return;
               }
               
               // BANCAROTTA azzera punteggio_round E punteggio_totale (perde tutto)!
               await _supabase.from('giocatori').update({punteggio_round:0, punteggio_totale:0}).eq('id', botPlayer.id);
               await _supabase.from('stanze').update({montepremi_round:0,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} gira BANCAROTTA! Perde tutto.`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
               await passTurnBot(true); // ‚úÖ Mantieni il messaggio "BANCAROTTA"
               botFinishAction();
               return;
           }

           // PASSA/PASSA_TURNO/PASSA_AVVERSARIO: usa JOLLY se disponibile
           if(val === 'PASSA' || val === 'PASSA_TURNO' || val === 'PASSA_AVVERSARIO') {
               // Usa JOLLY se disponibile
               const currentRound = s.round_giocati || 1;
               let jollyArray = Array.isArray(botPlayer.scadenza_jolly) ? [...botPlayer.scadenza_jolly] : [];
               jollyArray = jollyArray.filter(expiryRound => expiryRound >= currentRound);
               const hasJolly = jollyArray.length > 0;
               
               if(hasJolly) {
                  jollyArray.sort((a, b) => a - b);
                  jollyArray.shift();
                  await _supabase.from('giocatori').update({scadenza_jolly: jollyArray}).eq('id', botPlayer.id);
                  const label = (val === 'PASSA_AVVERSARIO') ? 'PASSA ALL\'AVVERSARIO' : 'PASSA TURNO';
                  await _supabase.from('stanze').update({montepremi_round:0,ultima_azione:'jolly',ultimo_messaggio:`${botPlayer.nome} usa JOLLY per evitare ${label}!`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
                  botFinishAction();
                  return;
               }
               
               const label = (val === 'PASSA_AVVERSARIO') ? 'PASSA ALL\'AVVERSARIO' : 'PASSA TURNO';
               await _supabase.from('stanze').update({montepremi_round:0,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} gira ${label}!`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
               await passTurnBot(true); // ‚úÖ Mantieni il messaggio "PASSA TURNO"
               botFinishAction();
               return;
           }

           let prize = (typeof val === 'number') ? val : 0;
           
           
           if(prize >= 1000) {
               await new Promise(r => TimerManager.setTimeout(r, 400));
           }
           
           await _supabase.from('stanze').update({montepremi_round:prize,ultima_azione:'gira_ruota',ultimo_messaggio:`${botPlayer.nome} gira ${val}‚Ç¨`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
           botFinishAction(); 
           return; 
       } else {
           // ‚úÖ CASO: Il bot NON ha girato la ruota
           // Pu√≤ essere perch√©: 1) ha comprato una vocale, o 2) montepremi_round > 0 (gi√† girato prima)
           
           if(!chosenChar) {
               // ‚è±Ô∏è PAUSA REALISTICA: Il bot "pensa" prima di scegliere la consonante
               const thinkTimeBeforeChoice = 200 + Math.random() * 300; // ‚úÖ VELOCIZZATO: 0.2-0.5 secondi
               await new Promise(r => TimerManager.setTimeout(r, thinkTimeBeforeChoice));
               
               // ‚úÖ DEVE essere una consonante, mai una vocale!
               chosenChar = getNextConsonantHuman(lettersCalledThisRound);
           }

           if(!chosenChar) chosenChar = "Z";
           
           // ‚úÖ VALIDAZIONE MIGLIORATA: Se per qualche motivo √® una vocale MA non era intenzionale (isVowel=false), cambiala
           // IMPORTANTE: Se isVowel=true, significa che il bot VOLEVA comprare una vocale, quindi la lasciamo!
           if("AEIOU".includes(chosenChar) && !isVowel) {
               console.warn(`‚ö†Ô∏è BUG RILEVATO: Il bot ha scelto una vocale (${chosenChar}) dopo aver girato la ruota! Questo √® VIETATO. Cambio in consonante...`);
               
               // Prova con consonanti sicure che non sono state ancora chiamate
               const safeConsonants = ['R', 'S', 'T', 'N', 'L', 'C', 'D', 'M', 'P', 'Z', 'V', 'B', 'F', 'G', 'H', 'Q'];
               let foundSafe = false;
               for(let safeCons of safeConsonants) {
                 if(!lettersCalledThisRound.includes(safeCons)) {
                   chosenChar = safeCons;
                   foundSafe = true;
                   console.log(`‚úÖ Sostituito con consonante sicura: ${safeCons}`);
                   break;
                 }
               }
               
               if(!foundSafe) {
                 chosenChar = "Z"; // Fallback finale
                 console.warn(`‚ö†Ô∏è Nessuna consonante sicura disponibile, uso Z come fallback`);
               }
           } 

           // ‚úÖ FIX: Aggiungi la lettera chiamata PRIMA di verificare se √® presente
           // Altrimenti il bot richiamer√† all'infinito lettere sbagliate!
           if(!lettersCalledThisRound.includes(chosenChar)) {
               lettersCalledThisRound.push(chosenChar);
           }

           
           let foundIndices = []; let gIdx = 0;
           const sol = currentPuzzleTextWithoutHint.toUpperCase();
           const cleanChar = cleanStr(chosenChar);
           for(let i=0; i<sol.length; i++) {
               if(sol[i].match(/[A-Z√Ä-√ô]/)) {
                   if(cleanStr(sol[i]) === cleanChar) foundIndices.push(gIdx);
                   gIdx++;
               }
           }
           const newFound = foundIndices.filter(idx => !s.lettere_rivelate.includes(idx));

           // ‚úÖ FIX CRITICO: Verifica se chosenChar √® EFFETTIVAMENTE una vocale
           // Spostata qui per essere accessibile sia nel ramo if che nel ramo else
           const isActuallyVowel = "AEIOU".includes(chosenChar);

           if(newFound.length > 0) {
               const newRev = [...s.lettere_rivelate, ...newFound];
               let gain = 0;
               if(isActuallyVowel) {
                   // Si paga la vocale
                   await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)-costVowel}).eq('id', botPlayer.id);
                   vowelsBoughtThisTurn++;
               } else {
                   // ‚úÖ FIX: Calcola gain con moltiplicatore RADDOPPIA (fase_speciale=2)
                   // PIATTO (fase_speciale=3) non si moltiplica per numero lettere n√© per RADDOPPIA
                   const multiplier = (s.fase_speciale === 2) ? 2 : 1;
                   gain = (s.fase_speciale === 3) ? (s.montepremi_round||0) : ((s.montepremi_round||0) * newFound.length * multiplier);
                   await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)+gain}).eq('id', botPlayer.id);
                   
                   // ‚úÖ RESET CORRETTO: Dopo aver trovato una CONSONANTE, pu√≤ comprare una vocale nel prossimo giro
                   vowelsBoughtThisTurn = 0;
               }
               
               let updateMessage;
               // Messaggio in base al tipo di lettera
               if(isActuallyVowel) {
                   // Ha pagato per la vocale
                   updateMessage = `${botPlayer.nome}, Trovate ${newFound.length} ${chosenChar}`;
               } else {
                   // Consonante trovata
                   updateMessage = `${botPlayer.nome}, Trovate ${newFound.length} ${chosenChar}`;
               }
               
               await _supabase.from('stanze').update({lettere_rivelate:newRev,montepremi_round:0,ultima_azione:'chiama_lettera',ultimo_messaggio:updateMessage,azione_timestamp:DateUtils.now()}).eq('id', roomId);
               
               botFinishAction();
               return;
           } else {
               // Lettera non trovata
               if(isActuallyVowel) {
                   // Paga anche se non trovata
                   await _supabase.from('giocatori').update({punteggio_round:(botPlayer.punteggio_round||0)-costVowel}).eq('id', botPlayer.id);
                   vowelsBoughtThisTurn++;
               }
               
               // ‚úÖ ACCESSIBILIT√Ä: Messaggio chiaro del motivo della perdita turno
               const letterType = isActuallyVowel ? 'vocale' : 'consonante';
               const errorMessage = `${botPlayer.nome}, ${chosenChar} assente`;
               
               await _supabase.from('stanze').update({ultima_azione:'errore',ultimo_messaggio:errorMessage,azione_timestamp:DateUtils.now()}).eq('id', roomId);
               
               botFinishAction();
               await passTurnBot(true); // ‚úÖ Mantieni il messaggio "lettera assente"
               return; 
           }
       }
       botFinishAction();
       } catch(error) {
         console.error('Errore in playBotTurn:', error);
         // ‚úÖ CRITICAL: Reset isBotThinking anche in caso di errore
         isBotThinking = false;
         // Prova a passare il turno per non bloccare il gioco
         try {
           await passTurnBot();
         } catch(e) {
           console.error('Errore anche in passTurnBot:', e);
         }
       }
    }

    function isLetterAlreadyRevealedOnBoard(char, stanza) {
        let found = false; let gIdx = 0;
        const sol = currentPuzzleTextWithoutHint.toUpperCase();
        for(let i=0; i<sol.length; i++){
            if(sol[i].match(/[A-Z√Ä-√ô]/)){
                if(cleanStr(sol[i]) === cleanStr(char) && stanza.lettere_rivelate.includes(gIdx)) found = true;
                gIdx++;
            }
        }
        return found;
    }

    async function passTurnBot(keepMessage = false){
      // ‚úÖ RESET: Quando passa il turno, resetta il contatore delle vocali
      vowelsBoughtThisTurn = 0;
      
      const s=currentStanza;
      if(!s || !s.giocatori || s.giocatori.length === 0) {
        return;
      }
      
      // ‚úÖ UUID: Trova giocatore corrente per UUID
      let currIdx=s.giocatori.findIndex(p=>p.id===s.id_giocatore_corrente);
      
      
      if(currIdx === -1) {
        currIdx = 0;
      }
      
      // ‚úÖ Ottieni il nome del giocatore corrente che perde il turno
      const currentPlayer = s.giocatori[currIdx];
      const currentPlayerName = currentPlayer ? currentPlayer.nome : 'Giocatore';
      
      let nextIdx = (currIdx + 1) % s.giocatori.length;
      let nextPlayerUUID = s.giocatori[nextIdx].id; // ‚Üê UUID invece di indice!
      
      // ‚úÖ NEL ROUND SPECIALE: Non resettare fase_speciale
      let updateData = {
        id_giocatore_corrente:nextPlayerUUID,
        montepremi_round:0,
        azione_timestamp:DateUtils.now()
      };
      
      // ‚úÖ ACCESSIBILIT√Ä: Se keepMessage=true, non sovrascrivere il messaggio
      // Questo permette ai messaggi specifici (es. "lettera X non trovata") 
      // di rimanere visibili invece di essere sostituiti da "passa il turno"
      if(!keepMessage) {
        updateData.ultima_azione = 'timeout';
        updateData.ultimo_messaggio = `${currentPlayerName} passa il turno`;
      }
      
      // Resettiamo fase_speciale
      updateData.fase_speciale = 0;
      
      await _supabase.from('stanze').update(updateData).eq('id', roomId);
    }

    async function updateUI(s){
      if (!s || !s.giocatori) return;
      currentStanza=s;
      s.giocatori.sort((a,b)=>a.indice-b.indice);
      
      // ‚úÖ TITLE DINAMICO: Solo per utenti visuali, non per screen reader
      // Screen reader usa aria-live per gli annunci, non il title
      if(!isAccessibleMode) {
        const me = s.giocatori.find(p => p.id === myId);
        if(me && s.giocatore_turno === myId) {
          document.title = "Ruota - TUO TURNO";
        } else {
          document.title = "Ruota";
        }
      } else {
        // In modalit√† accessibile, usa un titolo minimale per ridurre rumore
        document.title = " "; // Spazio singolo invece di vuoto
      }
      
      // ‚úÖ FIX CHATGPT: Usa is_host dal DB come fonte di verit√† (non indice 0)
      if(myId){
        const me = s.giocatori.find(p => p.id === myId);
        if(me){
          myIndex = me.indice;
          isHost = me.is_host; // ‚Üê Usa is_host dal database, non "indice 0"
        }
      }
      
      
      if(previousPlayersList.length > 0) {
        
        const currentIds = s.giocatori.map(p => p.id);
        const previousIds = previousPlayersList.map(p => p.id);
        
        // ‚úÖ FIX CHATGPT: Annunci rimossi da qui (gi√† gestiti in playersChannel)
        // Non pi√π showFlashMessage/speak qui per evitare duplicati
        
        // Controlla solo se tutti sono usciti (caso speciale)
        if(s.giocatori.length < 1 && previousPlayersList.length > 0) {
          showFlashMessage('Tutti i giocatori sono usciti. La stanza rimane aperta.', 'info');
        }
      }
      
      
      previousPlayersList = s.giocatori.map(p => ({id: p.id, nome: p.nome}));
      
      // ‚úÖ FIX CHATGPT: Failover host automatico se l'host esce
      if(s.giocatori.length > 0){
        const currentHost = s.giocatori.find(p => p.is_host);
        
        // Se nessuno √® host, promuovi il primo giocatore
        if(!currentHost){
          const newHost = s.giocatori[0];
          
          await _supabase.from('giocatori').update({is_host: true}).eq('id', newHost.id);
          
          // Se ero io, aggiorno subito localmente
          if(newHost.id === myId){
            isHost = true;
            speak("Sei diventato l'host della stanza");
          }
          
          showFlashMessage(`${newHost.nome} √® il nuovo host`, 'info');
        }
      }
      
      
      // ‚úÖ UUID: Controlla se il giocatore corrente esiste ancora (per UUID)
      if(s.stato === 'gioco' && !s.in_pausa && isHost && s.id_giocatore_corrente !== null && s.id_giocatore_corrente !== undefined) {
        const currentPlayerExists = s.giocatori.some(p => p.id === s.id_giocatore_corrente);
        if(!currentPlayerExists) {
          showFlashMessage('Il giocatore corrente √® uscito. Passaggio automatico del turno.', 'info');
          TimerManager.setTimeout(() => passTurn(), 1500);
        }
      }

      document.getElementById('pause-panel').classList.toggle('hidden', !s.in_pausa);
      document.getElementById('game-panel').classList.toggle('hidden', s.in_pausa);
      if(s.in_pausa) return;

      if(s.stato==='terminata'){
        document.getElementById('game-panel').classList.add('hidden');
        document.getElementById('end-panel').classList.remove('hidden');
        const l=document.getElementById('ranking-list'); l.innerHTML="";
        [...s.giocatori].sort((a,b)=>b.punteggio_totale-a.punteggio_totale).forEach((p,i)=> l.innerHTML+=`<li>${i+1}. ${escapeHTML(p.nome)}: ‚Ç¨${p.punteggio_totale}</li>`);
        
        
        document.getElementById('btn-new-game').classList.toggle('hidden', !isHost);
        
        return;
      }

      if(s.stato==='finito'){
        document.getElementById('round-over-panel').classList.remove('hidden');
        document.getElementById('round-winner-msg').textContent=s.ultimo_messaggio;
        document.getElementById('solution-msg').textContent=fullSolutionText;
        if(!nextRoundInterval){
          let sec=15;
          document.getElementById('next-round-timer').textContent=sec;
          nextRoundInterval=TimerManager.setInterval(()=>{
            sec--;
            document.getElementById('next-round-timer').textContent=sec;
            if(sec<=0){
              clearInterval(nextRoundInterval); nextRoundInterval=null;
              if(isHost) startNewRound();
            }
          },1000);
        }
        if(s.azione_timestamp !== lastTimestamp){
          lastTimestamp=s.azione_timestamp;
          playAudio('snd-win');
          speak(`Fine round. ${s.ultimo_messaggio}`);
        }
        return;
      } else {
        if(nextRoundInterval){ TimerManager.clearInterval(nextRoundInterval); nextRoundInterval=null; }
        document.getElementById('round-over-panel').classList.add('hidden');
      }

      if(!currentFrase || currentFrase.id !== s.frasi.id){
        currentFrase=s.frasi;
        fullSolutionText=currentFrase.soluzione;
        
        
        // ‚úÖ PRIORIT√Ä 1: Usa il campo 'tema' se presente nel database
        if(currentFrase.tema){
          currentHintText = currentFrase.tema;
          currentPuzzleTextWithoutHint = fullSolutionText; // Solo la parte da indovinare
          currentPuzzleText = currentFrase.tema + ' ‚Äì ' + fullSolutionText; // Testo completo mostrato
        }
        // ‚úÖ PRIORIT√Ä 2: Usa il campo 'hint' (per retrocompatibilit√†)
        else if(currentFrase.hint){
          currentHintText = currentFrase.hint;
          currentPuzzleTextWithoutHint = fullSolutionText; // Solo la parte da indovinare
          currentPuzzleText = currentFrase.hint + ' ‚Äì ' + fullSolutionText; // Testo completo mostrato
        }
        // ‚úÖ PRIORIT√Ä 3: Split sull'ULTIMO trattino CON SPAZI (per frasi come CURIOSIT√Ä con formato "TEMA ‚Äì SOLUZIONE")
        // IMPORTANTE: Cerca SOLO trattini con spazi per non splittare parole composte come "AUTO-CROSS"
        else if(fullSolutionText.includes(" ‚Äì ") || fullSolutionText.includes(" - ")){
          // Trova l'ULTIMO trattino con spazi, non il primo!
          let lastDashIndex = -1;
          let dashPattern = null;
          
          // Prima cerca " ‚Äì " (trattino lungo con spazi - pi√π comune)
          if(fullSolutionText.lastIndexOf(" ‚Äì ") !== -1) {
            lastDashIndex = fullSolutionText.lastIndexOf(" ‚Äì ");
            dashPattern = " ‚Äì ";
          } 
          // Poi cerca " - " (trattino normale con spazi)
          else if(fullSolutionText.lastIndexOf(" - ") !== -1) {
            lastDashIndex = fullSolutionText.lastIndexOf(" - ");
            dashPattern = " - ";
          }
          
          if(lastDashIndex !== -1) {
            currentHintText = fullSolutionText.substring(0, lastDashIndex).trim();
            currentPuzzleTextWithoutHint = fullSolutionText.substring(lastDashIndex + dashPattern.length).trim();
            currentPuzzleText = currentHintText + ' ‚Äì ' + currentPuzzleTextWithoutHint;
          } else {
            // Fallback se qualcosa va storto
            currentHintText = "";
            currentPuzzleTextWithoutHint = fullSolutionText;
            currentPuzzleText = fullSolutionText;
          }
        } else {
          // Nessun trattino con spazi trovato ‚Üí nessun tema
          currentHintText = "";
          currentPuzzleTextWithoutHint = fullSolutionText;
          currentPuzzleText = fullSolutionText;
        }
        
        // ‚úÖ Mostra categoria + hint (se presente) in elementi separati ma dentro lo stesso H2
        // Cos√¨ NVDA legge tutto quando naviga con H
        const displayCategory = formatCategory(currentFrase.categoria);
        document.getElementById('category-main').textContent = displayCategory;
        document.getElementById('round-hint').textContent = currentHintText;
        vowelsBoughtThisTurn=0;
        
        // ‚úÖ FIX CRITICO: Pulisci lettere_rivelate da eventuali indici corrotti
        // Se il DB contiene indici calcolati sul vecchio sistema (con tema incluso),
        // potrebbero esserci indici che puntano oltre la lunghezza di currentPuzzleTextWithoutHint
        if(s.lettere_rivelate && s.lettere_rivelate.length > 0) {
          // Conta il numero totale di lettere nella parte da indovinare
          let letterCount = 0;
          const solWithoutHint = currentPuzzleTextWithoutHint.toUpperCase();
          for(let i = 0; i < solWithoutHint.length; i++) {
            if(solWithoutHint[i].match(/[A-Z√Ä-√ô]/)) {
              letterCount++;
            }
          }
          // Gli indici validi vanno da 0 a letterCount-1
          const maxValidIndex = letterCount - 1;
          
          // Filtra via indici > maxValidIndex (sono corrotti)
          const cleanedIndices = s.lettere_rivelate.filter(idx => idx <= maxValidIndex);
          
          if(cleanedIndices.length !== s.lettere_rivelate.length) {
            console.warn(`‚ö†Ô∏è Puliti ${s.lettere_rivelate.length - cleanedIndices.length} indici corrotti da lettere_rivelate (max valido: ${maxValidIndex})`);
            // Aggiorna nel DB
            await _supabase.from('stanze').update({
              lettere_rivelate: cleanedIndices
            }).eq('id', roomId);
            // Aggiorna cache locale
            s.lettere_rivelate = cleanedIndices;
            if(currentStanza) currentStanza.lettere_rivelate = cleanedIndices;
          }
        }
        
        // ‚úÖ FIX CRITICO: Il tabellone deve mostrare SOLO currentPuzzleTextWithoutHint (senza tema)!
        // Il tema viene gi√† mostrato nell'header come "Categoria: TEMA"
        parseAndRenderBoard(currentPuzzleTextWithoutHint, s.lettere_rivelate, true); // ‚úÖ Reset navigazione per nuova frase
        
//         const speakText = currentHintText 
//           ? `Nuovo Round. Categoria: ${currentFrase.categoria}. ${currentHintText}` 
//           : `Nuovo Round. Categoria: ${currentFrase.categoria}`;
//         speak(speakText);
      }

      document.getElementById('round-indicator').textContent = `R ${s.round_giocati}/10`;
      
      // ‚úÖ Aggiorna sempre la categoria con hint (se presente) - persiste anche dopo cambio fase
      // Ma SOLO se √® cambiata (per evitare troppi aggiornamenti DOM)
      if(currentFrase) {
        const categoryMain = document.getElementById('category-main');
        const roundHint = document.getElementById('round-hint');
        
        const displayCategory = formatCategory(currentFrase.categoria);
        
        if(categoryMain && categoryMain.textContent !== displayCategory) {
          categoryMain.textContent = displayCategory;
        }
        
        if(roundHint && roundHint.textContent !== currentHintText) {
          roundHint.textContent = currentHintText;
        }
      }
      
      // ‚úÖ UUID: Trova giocatore corrente per UUID (non per indice!)
      const currentPlayer = s.giocatori.find(p=>p.id===s.id_giocatore_corrente);
      const isMe=(s.id_giocatore_corrente===myId); // ‚Üê Confronta UUID con UUID!
      
      if(currentPlayer) {
      }
      
      const isBotTurn = isHost && currentPlayer && currentPlayer.nome.startsWith("BOT");
      
      if(isBotTurn){
          // Annuncia SOLO se il turno √® appena cambiato al bot
          if(!wasBotTurn) {
            // Avvisa l'utente che c'√® un bot (potrebbe essere non voluto)
            const botWarning = `Rilevato ${currentPlayer.nome}. Se non l'hai aggiunto tu, puoi eliminarlo dal pannello Giocatori (tasto S).`;
            showFlashMessage(botWarning, 'warning');
            speak(`Turno del bot: ${currentPlayer.nome}`);
          }
          
          playBotTurn(currentPlayer);
      } else {
      }

      if(!wasMyTurn && isMe){ 
        vowelsBoughtThisTurn=0; 
        lastSpinTimestamp = DateUtils.now(); 
        
        // Annuncia il cambio turno
        speak("Tocca a te."); 
        playAudio('snd-turn');
      }
      
      // ‚úÖ FIX: Chiudi overlay di input quando il turno cambia e non √® pi√π il mio turno
      if(wasMyTurn && !isMe && inputMode){
        closeInput();
        speak("Turno cambiato durante l'inserimento");
      }
      
      wasMyTurn=isMe;
      wasBotTurn=isBotTurn;
      
      const who=currentPlayer?.nome;
      document.getElementById('turn-indicator').textContent=isMe ? "TOCCA A TE" : `Turno di ${who||'...'}`;
      document.getElementById('turn-indicator').style.color=isMe ? "var(--col-green)" : "#fff";

      const isRaddoppiaActive=(s.fase_speciale===2);
      const isMysteryFlat=(s.fase_speciale===3);
      document.getElementById('double-indicator').classList.toggle('hidden', !isRaddoppiaActive);

      const me=s.giocatori.find(p=>p.id===myId);
      const myRoundMoney=me ? (me.punteggio_round||0) : 0;
      const vCost=getVowelCost();
      const jInd=document.getElementById('jolly-indicator');
      if(hasActiveJolly(me, s)){
        const currentRound = s.round_giocati || 1;
        let jollyArray = Array.isArray(me.scadenza_jolly) ? [...me.scadenza_jolly] : [];
        jollyArray = jollyArray.filter(expiryRound => expiryRound >= currentRound);
        jollyArray.sort((a, b) => a - b);
        
        if(jollyArray.length === 1) {
          jInd.textContent = `1 JOLLY ATTIVO (scade al round ${jollyArray[0]})`;
        } else if(jollyArray.length === 2) {
          jInd.textContent = `2 JOLLY ATTIVI (scadono ai round ${jollyArray[0]}, ${jollyArray[1]})`;
        }
        jInd.classList.remove('hidden');
      } else jInd.classList.add('hidden');
      
      let canSpin=isMe && !isSpinning && !inputMode && s.montepremi_round===0 && !isProcessingInput;
      let canSolve=isMe && !isSpinning && !inputMode && !isProcessingInput; // ‚úÖ Puoi sempre risolvere quando √® il tuo turno
      let canPass=isMe && !isSpinning && !isProcessingInput;
      let canVowel=isMe && !isSpinning && !inputMode && !isProcessingInput;
      
      // ‚úÖ NUOVA REGOLA: Puoi comprare vocali SOLO se hai rivelato lettere (frase parziale)
      const hasRevealedLetters = (s.lettere_rivelate || []).length > 0;
      if(!hasRevealedLetters) canVowel=false;
      
      if(myRoundMoney < vCost) canVowel=false;
      if(vowelsBoughtThisTurn>=1) canVowel=false;
      if(isRaddoppiaActive) canVowel=false;
      
      // ‚úÖ FIX: Raddoppia deve sovrascrivere TUTTO
      if(isRaddoppiaActive && isMe) {
        canSpin = true; // Forza abilitazione anche se altri controlli dicono di no
      }

      setBtnState('btn-spin', !canSpin);
      setBtnState('btn-solve', !canSolve);
      // setBtnState('btn-pass', !canPass); // Pulsante PASSA rimosso (non serve nei round normali)
      
      // ‚úÖ PASSA ALL'AVVERSARIO: pulsante rimosso (non serve nei round normali)
      // let canPassOpponent = canPass && s.giocatori.length > 1;
      // setBtnState('btn-pass-opponent', !canPassOpponent);
      
      const btnV=document.getElementById('btn-vowel');
      setBtnState('btn-vowel', !canVowel);
      btnV.textContent=`VOCALE (‚Ç¨${vCost})`;

      let canManual=isMe && !isSpinning && !inputMode && s.montepremi_round>0;
      
      const btnSurrender = document.getElementById('btn-surrender');
      if(btnSurrender) {
        btnSurrender.classList.add('hidden'); // Nascondi sempre ARRENDI
      }
      
      // CORREZIONE: Salva il focus PRIMA di qualsiasi modifica al DOM
      const focusedElement = document.activeElement;
      const focusedId = focusedElement?.id;
      const focusedTag = focusedElement?.tagName;
      const wasInputModeNull = !inputMode; // Salva lo stato prima di openInput
      
      // ‚úÖ APERTURA AUTOMATICA CAMPO CONSONANTE: 
      // Si apre SOLO se non c'√® gi√† un campo aperto (inputMode √® null)
      // Se l'utente ha manualmente aperto vocale o risolvi, NON sovrascrivere
      // NON riapre se √® ancora in fase di processing (evita riapertura dopo submit)
      const willOpenInput = canManual && wasInputModeNull && !isProcessingInput;
      if(willOpenInput) {
        openInput('letter');
      }

      // ‚úÖ GUARD: Non re-render se l'utente sta scrivendo
      // IMPORTANTE: Usa inputMode invece di document.activeElement per evitare il paradosso:
      // - openInput() imposta inputMode PRIMA di fare focus (a T=0ms)
      // - Il focus arriva solo dopo 100ms
      // - Se usiamo activeElement, isTyping √® FALSE durante quei 100ms
      // - Questo causa un re-render del DOM proprio mentre NVDA sta atterrando sul campo
      const inputArea_check = document.getElementById('input-area');
      const isTyping = inputArea_check && !inputArea_check.classList.contains('hidden') && inputMode !== null;
      
      if (!isTyping) {
        // ‚úÖ FIX CRITICO: Usa currentPuzzleTextWithoutHint per mostrare solo la parte da indovinare
        parseAndRenderBoard(currentPuzzleTextWithoutHint, s.lettere_rivelate);
      }
      if(isAccessibleMode) updateAccessibleBoard();
      
      // ‚úÖ FIX NVDA FOCUS: Il focus viene impostato SOLO quando il campo viene aperto per la prima volta
      // NON viene pi√π forzato continuamente durante gli aggiornamenti
      // Questo evita che NVDA esca dalla modalit√† focus mentre l'utente sta scrivendo
      // Il focus viene gestito ESCLUSIVAMENTE in openInput(), non qui
      
      if(me){
        const roundScore = me.punteggio_round||0;
        const totalScore = me.punteggio_totale||0;
        document.getElementById('score-round').textContent=roundScore;
        document.getElementById('score-total').textContent=totalScore;
      } else {
        document.getElementById('score-round').textContent='?';
        document.getElementById('score-total').textContent='?';
      }
      let statusTxt="";
      if(s.montepremi_round>0) statusTxt = isMysteryFlat ? `IN PALIO: ‚Ç¨${s.montepremi_round} (Piatto)` : `IN PALIO: ‚Ç¨${s.montepremi_round}`;
      else if(isRaddoppiaActive) statusTxt="RADDOPPIA ATTIVO! GIRA!";
      document.getElementById('wheel-status-text').textContent=statusTxt;

      if(s.azione_timestamp !== lastTimestamp){
        lastTimestamp=s.azione_timestamp;
        addActionToHistory(s.ultimo_messaggio || s.ultima_azione || "Azione");
        if(s.ultima_azione==='errore') playAudio('snd-miss');
        else if(s.ultima_azione==='gira_ruota' && (s.ultimo_messaggio||"").includes("BANCAROTTA")) playAudio('snd-bankrupt');
        else if(s.ultima_azione==='chiama_lettera') {
            // ‚úÖ FIX: Riproduci il suono SOLO se il timestamp √® cambiato
            // Questo previene sovrapposizioni quando updateUI viene chiamato pi√π volte
            const match = (s.ultimo_messaggio || "").match(/Trovate (\d+)/);
            const count = match ? parseInt(match[1]) : 0; // ‚úÖ FIX: Default 0 invece di 1
            
            // ‚úÖ Riproduci beep SOLO se count > 0
            if(count > 0 && count <= 20) {  // Sanity check: max 20 beep
              playMultipleHits(count);
            }
        }
        showFlashMessage(s.ultimo_messaggio, 'info');
        
        // ‚úÖ FIX DUPLICATO: Annuncia SOLO se non √® stato gi√† fatto localmente
        // Quando chiami una consonante/vocale, viene fatto speak() immediato nel tryConsonant/tryBuyVowel
        // Poi il DB si aggiorna e triggera fetchFullState -> updateUI
        // Qui controlliamo se l'annuncio √® gi√† stato fatto per evitare duplicati
        if (!localAnnouncementMade) {
          speak(s.ultimo_messaggio);
        }
        // Reset flag per la prossima azione
        localAnnouncementMade = false;
      }
      
      
      const btnManagement = document.getElementById('btn-management');
      if(btnManagement) {
        btnManagement.textContent = isHost ? 'CONTROLLI E CLASSIFICA (S)' : 'CLASSIFICA (S)';
      }
    }

    function animateWheelSpin(){
      const wheel=document.getElementById('wheel-visual');
      wheelRotation += 720 + Math.floor(Math.random()*720);
      wheel.style.transform=`rotate(${wheelRotation}deg)`;
    }

    async function doSpin(){
      if(isBtnDisabled('btn-spin') || !currentStanza) return;
      
      // ‚úÖ SICUREZZA CRITICA: Verifica che sia il TUO turno
      const s = currentStanza;
      const isMyTurn = (s.id_giocatore_corrente === myId);
      
      if(!isMyTurn) {
        speak("Non √® il tuo turno.");
        playAudio('snd-miss');
        return;
      }
      
      // ‚úÖ FIX CRITICO: NON resettare vowelsBoughtThisTurn quando giri la ruota!
      // Il reset deve avvenire DOPO aver chiamato e TROVATO una consonante
      // Altrimenti puoi: GIRA ‚Üí COMPRA VOCALE (che √® vietato!)
      // Sequenza corretta: GIRA ‚Üí CHIAMA CONSONANTE ‚Üí (se trovi) reset ‚Üí COMPRA VOCALE
      // vowelsBoughtThisTurn = 0; // ‚ùå RIMOSSO
      
      isSpinning=true;
      
      // ‚úÖ SAFETY: Timeout di sicurezza per resettare isSpinning se qualcosa va storto
      const spinningTimeout = TimerManager.setTimeout(() => {
        if(isSpinning) {
          console.warn('SAFETY: isSpinning resettato dopo timeout di 10 secondi');
          isSpinning = false;
          if(currentStanza) updateUI(currentStanza);
        }
      }, 10000);
      
      speak("Giro la ruota.");
      playAudio('snd-spin');
      animateWheelSpin();
      await new Promise(r=>TimerManager.setTimeout(r,3000));
      
      let wheelValues = WHEEL_VALUES;
      
      let val=wheelValues[Math.floor(Math.random()*wheelValues.length)];
      
      const myName=document.getElementById('inp-name').value;
      
      const me=currentStanza.giocatori.find(p=>p.id===myId);
      
      const activeMultiplier=(currentStanza.fase_speciale===2) ? 2 : 1;
      let nextFaseSpeciale=0;
      let mysterySafeFlat=false;

      if(val==='MISTERO'){
        // Round normale: chiedi scelta
        const openIt = await askMysteryChoice(); 
        if(!openIt){
          val = 500;
          mysterySafeFlat = true;
          speak("Hai scelto 500 euro sicuri");
        } else {
          val = MISTERO_VALUES[Math.floor(Math.random()*MISTERO_VALUES.length)];
            
            
            let mysteryResultText = "";
            if(val === 'BANCAROTTA') mysteryResultText = "BANCAROTTA!";
            else if(val === 'RADDOPPIA') mysteryResultText = "RADDOPPIA!";
            else if(val === '+1000') mysteryResultText = "+1000 EURO!";
            else if(val === 'JOLLY') mysteryResultText = "JOLLY!";
            else if(val === 'PASSA' || val === 'PASSA_TURNO') mysteryResultText = "PASSA TURNO";
            else if(val === 'PASSA_AVVERSARIO') mysteryResultText = "PASSA ALL'AVVERSARIO";
            else mysteryResultText = `${val}`;
            
            speak(`Mistero svelato: ${mysteryResultText}`);
        }
      }

      if(val==='BANCAROTTA'){
        isSpinning=false;
        TimerManager.clearTimeout(spinningTimeout); // ‚úÖ Cancella timeout di sicurezza
        
        // ‚úÖ FIX CRITICO: Ricarica i dati freschi dal DB per avere scadenza_jolly aggiornato!
        const {data: freshData} = await _supabase.from('stanze').select('*, giocatori(*)').eq('id', roomId).single();
        if(freshData && freshData.giocatori) {
          currentStanza.giocatori = freshData.giocatori; // Aggiorna i dati dei giocatori
        }
        
        const saved=await tryUseJollyToAvoid("BANCAROTTA");
        if(saved) return;
        
        // Perde tutto e passa turno
        vowelsBoughtThisTurn = 0;
        
        await _supabase.from('giocatori').update({punteggio_round:0, punteggio_totale:0}).eq('id', myId);
        await _supabase.from('stanze').update({
          montepremi_round: 0,
          fase_speciale: 0,
          ultima_azione:'gira_ruota',
          ultimo_messaggio:`${myName} becca BANCAROTTA! Perde tutto!`,
          azione_timestamp:DateUtils.now()
        }).eq('id', roomId);
        
        addActionToHistory(`${myName} BANCAROTTA! Perde tutto`);
        speak("BANCAROTTA. Hai perso tutto e passi il turno.");
        showFlashMessage('BANCAROTTA!', 'bad');
        
        passTurn();
        return;
      }

      if(val==='PASSA' || val==='PASSA_TURNO' || val==='PASSA_AVVERSARIO'){
        isSpinning=false;
        TimerManager.clearTimeout(spinningTimeout); // ‚úÖ Cancella timeout di sicurezza
        
        // ‚úÖ FIX CRITICO: Ricarica i dati freschi dal DB per avere scadenza_jolly aggiornato!
        const {data: freshData} = await _supabase.from('stanze').select('*, giocatori(*)').eq('id', roomId).single();
        if(freshData && freshData.giocatori) {
          currentStanza.giocatori = freshData.giocatori; // Aggiorna i dati dei giocatori
        }
        
        const label=(val==='PASSA_AVVERSARIO') ? "PASSA ALL'AVVERSARIO" : "PASSA TURNO";
        const saved=await tryUseJollyToAvoid(label);
        if(saved) return;
        
        // Azzera fase e passa turno
        vowelsBoughtThisTurn = 0;
        
        await _supabase.from('stanze').update({
          montepremi_round: 0,
          fase_speciale: 0,
          ultima_azione:'gira_ruota',
          ultimo_messaggio:`${myName} becca ${label}!`,
          azione_timestamp:DateUtils.now()
        }).eq('id', roomId);
        
        addActionToHistory(`${myName} ${label}`);
        speak(`${label}. Passi il turno.`);
        showFlashMessage(`${label}`, 'bad');
        
        passTurn();
        return;
      }

      let finalPrize=0;
      let msg=`${myName} gira ${val}`;
      
      if(typeof val==='number'){
        if(mysterySafeFlat){
          finalPrize = val;
          msg = `${myName} prende ${val}‚Ç¨ (piatto)!`;
          nextFaseSpeciale = 3;
        } else {
          finalPrize = val * activeMultiplier;
          if(activeMultiplier>1) {
            msg = `${myName} gira ${val} x 2 = ${finalPrize}!`;
          }
          nextFaseSpeciale = 0;
        }
      } else if(val==='+1000'){
        await _supabase.from('giocatori').update({punteggio_round:(me.punteggio_round||0)+1000}).eq('id', myId);
        finalPrize=0;
        msg=`${myName} becca +1000‚Ç¨! Gira ancora.`;
        nextFaseSpeciale=0;
      } else if(val==='RADDOPPIA'){
        finalPrize=0;
        msg=`${myName} trova RADDOPPIA! Gira ancora.`;
        nextFaseSpeciale=2;
      } else if(val==='JOLLY'){
        // ‚úÖ NUOVO SISTEMA: Accumulo max 2 Jolly con scadenza a 5 round
        const currentRound = currentStanza.round_giocati || 1;
        const maxRounds = 10; // Massimo round della partita
        const jollyDuration = 5; // Durata in round
        
        let jollyArray = Array.isArray(me.scadenza_jolly) ? [...me.scadenza_jolly] : [];
        
        // Rimuovi jolly gi√† scaduti
        jollyArray = jollyArray.filter(expiryRound => expiryRound >= currentRound);
        
        // Calcola quando scade questo nuovo jolly
        const expiryRound = Math.min(currentRound + jollyDuration - 1, maxRounds);
        
        if(jollyArray.length >= 2) {
          // Hai gi√† 2 Jolly (massimo)
          msg=`${myName} pesca un JOLLY ma hai gi√† il massimo (2 Jolly). Non puoi accumularne altri.`;
        } else {
          // Aggiungi il nuovo jolly
          jollyArray.push(expiryRound);
          jollyArray.sort((a, b) => a - b); // Ordina per scadenza
          
          await _supabase.from('giocatori').update({scadenza_jolly: jollyArray}).eq('id', myId);
          
          const jollyCount = jollyArray.length;
          if(jollyCount === 1) {
            msg=`${myName} pesca il JOLLY! Ora hai 1 Jolly. Protegge da bancarotta e passa turno fino al round ${expiryRound}. Gira di nuovo.`;
          } else {
            msg=`${myName} pesca il JOLLY! Ora hai 2 Jolly. Protegge da bancarotta e passa turno fino ai round ${jollyArray[0]} e ${jollyArray[1]}. Gira di nuovo.`;
          }
        }
        
        finalPrize=0;
        nextFaseSpeciale=0;
      }

      isSpinning=false;
      TimerManager.clearTimeout(spinningTimeout); // ‚úÖ Cancella timeout di sicurezza
      lastSpinTimestamp = DateUtils.now();
      
      const updateResult = await _supabase.from('stanze').update({
        montepremi_round:finalPrize,
        fase_speciale:nextFaseSpeciale,
        ultima_azione:'gira_ruota',
        ultimo_messaggio:msg,
        azione_timestamp:DateUtils.now()
      }).eq('id', roomId);
      
      if(updateResult.error) {
        alert('ERRORE: ' + updateResult.error.message);
        return;
      }
      
      addActionToHistory(msg);
      
      // ‚úÖ ANNUNCIO SCREEN READER: Comunica quanto hai girato
      if(typeof val === 'number' && finalPrize > 0) {
        speak(`Hai girato ${finalPrize} euro.`);
      } else if(val === '+1000') {
        speak("Pi√π mille euro.");
      } else if(val === 'RADDOPPIA') {
        speak("RADDOPPIA. Gira ancora.");
      } else if(val === 'JOLLY') {
        speak("JOLLY. Gira ancora.");
      }
      // Per PASSA/BANCAROTTA gli annunci sono gi√† gestiti sopra
      
      // ‚úÖ FIX RACE CONDITION: Aspetta 500ms prima di fetchare lo stato
      // Questo d√† tempo al database di propagare l'aggiornamento
      await new Promise(r => TimerManager.setTimeout(r, 500));
      
      await fetchFullState();
      
      
      if(finalPrize > 0 && !mysterySafeFlat) {
        
        
        
        if(currentStanza) {
          currentStanza.montepremi_round = finalPrize;
          currentStanza.fase_speciale = nextFaseSpeciale;
          currentStanza.ultima_azione = 'gira_ruota';
          currentStanza.ultimo_messaggio = msg;
        }
        
        // openInput('letter') viene chiamato automaticamente da updateUI quando montepremi_round > 0
      } else {
        // ‚úÖ CORREZIONE: Aggiorna manualmente currentStanza per sincronizzazione immediata
        if(currentStanza) {
          currentStanza.montepremi_round = finalPrize;
          currentStanza.fase_speciale = nextFaseSpeciale;
          currentStanza.ultima_azione = 'gira_ruota';
          currentStanza.ultimo_messaggio = msg;
        }
        
        if(val === 'JOLLY') {
          // ‚úÖ CORRETTO: Ricarica il giocatore DOPO fetchFullState per avere il valore aggiornato
          const { data: freshData, error: freshError } = await _supabase
            .from('stanze')
            .select('*, giocatori(*)')
            .eq('id', roomId)
            .single();
          
          const freshMe = freshData?.giocatori?.find(p => p.id === myId);
          const currentRound = freshData?.round_giocati || 1;
          
          let jollyArray = Array.isArray(freshMe?.scadenza_jolly) ? [...freshMe.scadenza_jolly] : [];
          jollyArray = jollyArray.filter(expiryRound => expiryRound >= currentRound);
          jollyArray.sort((a, b) => a - b);
          
          // ‚úÖ FIX BUG: Definisci jollyText PRIMA di usarlo in showFlashMessage
          let jollyText;
          if(jollyArray.length === 1) {
            jollyText = `1 Jolly (scade al round ${jollyArray[0]})`;
            speak(`Hai pescato il JOLLY! Ora hai ${jollyText}. Protegge da bancarotta e passa turno. Gira di nuovo.`);
          } else if(jollyArray.length === 2) {
            jollyText = `2 Jolly (scadono ai round ${jollyArray[0]} e ${jollyArray[1]})`;
            speak(`Hai pescato il JOLLY! Ora hai ${jollyText}. Protegge da bancarotta e passa turno. Gira di nuovo.`);
          } else {
            // Caso edge: nessun jolly (non dovrebbe succedere ma per sicurezza)
            jollyText = `${jollyArray.length} Jolly`;
            speak(`Hai pescato il JOLLY! Protegge da bancarotta e passa turno. Gira di nuovo.`);
          }
          
          localAnnouncementMade = true;
          showFlashMessage(`JOLLY! Ora hai ${jollyText}`, 'good');
        } else if(val === '+1000') {
          speak(`Hai guadagnato mille euro! Ora gira di nuovo!`);
          localAnnouncementMade = true;
          showFlashMessage(`+1000 EURO GUADAGNATI!`, 'good');
        } else if(val === 'RADDOPPIA') {
          speak(`Raddoppia attivo! Il prossimo giro vale il doppio. Gira ora.`);
          localAnnouncementMade = true;
          showFlashMessage(`RADDOPPIA ATTIVO!`, 'good');
        }
      }
    }

    async function passTurn(fromError = false){
      if(isHandlingTimeout) {
        return;
      }
      
      isHandlingTimeout=true;
      vowelsBoughtThisTurn=0;
      const s=currentStanza;
      
      if(!s || !s.giocatori || s.giocatori.length === 0) {
        isHandlingTimeout=false;
        return;
      }
      
      // ‚úÖ UUID: Trova giocatore corrente per UUID (non per indice!)
      let currIdx=s.giocatori.findIndex(p=>p.id===s.id_giocatore_corrente);
      
      // Se non trovato (UUID non esiste pi√π), torna al primo
      if(currIdx === -1) {
        currIdx = 0;
      }
      
      // ‚úÖ Ottieni il nome del giocatore corrente che perde il turno
      const currentPlayer = s.giocatori[currIdx];
      const currentPlayerName = currentPlayer ? currentPlayer.nome : 'Giocatore';
      
      // Passa al prossimo giocatore
      let nextIdx = (currIdx + 1) % s.giocatori.length;
      let nextPlayerUUID = s.giocatori[nextIdx].id; // ‚Üê UUID invece di indice!
      
      let updateData = {
        id_giocatore_corrente:nextPlayerUUID,
        montepremi_round:0,
        fase_speciale: 0,
        ultima_azione:'passa_turno',
        ultimo_messaggio:`${currentPlayerName} passa il turno`,
        azione_timestamp:DateUtils.now()
      };
      
      const {error} = await _supabase.from('stanze').update(updateData).eq('id', roomId);
      
      if(error){
      } else {
      }
      
      isHandlingTimeout=false;
      
      // Forza refresh
      await fetchFullState();
    }
    
    async function passToOpponent(){
      // ‚úÖ Solo il giocatore di turno o l'host possono passare
      if(!isHost && !isMe){
        speak("Non puoi passare all'avversario");
        return;
      }
      
      const s=currentStanza;
      if(!s || !s.giocatori || s.giocatori.length === 0) return;
      
      // ‚úÖ Se 1 giocatore: non puoi passare
      if(s.giocatori.length === 1) {
        speak("Non puoi passare all'avversario se sei da solo");
        playAudio('snd-miss');
        return;
      }
      
      // ‚úÖ Se 2 giocatori: passa automaticamente all'altro
      if(s.giocatori.length === 2) {
        let currIdx=s.giocatori.findIndex(p=>p.id===s.id_giocatore_corrente);
        if(currIdx === -1) currIdx = 0;
        let nextIdx = (currIdx + 1) % 2;
        let nextPlayerUUID = s.giocatori[nextIdx].id;
        
        const myName = document.getElementById('inp-name').value || 'Giocatore';
        
        await _supabase.from('stanze').update({
          id_giocatore_corrente:nextPlayerUUID,
          montepremi_round:0,
          ultima_azione:'passa_avversario',
          ultimo_messaggio:`${myName} passa il turno a ${s.giocatori[nextIdx].nome}`,
          azione_timestamp:DateUtils.now()
        }).eq('id', roomId);
        
        speak(`Hai passato il turno a ${s.giocatori[nextIdx].nome}`);
        await fetchFullState();
        return;
      }
      
      // ‚úÖ Se 3+ giocatori: chiedi a chi passare
      const currIdx=s.giocatori.findIndex(p=>p.id===s.id_giocatore_corrente);
      const opponents = s.giocatori.filter((p, idx) => idx !== currIdx);
      
      // Mostra dialog per scegliere
      const choiceHTML = opponents.map((p, idx) => 
        `<button onclick="confirmPassTo('${p.id}')" style="display:block; width:100%; padding:15px; margin:5px 0; background:#333; color:#fff; border:2px solid #555; border-radius:8px; font-size:1.2em; cursor:pointer;">${p.nome}</button>`
      ).join('');
      
      const overlay = document.createElement('div');
      overlay.id = 'pass-choice-overlay';
      overlay.style = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:9999; display:flex; align-items:center; justify-content:center;';
      overlay.innerHTML = `
        <div style="background:#222; border:3px solid var(--col-neon); padding:30px; border-radius:15px; max-width:400px; width:90%;">
          <h2 style="color:var(--col-neon); margin-top:0;">Passa il turno a...</h2>
          ${choiceHTML}
          <button onclick="document.getElementById('pass-choice-overlay').remove()" style="display:block; width:100%; padding:10px; margin-top:15px; background:#555; color:#aaa; border:1px solid #666; border-radius:8px; cursor:pointer;">ANNULLA</button>
        </div>
      `;
      document.body.appendChild(overlay);
      speak("Scegli a chi passare il turno");
    }
    
    async function confirmPassTo(targetPlayerUUID) {
      const s=currentStanza;
      const targetPlayer = s.giocatori.find(p => p.id === targetPlayerUUID);
      
      document.getElementById('pass-choice-overlay')?.remove();
      
      // ‚úÖ Verifica che il giocatore esista ancora
      if(!targetPlayer) {
        speak("Errore: giocatore non trovato");
        playAudio('snd-miss');
        return;
      }
      
      const myName = document.getElementById('inp-name').value || 'Giocatore';
      
      await _supabase.from('stanze').update({
        id_giocatore_corrente:targetPlayerUUID,
        montepremi_round:0,
        ultima_azione:'passa_avversario',
        ultimo_messaggio:`${myName} passa il turno a ${targetPlayer.nome}`,
        azione_timestamp:DateUtils.now()
      }).eq('id', roomId);
      
      speak(`Hai passato il turno a ${targetPlayer.nome}`);
      await fetchFullState();
    }

    // ‚úÖ ACCESSIBILIT√Ä: Variabile per salvare l'elemento che ha aperto l'input
    let lastFocusedElement = null;
    
    async function openInput(mode){
      // ‚úÖ BLOCCO VOCALI NEL ROUND SPECIALE:
      // Fase 100 (vocali): L'input viene aperto AUTOMATICAMENTE dal loop quando √® il tuo turno
      // Fase 101 (consonanti): Zero vocali permesse
      // Questo blocco previene che il giocatore clicchi manualmente il pulsante VOCALE
      if(mode === 'vowel' && currentStanza) {
        const fase = currentStanza.fase_speciale;
        const isMyTurn = currentStanza.id_giocatore_corrente === myId;
        
        // Durante fase 100: permetti SOLO se √® il tuo turno (chiamata automatica dal loop)
        // Durante fase 101: blocca sempre
        if(fase === 101) {
          speak("Non puoi comprare vocali durante la fase consonanti!");
          playAudio('snd-miss');
          alert("ATTENZIONE: Durante la fase delle 10 consonanti NON si possono comprare vocali!");
          return;
        } else if(fase === 100 && !isMyTurn) {
          // Fase vocali ma non √® il tuo turno: blocca
          speak("Aspetta il tuo turno per scegliere la vocale!");
          playAudio('snd-miss');
          return;
        }
        // Se fase === 100 && isMyTurn: OK, procedi (chiamata automatica dal loop)
      }
      
      // ‚úÖ NUOVO: In modalit√† screen reader senza tastiera, usa overlay speciale per le consonanti
      if(isAccessibleMode && mode === 'letter'){
        const montepremi = currentStanza?.montepremi_round || 0;
        openAccessibleLetterInput(montepremi);
        inputMode = 'letter'; // Mantieni il flag per compatibilit√†
        return;
      }
      
      // ‚úÖ SICUREZZA: Per 'solve', verifica che sia il TUO turno (o che sia la fase 102 del round speciale)
      if(mode === 'solve' && currentStanza) {
        const isMyTurn = (currentStanza.id_giocatore_corrente === myId);
        const canEveryoneSolve = (currentStanza.fase_speciale === 102); // Round speciale, 10 consonanti usate
        
        if(!isMyTurn && !canEveryoneSolve) {
          speak("Non √® il tuo turno.");
          playAudio('snd-miss');
          return;
        }
      }
      
      // ‚úÖ PROBLEMA 2: Controllo della "porta aperta"
      // Se il campo √® gi√† aperto, NON fare NULLA
      // Questo evita di re-forzare il focus mentre l'utente sta scrivendo
      const inputArea = document.getElementById('input-area');
      const isAlreadyOpen = inputArea && !inputArea.classList.contains('hidden');
      
      if(isAlreadyOpen && inputMode) {
        // Il campo √® gi√† aperto - NON toccare nulla
        // L'utente sta gi√† scrivendo, non disturbare
        return;
      }
      
      // ‚úÖ Il campo √® chiuso - possiamo aprirlo
      // ‚úÖ ACCESSIBILIT√Ä: Salva l'elemento attualmente focalizzato
      lastFocusedElement = document.activeElement;
      
      inputMode=mode;
      lastInputMode=mode; 
      inputArea.classList.remove('hidden');
      
      // ‚úÖ NVDA FIX: NON usare role="dialog" e aria-modal="true"!
      // Questi attributi forzano NVDA in Browse Mode (modalit√† navigazione)
      // invece di permettere l'ingresso automatico in Focus Mode
      // Il campo di input √® semplicemente un overlay, non un dialog da esplorare
      
      const inp=document.getElementById('game-input');
      
      
      inp.onkeydown = (e) => {
        if(e.key === 'Enter') {
          e.preventDefault();
          submitInput();
        }
      };
      
      if(mode==='solve') {
        
        // ‚úÖ FIX BUG ASTERISCHI: Ricarica stato fresco dal database prima di generare il template
        // Questo previene che dati "stale" in memoria causino template inconsistenti
        inp.value = "Caricamento...";
        inp.disabled = true;
        
        const { data: freshStanza, error: freshError } = await _supabase
          .from('stanze')
          .select('*, giocatori(*), frasi(*)')
          .eq('id', roomId)
          .single();
        
        inp.disabled = false;
        
        if(freshError || !freshStanza || !freshStanza.frasi) {
          speak("Errore caricamento frase");
          inputArea.classList.add('hidden'); // Chiudi l'input se c'√® errore
          return;
        }
        
        // ‚úÖ FIX RACE CONDITION 10/10: Congela TUTTO lo stato al momento dell'apertura
        // Questo garantisce che il template e la validazione usino dati consistenti
        frozenSolvePuzzleText = currentPuzzleTextWithoutHint; // Solo la parte da indovinare (senza tema)
        frozenSolveFraseId = freshStanza.frase_corrente_id; // L'ID della frase corrente
        
        // ‚úÖ FIX CRITICO: Pulisci lettere_rivelate da indici corrotti PRIMA di congelare
        let cleanRevealedLetters = freshStanza.lettere_rivelate ? [...freshStanza.lettere_rivelate] : [];
        if(cleanRevealedLetters.length > 0) {
          // Conta numero totale di lettere valide
          let letterCount = 0;
          const solClean = currentPuzzleTextWithoutHint.toUpperCase();
          for(let i = 0; i < solClean.length; i++) {
            if(solClean[i].match(/[A-Z√Ä-√ô]/)) {
              letterCount++;
            }
          }
          // Gli indici validi vanno da 0 a letterCount-1
          const maxValidIndex = letterCount - 1;
          
          // Filtra indici corrotti (> maxValidIndex)
          const beforeClean = cleanRevealedLetters.length;
          cleanRevealedLetters = cleanRevealedLetters.filter(idx => idx <= maxValidIndex);
          if(beforeClean !== cleanRevealedLetters.length) {
            console.warn(`‚ö†Ô∏è RISOLVI: Puliti ${beforeClean - cleanRevealedLetters.length} indici corrotti (max: ${maxValidIndex})`);
          }
        }
        
        frozenSolveRevealedLetters = cleanRevealedLetters;
        
        // ‚úÖ OPZIONE B MIGLIORATA: Chiedi SUBITO se vuole copiare
        // L'utente pu√≤ scegliere S√¨/No e se S√¨ viene copiato immediatamente
        const frozenPuzzleText = frozenSolvePuzzleText;
        const frozenRevealedLetters = frozenSolveRevealedLetters;
        
        // Genera template da copiare
        let templateToCopy = "";
        let gIdx = 0;
        let totalLetters = 0;
        let revealedCount = 0;
        
        for(let i = 0; i < frozenPuzzleText.length; i++) {
          const char = frozenPuzzleText[i];
          const charUpper = char.toUpperCase();
          
          if(!charUpper.match(/[A-Z√Ä-√ô]/)) {
            // Non √® una lettera (spazio, punteggiatura)
            templateToCopy += char;
          } else {
            // √à una lettera
            totalLetters++;
            const isRevealed = frozenRevealedLetters.includes(gIdx);
            
            if(isRevealed) {
              // Lettera rivelata: mostrala
              revealedCount++;
              templateToCopy += charUpper;
            } else {
              // Lettera coperta: asterisco
              templateToCopy += '*';
            }
            
            gIdx++;
          }
        }
        
        const missingLetters = totalLetters - revealedCount;
        
        // ‚úÖ Salva template in variabile globale per riferimento
        window.currentSolveTemplate = templateToCopy;
        
        // ‚úÖ NUOVO: Chiedi SUBITO se vuole copiare la frase
        // Se l'utente ha lettere rivelate, chiedi se vuole copiarle negli appunti
        if(revealedCount > 0 && navigator.clipboard && navigator.clipboard.writeText) {
          // Chiedi conferma
          const wantsCopy = confirm(`Vuoi copiare la frase con le lettere rivelate negli appunti?\n\n${templateToCopy}\n\n(${revealedCount}/${totalLetters} lettere rivelate)`);
          
          if(wantsCopy) {
            // Copia SENZA alert di conferma (come richiesto!)
            try {
              await navigator.clipboard.writeText(templateToCopy);
              speak("Copiata"); // Solo annuncio vocale, niente alert
            } catch(err) {
              console.warn("Errore copia:", err);
              speak("Errore nella copia");
            }
          }
        }
        
        // Campo vuoto - l'utente pu√≤ incollare o scrivere da zero
        inp.value = '';
        
        // Suggerimento nel placeholder
        inp.setAttribute('placeholder', `Incolla o scrivi la soluzione (${totalLetters} lettere, ${missingLetters} da indovinare)`);
        
        // ‚úÖ NVDA FIX: NON sostituire l'elemento (replaceChild rompe NVDA)
        // Invece, rimuovi i vecchi listener duplicando solo i listener necessari
        // L'elemento rimane lo stesso, NVDA mantiene il riferimento
        
        // Rimuovi vecchi listener onkeydown se esistono
        inp.onkeydown = null;
        
        // ‚úÖ ACCESSIBILIT√Ä: Aggiungi label e descrizione per screen reader
        inp.setAttribute('aria-label', 'Risolvi');
        // ‚úÖ MOBILE: Ottimizza tastiera per testo completo
        inp.setAttribute('inputmode', 'text');
        
        // ‚úÖ FIX: Per RISOLVI usa solveInputHandler che sostituisce asterischi solo dove digiti
        // Rimuovi entrambi i vecchi handler
        inp.removeEventListener('input', uppercaseInputHandler);
        inp.removeEventListener('input', solveInputHandler);
        
        // Inizializza il valore precedente per il tracking delle modifiche
        lastSolveValue = inp.value;
        
        // Aggiungi quello corretto per RISOLVI
        inp.addEventListener('input', solveInputHandler);
        
        // Re-aggiungi listener per Enter
        inp.onkeydown = (e) => {
          if(e.key === 'Enter') {
            e.preventDefault();
            submitInput();
          }
        };
        
        // ‚úÖ NVDA FIX: speak() viene chiamato DOPO il setTimeout del focus
        // Vedi pi√π in basso (dopo il setTimeout)
      } else {
        inp.value='';
        // ‚úÖ RIMUOVI placeholder per consonanti/vocali (crea confusione per screen reader)
        inp.removeAttribute('placeholder');
        
        // ‚úÖ ACCESSIBILIT√Ä: Label BREVE e chiara per ogni modalit√†
        if(mode==='vowel') {
          inp.setAttribute('aria-label', 'Vocale');
          // ‚úÖ MOBILE: Ottimizza tastiera per lettere
          inp.setAttribute('inputmode', 'text');
          // ‚úÖ NVDA FIX: speak() viene chiamato DOPO il setTimeout del focus
          // Vedi pi√π in basso (dopo il setTimeout)
        } else {
          // ‚úÖ CONSONANTE: aria-label BREVE senza soldi (vengono gi√† annunciati da speak)
          inp.setAttribute('aria-label', 'Consonante');
          // ‚úÖ MOBILE: Ottimizza tastiera per lettere
          inp.setAttribute('inputmode', 'text');
          // ‚úÖ NVDA FIX: speak() viene chiamato DOPO il setTimeout del focus
          // Vedi pi√π in basso (dopo il setTimeout)
        }
      }
      
      // Nascondi/mostra bottoni in base al mode
      const btnCancel = document.getElementById('btn-cancel-input');
      
      if(btnCancel){
        if(mode === 'letter'){
          // Consonante: nascondi ANNULLA
          btnCancel.style.display = 'none';
        } else {
          // Vocale/Risolvi: mostra ANNULLA
          btnCancel.style.display = 'flex';
        }
      }
      
      // ‚úÖ RIMOSSO: Pulsante COPIA FRASE non pi√π necessario
      // Ora chiediamo subito all'apertura se l'utente vuole copiare
      
      // ‚úÖ FIX NVDA: Focus viene impostato UNA SOLA VOLTA quando il campo viene aperto
      // NON verr√† pi√π forzato continuamente da updateUI
      // ‚úÖ FIX iOS SAFARI: Usa requestAnimationFrame invece di setTimeout per mantenere "user gesture"
      // Safari blocca focus() quando chiamato da setTimeout, ma accetta requestAnimationFrame
      requestAnimationFrame(() => {
        const gameInput = document.getElementById('game-input');
        if(gameInput) {
          // ‚úÖ SMARTPHONE FIX: Attiva la tastiera virtuale automaticamente
          // Combo di tecniche per forzare l'apertura della tastiera su tutti i dispositivi
          
          // 1. Focus normale
          gameInput.focus();
          
          // 2. Click per attivare (Safari iOS richiede questo!)
          gameInput.click();
          
          // 3. Seleziona tutto il testo per assicurare che sia editabile
          gameInput.select();
          
          // 4. Se ancora non funziona, forza con setSelectionRange (dopo 1 frame)
          requestAnimationFrame(() => {
            if(gameInput === document.activeElement) {
              gameInput.setSelectionRange(gameInput.value.length, gameInput.value.length);
            }
          });
          
          // ‚úÖ NVDA FIX: speak() viene chiamato DOPO il focus, cos√¨ NVDA √® gi√† in focus mode
          // e l'annuncio non interferisce con l'ingresso nella modalit√† focus
          // CRITICO: Delay di 500ms per dare a NVDA tempo SUFFICIENTE di stabilizzarsi
          // Con 150ms era troppo veloce e NVDA veniva interrotto durante l'ingresso in Focus Mode
          TimerManager.setTimeout(() => {
            if(mode === 'solve') {
              speak("Risolvi. Scrivi la soluzione completa della frase.");
            } 
            // ‚úÖ RIDUZIONE RUMORE: Per vocali e consonanti, NON annunciare nulla
            // L'aria-label del campo input √® sufficiente e pi√π pulita
          }, 500); // ‚úÖ Aumentato da 150ms a 500ms - critico per NVDA!
        }
      }, 100); // Timeout breve per permettere al DOM di aggiornarsi
    }
    
    function tryCancelInput(){
      // Se √® una consonante (letter mode), NON permettere l'annullamento
      if(inputMode === 'letter'){
        playAudio('snd-miss');
        speak("Non puoi annullare la consonante! Devi inserirla.");
        alert("Non puoi annullare!\n\nDevi inserire una consonante dopo aver girato la ruota.");
        return;
      }
      
      // Altrimenti chiudi normalmente (vocale, risolvi)
      closeInput();
    }
    
    // ‚úÖ RIMOSSO: copySolvePhrase() non pi√π necessaria
    // Ora la copia avviene all'apertura tramite confirm()
    
    function closeInput(actionWasCompleted = false){ 
      const inp = document.getElementById('game-input');
      
      // ‚úÖ FIX: Segnala se l'azione √® stata completata
      if(actionWasCompleted) {
        actionJustCompleted = true;
        // Resetta il flag dopo 2 secondi (tempo sufficiente per evitare riaperture accidentali)
        TimerManager.setTimeout(() => {
          actionJustCompleted = false;
        }, 2000);
      }
      
      // ‚úÖ NVDA FIX: NON clonare e sostituire l'elemento (rompe NVDA)
      // Invece, pulisci solo il valore e i listener
      // L'elemento rimane lo stesso, NVDA mantiene il riferimento
      
      if(inputMode !== 'letter') {
        // Per vocale/risolvi, svuota il campo
        inp.value = '';
      }
      // Per consonanti, mantieni il valore (gi√† gestito)
      
      // Rimuovi listener per evitare duplicazioni
      inp.onkeydown = null;
      inp.oninput = null;
      // ‚úÖ FIX MEMORY LEAK: Rimuovi entrambi i listener
      inp.removeEventListener('input', uppercaseInputHandler);
      inp.removeEventListener('input', solveInputHandler);
      
      // Reset stato tracking per RISOLVI
      lastSolveValue = '';
      
      document.getElementById('input-area').classList.add('hidden'); 
      
      // ‚úÖ NUOVO: Chiudi anche l'overlay accessibile se aperto
      const accessibleOverlay = document.getElementById('accessible-letter-input');
      if(accessibleOverlay && !accessibleOverlay.classList.contains('hidden')){
        accessibleOverlay.classList.add('hidden');
        const accessibleInput = document.getElementById('accessible-game-input');
        if(accessibleInput){
          accessibleInput.value = '';
          accessibleInput.onkeydown = null;
        }
      }
      
      inputMode=null;
      
      // ‚úÖ FIX: Aggiorna UI subito dopo aver chiuso l'input per riabilitare i pulsanti
      if(currentStanza){
        updateUI(currentStanza);
      }
      
      // In modalit√† screen reader senza tastiera, ritorna focus su GIRA
      if(isAccessibleMode){
        TimerManager.setTimeout(()=> document.getElementById('btn-acc-spin')?.focus(), 100);
      }
    }

    // ‚úÖ NUOVO: Overlay speciale per input consonante in modalit√† screen reader senza tastiera
    function openAccessibleLetterInput(montepremi){
      const overlay = document.getElementById('accessible-letter-input');
      const input = document.getElementById('accessible-game-input');
      const infoText = document.getElementById('accessible-input-info');
      
      // ‚úÖ RIDUZIONE RUMORE: aria-label semplice (i soldi sono gi√† annunciati prima)
      input.setAttribute('aria-label', 'Consonante');
      
      // Aggiorna info con i soldi girati (visivo)
      infoText.textContent = `Hai girato ${montepremi} ‚Ç¨`;
      
      // Pulisci il campo
      input.value = '';
      
      // Mostra overlay
      overlay.classList.remove('hidden');
      
      // Listener per Enter
      input.onkeydown = (e) => {
        if(e.key === 'Enter') {
          e.preventDefault();
          submitAccessibleLetterInput();
        }
      };
      
      // ‚úÖ FOCUS AUTOMATICO: Il campo √® subito pronto per scrivere
      TimerManager.setTimeout(() => {
        input.focus();
        input.click(); // Per aprire tastiera su mobile
        
        // Annuncio gi√† nell'aria-label del campo, non serve speak aggiuntivo
      }, 100);
    }

    function closeAccessibleLetterInput(){
      const overlay = document.getElementById('accessible-letter-input');
      const input = document.getElementById('accessible-game-input');
      
      // Nascondi overlay
      overlay.classList.add('hidden');
      
      // Pulisci
      input.value = '';
      input.onkeydown = null;
      
      // ‚úÖ CORREZIONE: Reset inputMode per permettere la riapertura del campo
      inputMode = null;
      
      // Ritorna focus su GIRA
      TimerManager.setTimeout(()=> document.getElementById('btn-acc-spin')?.focus(), 100);
    }

    async function submitAccessibleLetterInput(){
      const input = document.getElementById('accessible-game-input');
      const letter = input.value.trim().toUpperCase();
      
      if(!letter || letter.length !== 1){
        speak("Inserisci una sola lettera!");
        playAudio('snd-miss');
        return;
      }
      
      // Verifica che sia una consonante
      const isVowel = "AEIOU".includes(letter);
      if(isVowel){
        speak("Devi inserire una consonante, non una vocale!");
        playAudio('snd-miss');
        input.value = '';
        TimerManager.setTimeout(() => input.focus(), 100);
        return;
      }
      
      // Usa la logica di submitInput per le consonanti
      // Impostiamo temporaneamente inputMode per far funzionare submitInput
      const oldInputMode = inputMode;
      inputMode = 'letter';
      
      // Copia la lettera nel campo normale (per compatibilit√† con submitInput)
      document.getElementById('game-input').value = letter;
      
      // Chiama submitInput - se ha successo, closeInput chiuder√† tutto
      await submitInput();
      
      // Ripristina
      inputMode = oldInputMode;
      
      // ‚úÖ CORREZIONE: Chiudi l'overlay accessibile dopo aver processato la lettera
      closeAccessibleLetterInput();
    }

    function showAccessibleRevealedLetters(){
      // Chiama la funzione esistente per leggere le lettere
      readRevealedLetters();
    }

    async function submitInput(){
      if(isProcessingInput) return;
      
      // ‚úÖ FIX: Verifica che sia ancora il tuo turno prima di processare
      const s = currentStanza;
      const isMe = (s?.id_giocatore_corrente === myId);
      if(!isMe){
        playAudio('snd-miss');
        alert("Non √® pi√π il tuo turno!");
        speak("Errore: non √® pi√π il tuo turno");
        closeInput();
        return;
      }
      
      isProcessingInput=true;
      
      // ‚úÖ SAFETY: Timeout di sicurezza per resettare isProcessingInput se qualcosa va storto
      if(processingInputTimeout) TimerManager.clearTimeout(processingInputTimeout);
      processingInputTimeout = TimerManager.setTimeout(() => {
        if(isProcessingInput) {
          console.warn('SAFETY: isProcessingInput resettato dopo timeout di 10 secondi');
          isProcessingInput = false;
          processingInputTimeout = null;
          if(currentStanza) updateUI(currentStanza);
        }
      }, 10000);
      
      const txt=document.getElementById('game-input').value.trim().toUpperCase();
      if(!txt){ 
        isProcessingInput=false;
        if(processingInputTimeout) TimerManager.clearTimeout(processingInputTimeout);
        processingInputTimeout = null;
        return;
      }
      const mode=inputMode;
      
      // ‚úÖ FIX: Valida l'input PRIMA di chiudere il campo!
      // Se c'√® un errore, lascia il campo aperto per riscrivere
      
      // Validazione per vocali/consonanti
      if(mode === 'vowel' || mode === 'letter') {
        const char = txt.charAt(0);
        const isVowel = "AEIOU".includes(char);
        
        // Controllo vocale al posto di consonante
        if(mode === 'letter' && isVowel) {
          playAudio('snd-miss');
          alert("Devi inserire una CONSONANTE, non una vocale!");
          speak("Errore: hai inserito una vocale invece di una consonante. Riprova.");
          document.getElementById('game-input').value = '';
          document.getElementById('game-input').focus();
          isProcessingInput = false;
          return; // NON chiude il campo, NON passa il turno
        }
        
        // Controllo consonante al posto di vocale
        if(mode === 'vowel' && !isVowel) {
          playAudio('snd-miss');
          alert("Devi inserire una VOCALE, non una consonante!");
          speak("Errore: hai inserito una consonante invece di una vocale. Riprova.");
          document.getElementById('game-input').value = '';
          document.getElementById('game-input').focus();
          isProcessingInput = false;
          return; // NON chiude il campo, NON passa il turno
        }
      }
      
      // ‚úÖ Validazione OK - ora possiamo chiudere il campo
      closeInput();
      const myName=document.getElementById('inp-name').value;
      // Usiamo 's' gi√† dichiarato all'inizio della funzione
      
      

      if(mode==='solve'){
        // ‚úÖ FIX RACE CONDITION: Verifica stato fresco prima di risolvere
        const { data: freshState, error: fetchError } = await _supabase
          .from('stanze')
          .select('*, giocatori(*)')
          .eq('id', roomId)
          .single();
        
        if(fetchError || !freshState) {
          playAudio('snd-miss');
          alert("Errore di connessione. Riprova.");
          isProcessingInput = false;
          return;
        }
        
        // ‚úÖ VALIDAZIONE CRITICA: Verifica che sei ANCORA il giocatore corrente
        if(freshState.id_giocatore_corrente !== myId) {
          playAudio('snd-miss');
          alert("Non √® pi√π il tuo turno!");
          speak("Errore: il turno √® cambiato. Non puoi risolvere.");
          closeInput();
          isProcessingInput = false;
          return;
        }
        
        // ‚úÖ VALIDAZIONE CRITICA 10/10: Verifica che la frase non sia cambiata
        if(frozenSolveFraseId !== null && freshState.frase_corrente_id !== frozenSolveFraseId) {
          playAudio('snd-miss');
          alert("La frase √® cambiata! Il round √® terminato.");
          speak("Errore: la frase √® cambiata durante la risoluzione.");
          closeInput();
          isProcessingInput = false;
          // Reset frozen state
          frozenSolvePuzzleText = null;
          frozenSolveFraseId = null;
          frozenSolveRevealedLetters = null;
          return;
        }
        
        // ‚úÖ CORREZIONE 4 + BUG 8: Normalizzazione migliorata per confronto soluzione
        // - Rimuove asterischi completamente
        // - Normalizza apostrofi curvi/dritti
        // - Gestisce spazi extra
        
        // ‚úÖ BUG FIX 10: Con il nuovo sistema (campo vuoto), non ci sono pi√π asterischi
        // L'utente scrive semplicemente la soluzione completa
        let userAnswer = txt.trim();
        
        // ‚úÖ USA LO STATO CONGELATO per il confronto, non currentPuzzleText che potrebbe essere cambiato
        const correctAnswer = frozenSolvePuzzleText || currentPuzzleTextWithoutHint;
        
        // ‚úÖ CORREZIONE 4: Se l'utente ha lasciato asterischi nella risposta,
        // verifica se le lettere che ha inserito sono almeno corrette
        // Esempio: "CHI D*RME" vs "CHI DORME" ‚Üí accetta se le lettere matchano
        const cleanUser = cleanStr(userAnswer);
        const cleanCorrect = cleanStr(correctAnswer);
        
        if(cleanUser === cleanCorrect){
          playAudio('snd-win'); 
          const me=s.giocatori.find(p=>p.id===myId);
          
          addActionToHistory(`${myName} HA RISOLTO! Soluzione: ${correctAnswer}`);
          
          // ‚úÖ TRACCIAMENTO VINCITORE: Salva chi ha vinto questo round
          previousRoundWinnerUUID = lastRoundWinnerUUID;
          lastRoundWinnerUUID = myId;
          
          await _supabase.from('giocatori').update({punteggio_totale:(me.punteggio_totale||0)+(me.punteggio_round||0)+1000,punteggio_round:0}).eq('id', myId);
          await _supabase.from('stanze').update({stato:'finito',ultima_azione:'vittoria',ultimo_messaggio:`${myName} HA RISOLTO!`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
          
          // ‚úÖ Reset frozen state dopo aver risolto
          frozenSolvePuzzleText = null;
          frozenSolveFraseId = null;
          frozenSolveRevealedLetters = null;
        } else {
          playAudio('snd-miss'); 
          addActionToHistory(`${myName}, Soluzione SBAGLIATA - ${userAnswer}`);
          
          // ‚úÖ ACCESSIBILIT√Ä: Annuncio chiaro del motivo della perdita turno
          speak(`Soluzione sbagliata. Hai scritto: ${userAnswer}. Perdi il turno.`);
          localAnnouncementMade = true;
          
          // ‚úÖ Aggiorna il messaggio nel database prima di passare il turno
          await _supabase.from('stanze').update({
            ultima_azione:'errore',
            ultimo_messaggio:`${myName}, Soluzione SBAGLIATA`,
            azione_timestamp:DateUtils.now()
          }).eq('id', roomId);
          
          passTurn(true); // fromError=true per permetterlo nel round speciale
          
          // ‚úÖ Reset frozen state dopo tentativo sbagliato
          frozenSolvePuzzleText = null;
          frozenSolveFraseId = null;
          frozenSolveRevealedLetters = null;
        }
      } else {
        const char=txt.charAt(0);
        const isVowel="AEIOU".includes(char);
        // ‚úÖ I controlli vocale/consonante sono ora all'inizio di submitInput
        // Non serve ripeterli qui

        if(mode==='vowel'){
          const cost=getVowelCost();
          const me=s.giocatori.find(p=>p.id===myId);
          const myRoundMoney = me ? (me.punteggio_round||0) : 0;
          
          // ‚úÖ FIX RACE CONDITION: Verifica stato fresco prima di comprare vocale
          const { data: freshState, error: fetchError } = await _supabase
            .from('stanze')
            .select('*, giocatori(*)')
            .eq('id', roomId)
            .single();
          
          if(fetchError || !freshState) {
            playAudio('snd-miss');
            alert("Errore di connessione. Riprova.");
            isProcessingInput = false;
            return;
          }
          
          // ‚úÖ VALIDAZIONE CRITICA: Verifica che sei ANCORA il giocatore corrente
          if(freshState.id_giocatore_corrente !== myId) {
            playAudio('snd-miss');
            alert("Non √® pi√π il tuo turno!");
            speak("Errore: il turno √® cambiato. Non puoi comprare la vocale.");
            closeInput();
            isProcessingInput = false;
            return;
          }
          
          vowelsBoughtThisTurn++;
          await _supabase.from('giocatori').update({punteggio_round:myRoundMoney-cost}).eq('id', myId);
          addActionToHistory(`${myName}: Vocale ${char} comprata per ‚Ç¨${cost}`);
        }
        
        
        

        let foundIndices=[]; let gIdx=0;
        const sol=currentPuzzleTextWithoutHint.toUpperCase();
        
        
        if(lettersCalledThisRound.includes(char)) {
          playAudio('snd-miss');
          // ‚úÖ ACCESSIBILIT√Ä: Annuncio pi√π chiaro
          speak(`La lettera ${char} √® gi√† stata chiamata in questo round. Perdi il turno.`);
          localAnnouncementMade = true;
          addActionToHistory(`${myName}, ${char} gi√† chiamata!`);
          await _supabase.from('stanze').update({
            ultima_azione:'errore',
            ultimo_messaggio:`${myName}, ${char} gi√† chiamata!`,
            azione_timestamp:DateUtils.now()
          }).eq('id', roomId);
          passTurn();
          isProcessingInput=false;
          return;
        }
        
        
        lettersCalledThisRound.push(char);
        
        for(let i=0;i<sol.length;i++){
          if(sol[i].match(/[A-Z√Ä-√ô]/)){
            const solChar = sol[i];
            const cleanSolChar = cleanStr(solChar);
            const cleanInputChar = cleanStr(char);
            if(cleanSolChar === cleanInputChar) {
              foundIndices.push(gIdx);
            }
            gIdx++;
          }
        }
        if(foundIndices.length>0){
          
          const newFoundIndices = foundIndices.filter(idx => !(s.lettere_rivelate||[]).includes(idx));
          
          
          if(newFoundIndices.length === 0){
            playAudio('snd-miss'); 
            // ‚úÖ ACCESSIBILIT√Ä: Annuncio pi√π chiaro
            speak(`La lettera ${char} √® gi√† stata rivelata. Perdi il turno.`);
            localAnnouncementMade = true;
            addActionToHistory(`${myName}, ${char} gi√† rivelata!`);
            await _supabase.from('stanze').update({
              ultima_azione:'errore',
              ultimo_messaggio:`${myName}, ${char} gi√† rivelata!`,
              azione_timestamp:DateUtils.now()
            }).eq('id', roomId);
            passTurn();
            isProcessingInput=false;
            return;
          }
          
          // ‚úÖ FIX: NON riprodurre il suono qui - verr√† riprodotto da updateUI
          // quando riceveremo l'aggiornamento dal server. Altrimenti si sovrappone!
          // playMultipleHits(newFoundIndices.length); // <- RIMOSSO
          
          const newRev=[...new Set([...(s.lettere_rivelate||[]), ...foundIndices])];
          if(mode==='letter'){
            
            // ‚úÖ CORREZIONE CRITICA: Resetta vowelsBoughtThisTurn SOLO se hai trovato una CONSONANTE
            // Questo permette di comprare una vocale nel prossimo turno (prima di girare di nuovo)
            // REGOLA: GIRA ‚Üí CONSONANTE (trovata) ‚Üí reset ‚Üí puoi COMPRARE VOCALE o GIRARE
            const isConsonant = !"AEIOU".includes(char.toUpperCase());
            if(isConsonant) {
              vowelsBoughtThisTurn = 0;
            }
            
            const me=s.giocatori.find(p=>p.id===myId);
            
            // ‚úÖ FIX RACE CONDITION: Ricarica lo stato fresco dal DB prima di aggiornare
            const { data: freshState, error: fetchError } = await _supabase
              .from('stanze')
              .select('*, giocatori(*), frasi(*)')
              .eq('id', roomId)
              .single();
            
            if(fetchError || !freshState) {
              playAudio('snd-miss');
              alert("Errore di connessione. Riprova.");
              isProcessingInput = false;
              return;
            }
            
            // ‚úÖ VALIDAZIONE CRITICA: Verifica che sei ANCORA il giocatore corrente
            if(freshState.id_giocatore_corrente !== myId) {
              playAudio('snd-miss');
              alert("Non √® pi√π il tuo turno!");
              speak("Errore: il turno √® cambiato. Non puoi pi√π inserire lettere.");
              closeInput();
              isProcessingInput = false;
              return;
            }
            
            const gain = (s.fase_speciale===3) ? (s.montepremi_round||0) : ((s.montepremi_round||0) * newFoundIndices.length);
            
            // ‚úÖ FIX CRITICO: Aggiorna cache locale PRIMA dell'update DB
            // Questo previene che updateUI() riapra il campo prima che il DB si aggiorni
            if(currentStanza) {
              currentStanza.montepremi_round = 0;
              currentStanza.fase_speciale = 0;
              // ‚úÖ IMMEDIATO: Chiama updateUI subito per riabilitare il pulsante GIRA
              // DEVE usare currentStanza aggiornato, non aspettare il fetch DB
              await updateUI(currentStanza);
            }
            
            const resultMsg = `Trovate ${newFoundIndices.length} ${char}. Guadagni ${gain} euro`;
            speak(resultMsg);
            localAnnouncementMade = true;
            addActionToHistory(`${myName}: ${char} - Trovate ${newFoundIndices.length}, guadagno ‚Ç¨${gain}`);
            
            await _supabase.from('giocatori').update({punteggio_round:(me.punteggio_round||0)+gain}).eq('id', myId);
            
            // ‚úÖ CONSONANTE TROVATA: Aggiorna DB e MANTIENI turno (no passTurn)
            await _supabase.from('stanze').update({lettere_rivelate:newRev,montepremi_round:0,ultima_azione:'chiama_lettera',ultimo_messaggio:`${myName}, Trovate ${newFoundIndices.length} ${char}`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
            // ‚úÖ CORRETTO: NON chiamare passTurn() qui - se la consonante √® trovata mantieni il turno!
          } else {
            // ‚úÖ VOCALE COMPRATA E TROVATA
            // Se siamo qui, newFoundIndices.length √® sempre > 0 (altrimenti avremmo fatto return prima)
            speak(`Trovate ${newFoundIndices.length} ${char}`);
            
            await _supabase.from('stanze').update({lettere_rivelate:newRev,ultima_azione:'chiama_lettera',ultimo_messaggio:`${myName}, Trovate ${newFoundIndices.length} ${char}`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
            // ‚úÖ CORRETTO: NON chiamare passTurn() qui - se la vocale √® trovata mantieni il turno!
          }
        } else {
          // ‚úÖ LETTERA NON TROVATA (consonante o vocale)
          playAudio('snd-miss'); 
          
          // ‚úÖ ACCESSIBILIT√Ä: Annuncio chiaro e completo del motivo della perdita turno
          const letterType = isVowel ? 'vocale' : 'consonante';
          speak(`La ${letterType} ${char} non √® presente nella frase. Perdi il turno.`);
          localAnnouncementMade = true;
          addActionToHistory(`${myName}: ${char} NON PRESENTE`);
          await _supabase.from('stanze').update({ultima_azione:'errore',ultimo_messaggio:`${myName}: ${char} assente`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
          await passTurn();
          }
        }
      
      TimerManager.setTimeout(async () => {
        if(roomId) await fetchFullState();
        isProcessingInput=false; // ‚úÖ Reset DOPO il fetch, cos√¨ updateUI vede i dati freschi
        if(processingInputTimeout) TimerManager.clearTimeout(processingInputTimeout); // ‚úÖ Cancella timeout di sicurezza
        processingInputTimeout = null;
        
        // ‚úÖ SMARTPHONE FIX: Dopo aver trovato una consonante, aspetta 1 secondo e poi 
        // forza un altro fetch per assicurarsi che il pulsante GIRA sia riabilitato
        // Questo risolve race condition dove isProcessingInput blocca canSpin
        TimerManager.setTimeout(async () => {
          if(roomId) await fetchFullState();
        }, 1000);
      }, 100); // ‚úÖ Ridotto a 100ms per reattivit√† ottimale
    }

    function checkTurnTimer(){
      if(!currentStanza || currentStanza.in_pausa || currentStanza.stato!=='gioco') return;
      
      // Non controllare il timer se l'utente sta facendo qualcosa
      if(isSpinning || isProcessingInput) return;
      
      // ‚úÖ FIX: Non passare automaticamente il turno se l'utente √® in modalit√† input
      // (sta scrivendo una consonante, vocale o soluzione)
      if(inputMode) return;
      
      // ‚úÖ FIX CHATGPT: Usa SOLO azione_timestamp dal DB (fonte di verit√† unica)
      const timestampToUse = currentStanza.azione_timestamp;
      
      // ‚úÖ CORREZIONE 2: Usa l'offset server-client per calcolare il tempo rimanente
      const currentClientTime = Date.now();
      const adjustedServerTime = currentClientTime + serverTimeOffset;
      const serverActionTime = new Date(timestampToUse).getTime();
      
      const elapsed = Math.floor((adjustedServerTime - serverActionTime) / 1000);
      
      if(isNaN(elapsed) || elapsed > 10000 || elapsed < -100) return;
      const left=Math.max(0, TURN_LIMIT_SEC - elapsed);
      document.getElementById('timer-box').textContent=left;
      
      // ‚úÖ Quando il timer scade, passa il turno (anche se sei tu a giocare)
      if(left===0 && isHost && !isHandlingTimeout) {
        passTurn();
      }
    }

    async function fetchChat(showAll = false){
      const {data:msgs}=await _supabase.from('chat_messaggi').select('*').eq('stanza_id', roomId).order('created_at',{ascending:true}).limit(50);
      if(!msgs || msgs.length === 0) {
        const c=document.getElementById('chat-messages');
        c.innerHTML="<p style='color:#777;text-align:center;'>Nessun messaggio</p>";
        return;
      }
      
      const c=document.getElementById('chat-messages'); 
      c.innerHTML="";
      
      if(showAll) {
        
        msgs.forEach(m=>{
          const d=document.createElement('div');
          d.style="border-bottom:1px solid #333; margin-bottom:5px; padding:8px;";
          // ‚ùå Rimosso tabIndex per evitare letture multiple
          // Gli annunci vengono gestiti da speakChat() quando arrivano nuovi messaggi
          
          // Check if it's a sound effect
          if(m.messaggio.startsWith('[SOUND:')){
            const soundMatch = m.messaggio.match(/\[SOUND:([^\]]+)\](.+)/);
            if(soundMatch){
              const soundName = escapeHTML(soundMatch[2]);
              d.innerHTML=`<strong style="color:var(--col-accent);">${escapeHTML(m.giocatore_nome)}</strong> <span style="color:#aaa;">ha fatto:</span> <strong style="color:var(--col-neon); font-size:1.2em;">${soundName}</strong>`;
            }
          } else {
            d.innerHTML=`<strong style="color:var(--col-accent);">${escapeHTML(m.giocatore_nome)}:</strong> ${escapeHTML(m.messaggio)}`;
          }
          c.appendChild(d);
        });
        c.scrollTop=c.scrollHeight;
      } else {
        
        const lastMsg = msgs[msgs.length - 1];
        const d=document.createElement('div');
        d.style="border-bottom:1px solid #333; margin-bottom:5px; padding:8px; font-size:1.1em;";
        // ‚ùå Rimosso tabIndex per evitare letture multiple
        // Gli annunci vengono gestiti da speakChat() quando arrivano nuovi messaggi
        
        // Check if it's a sound effect
        if(lastMsg.messaggio.startsWith('[SOUND:')){
          const soundMatch = lastMsg.messaggio.match(/\[SOUND:([^\]]+)\](.+)/);
          if(soundMatch){
            const soundName = escapeHTML(soundMatch[2]);
            d.innerHTML=`<strong style="color:var(--col-accent);">${escapeHTML(lastMsg.giocatore_nome)}</strong> <span style="color:#aaa;">ha fatto:</span> <strong style="color:var(--col-neon); font-size:1.2em;">${soundName}</strong>`;
          }
        } else {
          d.innerHTML=`<strong style="color:var(--col-accent);">${escapeHTML(lastMsg.giocatore_nome)}:</strong> ${escapeHTML(lastMsg.messaggio)}`;
        }
        c.appendChild(d);
        
        
        if(msgs.length > 1) {
          const hint=document.createElement('p');
          hint.style="color:#888; font-size:0.9em; margin-top:10px; text-align:center;";
          hint.innerHTML=" Usa Shift+Tab dal campo input per vedere tutti i messaggi";
          c.appendChild(hint);
        }
      }
    }
    
    function openChat(){ 
       document.getElementById('chat-overlay').classList.remove('hidden'); 
       fetchChat(false); 
       
       
       TimerManager.setTimeout(() => {
         speak("Chat aperta. Premi Shift Tab per vedere la cronologia completa.");
         
         const chatInput = document.getElementById('chat-input');
         chatInput.focus();
         
         
         chatInput.onkeydown = null;
         
         
         chatInput.addEventListener('keydown', (e) => {
           if(e.key === 'Tab' && e.shiftKey) {
             e.preventDefault();
             fetchChat(true); 
             speak("Visualizzazione cronologia completa. Usa le frecce per navigare tra i messaggi.");
             
             TimerManager.setTimeout(() => {
               const firstMsg = document.getElementById('chat-messages').querySelector('div[tabindex="0"]');
               if(firstMsg) firstMsg.focus();
             }, 100);
           } else if(e.key === 'Enter') {
             e.preventDefault();
             sendChatMessage();
           }
         });
       }, 150);
    }
    
    async function sendChatMessage(){
      const t=document.getElementById('chat-input').value.trim();
      if(!t) return;
      await _supabase.from('chat_messaggi').insert({stanza_id:roomId, giocatore_nome:document.getElementById('inp-name').value, messaggio:t});
      document.getElementById('chat-input').value="";
      fetchChat(false); 
      document.getElementById('chat-input').focus();
    }

    async function startNewRound(){
      if(!isHost) return;
      let n=currentStanza.round_giocati + 1;
      if(n>10){ await _supabase.from('stanze').update({stato:'terminata'}).eq('id', roomId); return; }
      
      // ‚úÖ LOGICA INIZIO ROUND: Determina chi inizia questo round
      let startingPlayerUUID = null;
      
      if(n === 1){
        // Primo round: inizia l'host
        const hostPlayer = currentStanza.giocatori.find(p => p.is_host);
        startingPlayerUUID = hostPlayer?.id || currentStanza.giocatori[0]?.id;
      } else {
        // Round successivi: logica basata sul vincitore precedente
        if(lastRoundWinnerUUID === previousRoundWinnerUUID && lastRoundWinnerUUID !== null){
          // Lo stesso giocatore ha vinto 2 volte consecutive
          // Inizia chi ha iniziato meno round
          const players = currentStanza.giocatori;
          let minStarts = Infinity;
          let playerWithMinStarts = null;
          
          for(const player of players){
            const starts = playerRoundStarts[player.id] || 0;
            if(starts < minStarts){
              minStarts = starts;
              playerWithMinStarts = player.id;
            }
          }
          
          startingPlayerUUID = playerWithMinStarts || players[0]?.id;
        } else {
          // Caso normale: inizia il vincitore del round precedente
          // Verifica che il vincitore esista ancora
          const winnerExists = currentStanza.giocatori.some(p => p.id === lastRoundWinnerUUID);
          if(winnerExists){
            startingPlayerUUID = lastRoundWinnerUUID;
          } else {
            // Il vincitore √® uscito, inizia il primo giocatore disponibile
            startingPlayerUUID = currentStanza.giocatori[0]?.id;
          }
        }
      }
      
      // Incrementa il contatore di round iniziati per questo giocatore
      if(startingPlayerUUID){
        playerRoundStarts[startingPlayerUUID] = (playerRoundStarts[startingPlayerUUID] || 0) + 1;
      }
      
      // ‚úÖ PULIZIA JOLLY SCADUTI: Rimuovi i jolly scaduti da tutti i giocatori
      const allPlayers = currentStanza.giocatori || [];
      for(const player of allPlayers) {
        if(Array.isArray(player.scadenza_jolly) && player.scadenza_jolly.length > 0) {
          const validJollies = player.scadenza_jolly.filter(expiryRound => expiryRound >= n);
          if(validJollies.length !== player.scadenza_jolly.length) {
            // Ci sono jolly scaduti, aggiorna il database
            await _supabase.from('giocatori').update({scadenza_jolly: validJollies}).eq('id', player.id);
          }
        }
      }
      
      lettersCalledThisRound = [];
      
      // ‚úÖ MODIFICATO: Tutti i round usano frasi casuali da TUTTE le categorie
      const {data:fr}=await _supabase.from('frasi').select('id,categoria').limit(500);
      if(!fr || fr.length === 0){
        speak("Errore: nessuna frase disponibile");
        return;
      }
      
      const rid = fr[Math.floor(Math.random()*fr.length)].id;
      
      await _supabase.from('giocatori').update({punteggio_round:0}).eq('stanza_id', roomId);
      await _supabase.from('stanze').update({frase_corrente_id:rid,stato:'gioco',round_giocati:n,lettere_rivelate:[],montepremi_round:0,id_giocatore_corrente:startingPlayerUUID,ultima_azione:'nuovo',ultimo_messaggio:`Inizio Round ${n}`,azione_timestamp:DateUtils.now()}).eq('id', roomId);
    }
    

    async function leaveGame(){
      // ‚úÖ CORREZIONE CHATGPT: Ferma ping periodico
      stopPeriodicPing();
      
      // Cleanup channels and timers
      if(gameChannel) {
        await gameChannel.unsubscribe();
        gameChannel = null;
      }
      if(playersChannel) { // ‚úÖ CORREZIONE CHATGPT
        await playersChannel.unsubscribe();
        playersChannel = null;
      }
      if(chatChannel) {
        await chatChannel.unsubscribe();
        chatChannel = null;
      }
      if(turnTimerInterval) {
        TimerManager.clearInterval(turnTimerInterval);
        turnTimerInterval = null;
      }
      if(nextRoundInterval) {
        TimerManager.clearInterval(nextRoundInterval);
        nextRoundInterval = null;
      }
      
      if(roomId && myId){
        if(isHost){
          if(confirm("Sei l'host! Vuoi chiudere la stanza per tutti?")){
            await closeRoom();
            return;
          } else {
            
            await _supabase.from('giocatori').delete().eq('id', myId);
          }
        } else {
          
          await _supabase.from('giocatori').delete().eq('id', myId);
        }
      }
      
      
      
      document.getElementById('game-panel').classList.add('hidden');
      document.getElementById('setup-panel').classList.remove('hidden');
      
      // ‚úÖ FIX: Non riempire automaticamente i campi quando esci
      // Gli utenti con screen reader preferiscono campi vuoti
      // I valori sono comunque salvati in localStorage se vogliono rientrare
      
      // Reset display
      const displayName = document.getElementById('inp-name-display');
      const displayCode = document.getElementById('inp-code-display');
      if(displayName) displayName.textContent = '(vuoto)';
      if(displayCode) displayCode.textContent = '(vuoto)';
      
      
      roomId = null;
      myId = null;
      myIndex = null;
      isHost = false;
      currentStanza = null;
      
      speak("Sei uscito dalla stanza.");
    }
    async function closeRoom(){ 
      await _supabase.from('stanze').delete().eq('id', roomId); 
      localStorage.removeItem('lastRoomCode');
      localStorage.removeItem('lastPlayerName');
      location.reload(); 
    }
    
    async function surrenderPhrase(){
      if(!isHost) return;
      
      if(confirm("Arrenditi?")){
        const result = await safeQuery(
          () => _supabase.from('stanze').update({
            stato:'finito',
            ultima_azione:'arresa',
            ultimo_messaggio:'HOST SI √à ARRESO',
            azione_timestamp:DateUtils.now()
          }).eq('id', roomId),
          'Resa partita'
        );
        if (!result.success) {
          speak("Errore nell'arrendersi");
        }
      }
    }
    
    async function resetGame(){
      if(!confirm("Reset partita? Tutti i punteggi saranno azzerati.")) return;
      
      // ‚úÖ RESET TRACCIAMENTO VINCITORI
      lastRoundWinnerUUID = null;
      previousRoundWinnerUUID = null;
      playerRoundStarts = {};
      
      // Reset punteggi
      const playersResult = await safeQuery(
        () => _supabase.from('giocatori').update({
          punteggio_totale: 0, 
          punteggio_round: 0
        }).eq('stanza_id', roomId),
        'Reset punteggi giocatori'
      );
      
      if (!playersResult.success) {
        speak("Errore nel reset punteggi");
        return;
      }
      
      // Reset stanza
      const roomResult = await safeQuery(
        () => _supabase.from('stanze').update({
          round_giocati: 0, 
          lettere_rivelate: [],
          montepremi_round: 0
        }).eq('id', roomId),
        'Reset stanza'
      );
      
      if (!roomResult.success) {
        speak("Errore nel reset stanza");
        return;
      }
      
      // Riorganizza giocatori e turni
      await reorganizePlayers();
      
      // Avvia nuovo round
      await startNewRound();
      
      speak("Partita resettata. Nuovo round iniziato.");
    }
    
    
    // ==========================================
    // GESTIONE AUDIO
    // ==========================================
    
    let audioEnabled = true;
    let audioContext = null;
    
    function initAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }
    
    function playSound(frequency, duration = CONFIG.SOUND_DURATIONS.MEDIUM, type = 'sine') {
      if (!audioEnabled) return;
      
      const ctx = initAudioContext();
      if (!ctx) {
        console.warn('AudioContext non disponibile');
        return;
      }
      
      try {
        if (ctx.state === 'suspended') {
          ctx.resume();
        }
        
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        const now = ctx.currentTime;
        const durationSeconds = duration / 1000;
        
        gainNode.gain.setValueAtTime(CONFIG.AUDIO_VOLUME, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + durationSeconds);
        
        oscillator.start(now);
        oscillator.stop(now + durationSeconds);
        
        oscillator.onended = () => {
          oscillator.disconnect();
          gainNode.disconnect();
        };
      } catch(error) {
        console.error('Errore riproduzione suono:', error);
      }
    }
    
    function playRandomCorrectSound() {
      if (!audioEnabled) return;
      const frequencies = CONFIG.FREQUENCIES.CORRECT;
      const randomFreq = frequencies[Math.floor(Math.random() * frequencies.length)];
      playSound(randomFreq, CONFIG.SOUND_DURATIONS.SHORT, 'sine');
      TimerManager.setTimeout(() => playSound(randomFreq * 1.5, CONFIG.SOUND_DURATIONS.MEDIUM, 'sine'), 70);
    }
    
    function playIncorrectSound() {
      if (!audioEnabled) return;
      playSound(CONFIG.FREQUENCIES.INCORRECT[0], 80, 'sawtooth');
      TimerManager.setTimeout(() => playSound(CONFIG.FREQUENCIES.INCORRECT[1], 120, 'sawtooth'), 90);
    }
    
    function playWheelSpinSound() {
      if (!audioEnabled) return;
      let freq = CONFIG.FREQUENCIES.WHEEL_START;
      let intervalCount = 0;
      const maxIntervals = 20;
      
      const spinInterval = TimerManager.setInterval(() => {
        if (intervalCount >= maxIntervals) {
          TimerManager.clearInterval(spinInterval);
          return;
        }
        
        playSound(freq, 50, 'square');
        freq += 50;
        if (freq > CONFIG.FREQUENCIES.WHEEL_MAX) {
          freq = CONFIG.FREQUENCIES.WHEEL_START;
        }
        intervalCount++;
      }, 100);
      
      TimerManager.setTimeout(() => TimerManager.clearInterval(spinInterval), CONFIG.WHEEL_SPIN_DURATION_MS);
    }
    
    function playSuccessSound() {
      if (!audioEnabled) return;
      playSound(523.25, CONFIG.SOUND_DURATIONS.MEDIUM);
      TimerManager.setTimeout(() => playSound(659.25, CONFIG.SOUND_DURATIONS.MEDIUM), 120);
      TimerManager.setTimeout(() => playSound(783.99, CONFIG.SOUND_DURATIONS.LONG), 240);
    }
    
    function toggleAudio() {
      audioEnabled = !audioEnabled;
      const btn = document.getElementById('btn-toggle-audio');
      if (btn) {
        btn.textContent = audioEnabled ? 'Audio ON' : 'Audio OFF';
      }
      const accBtn = document.getElementById('btn-acc-audio');
      if (accBtn) {
        accBtn.textContent = audioEnabled ? 'AUDIO ON' : 'AUDIO OFF';
      }
      if (audioEnabled) {
        playSound(440, CONFIG.SOUND_DURATIONS.MEDIUM);
      }
    }
    
    // ==========================================
    // SISTEMA PING PERIODICO
    // ==========================================
    
    function startPeriodicPing(){
      if(pingInterval) TimerManager.clearInterval(pingInterval);
      
      sendPing();
      
      pingInterval = TimerManager.setInterval(async () => {
        await sendPing();
      }, CONFIG.PING_INTERVAL_MS);
    }
    
    async function sendPing() {
      if(!myId || !roomId) return;
      
      try {
        await _supabase
          .from('giocatori')
          .update({ultimo_ping: DateUtils.now()})
          .eq('id', myId);
      } catch(error) {
        console.error('Errore ping:', error);
        if (error.message?.includes('network')) {
          TimerManager.setTimeout(() => sendPing(), 5000);
        }
      }
    }
    
    function stopPeriodicPing(){
      if(pingInterval){
        TimerManager.clearInterval(pingInterval);
        pingInterval = null;
      }
    }
    
    // ==========================================
    // CLEANUP E GESTIONE LIFECYCLE
    // ==========================================
    
    async function cleanupSubscriptions() {
      const cleanupPromises = [];
      
      if (gameChannel) {
        console.log('Chiusura gameChannel...');
        cleanupPromises.push(
          gameChannel.unsubscribe()
            .then(() => { gameChannel = null; })
            .catch(err => console.error('Errore cleanup gameChannel:', err))
        );
      }
      
      if (playersChannel) {
        console.log('Chiusura playersChannel...');
        cleanupPromises.push(
          playersChannel.unsubscribe()
            .then(() => { playersChannel = null; })
            .catch(err => console.error('Errore cleanup playersChannel:', err))
        );
      }
      
      if (chatChannel) {
        console.log('Chiusura chatChannel...');
        cleanupPromises.push(
          chatChannel.unsubscribe()
            .then(() => { chatChannel = null; })
            .catch(err => console.error('Errore cleanup chatChannel:', err))
        );
      }
      
      await Promise.allSettled(cleanupPromises);
      console.log('‚úÖ Tutte le subscriptions chiuse');
    }
    
    // Cleanup quando la pagina viene scaricata
    window.addEventListener('beforeunload', async function() {
      console.log('Cleanup risorse...');
      
      stopPeriodicPing();
      TimerManager.clearAll();
      
      if (audioContext && audioContext.state !== 'closed') {
        try {
          await audioContext.close();
          console.log('‚úÖ AudioContext chiuso');
        } catch (err) {
          console.error('Errore chiusura AudioContext:', err);
        }
      }
      
      await cleanupSubscriptions();
    });
    
    // Gestione visibility change per ottimizzare risorse
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        // Pagina nascosta: pausa audio context
        if (audioContext && audioContext.state === 'running') {
          audioContext.suspend();
          console.log('AudioContext sospeso (pagina nascosta)');
        }
      } else {
        // Pagina visibile: riprendi audio context
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
          console.log('AudioContext ripreso (pagina visibile)');
        }
      }
    });
    
  </script>
</body>
</html>